# Linux 共享库的组织

### 共享库兼容性

开发一个导出接口为 C++ 的共享库，要注意以下事项，以防止 ABI 不兼容：

- 不要在接口类中使用虚函数，万不得已要使用虚函数时，不要随意删除、添加或在子类中添加新的实现函数，这样会导致类的虚函数表结构发生变化。
- 不要改变类中任何成员变量的位置和类型。
- 不要删除非内嵌的 `public` 或 `protected` 成员函数。
- 不要将非内嵌的成员函数改变成内嵌成员函数。
- 不要改变成员函数的访问权限。
- 不要在接口中使用模板。
- 最重要的是，不要改变接口的任何部分或干脆不要使用 C++ 作为共享库接口！

## 共享库系统路径

FHS（File Hierarchy Standard）规定，一个系统中主要有 3 个存放共享库的位置，它们分别如下：

- /lib，这个位置主要存放系统最关键和基础的共享库，比如动态链接器、C 语言运行库、数学库等，这些库主要是那些 /bin 和 /sbin 下的程序所要用到的库，还有系统启动时需要的库。
- /usr/lib，这个目录下主要保存的是一些非系统运行时所需要的关键性的共享库，主要是一些开发时用到的共享库，这些共享库一般不会被用户的程序或 shell 脚本直接用到。这个目录下面还包含了开发时可能会用到的静态库、目标文件等。
- /usr/local/lib，这个目录用来放置一些跟操作系统本身并不十分相关的库，主要是一些第三方的应用程序的库。比如我们在系统中安装了 python 语言的解释器，那么与它相关的共享库可能会被放到 /usr/local/lib/python，而它的可执行文件可能被放到 /usr/local/bin 下。GNU 的标准推荐第三方的程序应该默认将库安装到 /usr/local/lib 下。

所以总体来看，/lib 和 /usr/lib 是一些很常用的、成熟的，一般是系统本身所需要的库；而 /usr/local/lib 是非系统所需的第三方程序的共享库。

## 共享库查找过程

Linux 系统中都有一个叫做 ldconfig 的程序，这个程序的作用是为共享库目录下的各个共享库创建、删除或更新相应的 SO-NAME（即相应的符号链接），这样每个共享库的 SO-NAME 就能够指向正确的共享库文件；并且这个程序还会将这些 SO-NAME 收集起来，集中存放到 /etc/ld.so.cache 文件里面，并建立一个 SO-NAME 的缓存。当动态链接器要查找共享库时，它可以直接从 /etc/ld.so.cache 里面查找。

如果动态链接器在 /etc/ld.so.cache 里面没有找到所需要的共享库，那么它还会遍历 /lib 和 /usr/lib 这两个目录，如果还是没找到，就宣告失败。

所以理论上讲，如果我们在系统指定的共享库目录下添加、删除或更新任何一个共享库，或者我们更改了 /etc/ld.so.conf 的配置，都应该运行 ldconfig 这个程序，以便调整 SO-NAME 和 /etc/ld.so.cache。很多软件包的安装程序在往系统里面安装共享库以后都会调用 ldconfig。

## 环境变量

动态链接器会按照下列顺序依次装载或查找共享对象（目标文件）：

- 由环境变量 LD_LIBRARY_PATH 指定的路径。
- 由路径缓存文件 /etc/ld.so.cache 指定的路径。
- 默认共享库目录，先 /usr/lib，然后 /lib。

在 LD_PRELOAD 里面指定的文件会在动态链接器按照固定规则搜索共享库之前装载，它比 LD_LIBRARY_PATH 里面所指定的目录中的共享库还要优先。无论程序是否依赖于它们，LD_PRELOAD 里面指定的共享库或目标文件都会被装载。

LD_DEBUG 可以打开动态链接器的调试功能。

## 共享库的创建和安装

### 共享库的创建

创建共享库最关键的是使用 GCC 的两个参数，即 `-shared` 和 `-fPIC`。`-shared` 表示输出结果是共享库类型的；`-fPIC` 表示使用地址无关代码（Position Independent Code）技术来生产输出文件。另外还有一个参数是 `-WI` 参数，这个参数可以将指定的参数传递给链接器，比如当我们使用 `-WI、-soname、my_soname` 时，GCC 会将 `-soname my_soname` 传递给链接器，用来指定输出共享库的 SO-NAME。

### 清除符号信息

使用 `strip` 工具清除掉共享库或可执行文件的所有符号和调试信息。