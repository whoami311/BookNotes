# 温故而知新

1. 线程的访问权限

线程的访问非常自由，它可以访问进程内存里的所有数据，甚至包括其他线程的堆栈（如果它知道其他线程的堆栈地址，那么这就是很少见的情况），但实际运用中线程也拥有自己的私有存储空间，包括以下几方面。

- 栈（尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有的数据）。
- 线程局部存储（Thread Local Storage，TLS）。线程局部存储是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。
- 寄存器（包括 PC 寄存器），寄存器是执行流的基本数据，因此为线程私有。

从 C 程序员的角度来看，数据在线程之间是否私有如表所示。

| 线程私有 | 线程之间共享（进程所有） |
| - | - |
| <li>局部变量</li><li>函数的参数</li><li>TLS数据</li> | <li>全局变量</li><li>堆上的数据</li><li>函数里的静态变量</li><li>程序代码，任何线程都有权利读取并执行任何代码</li><li>打开的文件，A 线程打开的文件可以由 B 线程读写</li> |

2. 线程调度与优先级

当线程数量小于等于处理器数量时（并且操作系统支持多处理器），线程的并发是真正的并发，不同的线程运行在不同的处理器上，彼此之间互不相干。但对于线程数量大于处理器数量的情况，线程的并发会受到一些阻碍，因为此时至少有一个处理器会运行多个线程。

在单处理器对应多线程的情况下，并发是一种模拟出来的状态。操作系统会让这些多线程程序轮流执行，每次仅执行一小段时间（通常是几十到几百毫秒），这样每个线程就“看起来”在同时执行。这样的一个不断在处理器上切换不同的线程的行为称之为**线程调度（Thread Schedule）**。在线程调度中，线程通常拥有至少三种状态，分别是：

- **运行（Running）**：此时线程正在执行。
- **就绪（Ready）**：此时线程可以立刻运行，但 CPU 已经被占用。
- **等待（Waiting）**：此时线程正在等待某一事件（通常是 I/O 或同步）发生，无法执行。

处于运行中线程拥有一段可以执行的时间，这段时间称为**时间片（Time Slice）**，当时间片用尽的时候，该进程将进入就绪状态。如果在时间片用尽之前进程就开始等待某事件，那么它将进入等待状态。每当一个线程离开运行状态时，调度系统就会选择一个其他的就绪线程继续执行。在一个处于等待状态的线程所等待的事件发生之后，该线程将进入就绪状态。

我们一般把频繁等待的线程称之为 **IO 密集型线程（IO Bound Thread）**，而把很少等待的线程称为 **CPU 密集型线程（CPU Bound Thread）**。IO 密集型线程总是比 CPU 密集型线程容易得到优先级的提升。

在优先级调度的环境下，线程的优先级改变一般有三种方式。

- 用户指定优先级。
- 根据进入等待状态的频繁程度提升或降低优先级。
- 长时间得不到执行而被提升优先级。

3. 线程安全

一个函数要成为可重入的，必须具如下几个特点：

- 不使用任何（局部）静态或全局的非 `const` 变量。
- 不返回任何（局部）静态或全局的非 `const` 变量的指针。
- 仅依赖于调用方提供的参数。
- 不依赖任何单个资源的锁（mutex 等）。
- 不调用任何不可重入的函数。

`volatile` 基本可以做到两件事情：

1. 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回。
2. 阻止编译器调整操作 `volatile` 变量的指令顺序。