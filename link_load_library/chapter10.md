# 内存

## 栈与调用惯例

### 栈

栈保存了一个函数调用所需要的维护信息，这常常被称为**堆栈帧（Stack Frame）**或**活动记录（Activate Record）**。堆栈帧一般包括如下几方面内容：

- 函数的返回地址和参数。
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。
- 保存的上下文：包括在函数调用前后需要保持不变的寄存器。

### 调用惯例

一个**调用惯例（Calling Convention）**一般会规定如下几个方面的内容。

- 函数参数的传递顺序和方式
- 栈的维护方式
- 名字修饰（Name-mangling）的策略

## 堆与内存管理

### Linux 进程堆管理

Linux 提供了两种堆空间分配的方式，即两个系统调用：一个是 `brk()` 系统调用，另外一个是 `mmap()`。

glic 的 `malloc` 函数是这样处理用户的空间请求的：对于小于 128KB 的请求来说，它会在现有的堆空间里面，按照堆分配算法为它分配一块空间并返回；对于大于 128KB 的请求来说，它会使用 `mmap()` 函数为它分配一块匿名空间，然后在这个匿名空间中为用户分配空间。

### 堆分配算法

1. 空闲链表

**空闲链表（Free List）**的方法实际上就是把堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间时，可以遍历整个链表，直到找到合适大小的块并且将它拆分；当用户释放空间时将它合并到空闲链表中。

2. 位图

**位图（Bitmap）**，其核心思想是将整个堆划分为大量的**块（block）**，每个块的大小相同。当用户请求内存的时候，总是分配整数个块的空间给用户，第一个块我们称为已分配区域的**头（Head）**，其余的称为已分配区域的**主体（Body）**。而我们可以使用一个整数数组来记录块的使用情况，由于每个块只有头/主体/空闲三种状态，因此仅仅需要两位即可表示一个块，因此成为位图。

3. 对象池

对象池的思路很简单，如果每一次分配的空间大小都一样，那么就可以按照这个每次请求分配的大小作为一个单位，把整个堆空间划分为大量的小块，每次请求的时候只需要找到一个小块就可以了。

实际上在很多现实应用中，堆的分配算法往往是采取多种算法复合而成的。比如对于 glibc 来说，它对于小于 64 字节的空间申请是采用类似于对象池的方法；而对于大于 512 字节的空间申请采用的是最佳适配算法；对于大于 64 字节而小于 512 字节的，它会根据情况采取上述方法中的最佳折中策略；对于大于 128KB 的申请，它会使用 `mmap` 机制直接向操作系统申请空间。
