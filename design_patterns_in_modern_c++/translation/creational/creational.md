# Creational Patterns

即使没有创建型模式，在C++中创建对象的行为也充满了危险。是在栈上创建还是在堆上创建？是使用原始指针、唯一指针或共享指针，还是完全使用其他指针？最后，手动创建对象是否仍然合法，或者我们是否应该将基础架构所有关键方面的创建工作推迟到专门的构造中，如工厂（稍后将详细介绍！）或反转控制容器？

无论您选择哪种方法，创建对象仍然是一件麻烦事，尤其是在创建过程比较复杂或需要遵守特殊规则的情况下。这就是创建模式的由来：它们是与创建对象相关的常用方法。

万一你对基本的C++或一般的智能指针感到生疏，下面将简要介绍在 C++ 中创建对象的方式：

- *栈分配* 创建一个将在堆栈上分配的对象。该对象将在作用域结束时自动清理（你可以用一对大括号在任何地方创建一个人工作用域）。如果将对象赋值给变量，对象将在作用域的末尾调用析构函数；如果不这样做，析构函数将立即被调用。（这可能会破坏 Memento 设计模式的某些实现，我们稍后会发现）。
- *堆分配* 使用原始指针将对象放到堆（又称空闲存储空间）上。`Foo* foo = new Foo;`创建了一个新的 Foo 实例，并留下了谁负责清理对象的问题。GSL1 的 owner`<T>` 试图引入一些关于原始指针 "所有权 "的概念，但并不涉及任何清理代码————你仍然需要自己编写。
- 唯一指针*（unique_ptr）可以使用堆分配的指针，并对其进行管理，以便在不再有引用时自动清理。唯一指针确实是唯一的：你不能复制它，也不能将它传递给另一个函数而不失去对原始指针的控制。
- 共享指针* (shared_ptr) 使用堆分配的指针并对其进行管理，但允许在代码中共享该指针。只有当没有组件继续使用指针时，才会对其进行清理。
- 弱指针*（weak_ptr）是一个智能但非所有的指针，它持有对`shared_ptr`所管理对象的弱引用。你需要将它转换为`shared_ptr`才能实际访问被引用的对象。它的用途之一是打破`shared_ptr`的循环引用。

## Returning Objects From Functions

如果要返回大于单词大小的值，有几种方法可以从函数中返回值。第一种，也是最明显的一种：

```c++
Foo make_foo(int n)
{
    return Foo{n};
}
```

在你看来，使用前一种方法可能会制作 Foo 的完整副本，从而浪费宝贵的资源。但事实并非总是如此。假设你将 Foo 定义为：

```c++
struct Foo
{
    Foo(int n) {}
    Foo(const Foo&) { cout << "COPY CONSTRUCTOR!!!\n"; }
};
```

你会发现复制构造函数可能会被调用 0 到 2 次不等：具体调用次数取决于编译器。返回值优化（RVO）是编译器的一项功能，专门用于防止额外的复制（因为它们并不会真正影响代码的运行）。不过，在复杂的情况下，确实不能依赖 RVO，但在选择是否优化返回值时，我更倾向于遵循 Knuth 的意见。

当然，另一种方法是简单地返回一个智能指针，如 unique_ptr：

```c++
unique_ptr<Foo> make_foo(int n)
{
    return make_unique<Foo>(n);
}
```

这样做非常安全，但也有主见：你为用户选择了智能指针。如果他们不喜欢智能指针呢？如果他们更喜欢`shared_ptr`呢？

第三种也是最后一种方法是使用原始指针，或许可以与 GSL 的 owner`<T>` 配合使用。这样就不会强制清理已分配的对象，但会发出一个非常明确的信息：这是调用者的责任：

```c++
owner<Foo*> make_foo(int n)
{
    return new Foo(n);
}
```

你可以把这种方法看作是给用户一个提示：我将返回一个指针，从现在起，你就可以自行处理这个指针了。当然，现在`make_foo()`的调用者需要处理这个指针：要么正确调用`delete`，要么将其封装在 `unique_ptr`或`shared_ptr`中。请记住，owner`<T>` 并不涉及复制。

所有这些方案都同样有效，很难说哪个方案更好。
