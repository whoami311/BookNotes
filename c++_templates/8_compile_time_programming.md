# 编译期编程

C++ 支持编译期编程的多个特性。

- 从 C++98 之前的版本开始，模板就提供了编译期计算的功能，包括使用循环和执行路径选择。
- 通过偏特化，可以在编译期，根据特定的限制或需求，在不同的类模板实现之间进行选择。
- 利用 SFINAE 原则，可以根据不同类型或不同限制，在不同函数模板实现之间进行选择。
- 在 C++11 和 C++14 中，`constexpr` 特性使用“直观的”执行路径选择和从 C++14 开始支持的大多数语句类型（包括 `for` 循环、`switch` 语句等），使得编译期计算得到越来越好的支持。
- C++17 引入了甚至可以在模板之外使用的“编译期 `if`”，通过它可以根据编译期的条件或限制来弃用某些语句。

## 模板元编程

模板是在编译期实例化的（与动态语言截然不同，动态语言是在运行期处理泛型的）。事实证明 C++ 模板的一些特性可以结合实例化过程，进而从 C++ 语言自身产生一种原始递归的“编程语言”。正因如此，模板可以用来“计算一个程序的结果”。

## 使用 `constexpr` 计算

C++11 引入了一个名为 `constexpr` 的新特性，极大简化了各种形式的编译期计算。当然，成功计算一个 `constexpr` 函数仍然需要所有计算步骤在编译期都是可行的和有效的：目前堆内存分配和抛出异常之类不在支持之列。

## 偏特化的执行路径选择

使用偏特化在编译期选择不同的模板实现方案。

因为函数模板不支持偏特化，所以必须使用其他机制，基于某些约束条件来改变函数实现。我们的选择包括以下选项：

- 选择带有静态函数的类；
- 使用 `std::enable_if<>`；
- 使用 SFINAE 特性；
- 使用从 C++17 开始可用的编译期 `if` 特性。

## SFINAE

当编译器看到对重载函数的调用时，它必须分别考虑每个候选函数，评估调用实参并挑出最匹配的那一个。

在调用的候选函数集包含函数模板的情况下，编译器首先必须决定应该为该候选函数模板使用哪些模板实参，其次在函数参数列表及其返回类型中替换这些实参，最后评估其匹配度（就像普通函数一样）。然而，替换过程可能会出现问题：替换产生的代码可能没有意义。语言规则不认定这种无意义的替换会导致错误，而仅仅忽略有这种替换问题的候选函数。

我们称这一原则为 SFINAE，是 “substitution failure is not an error”（替换失败并不是错误）的缩写。

注意，这里描述的替换过程不同于按需实例化过程：即使对那些有可能但不需要真正实例化的模板也会进行替换（因此，编译器可以评估是否确实不需要它们）。它只会替换直接出现在函数声明中的代码（而不是函数体）。

当替换某个候选函数的返回类型没有意义时忽略该函数，会导致编译器选择另一个参数匹配度较低的候选函数。

### SFINAE 和重载解析

随着时间的推移，SFINAE 原则在模板设计者中变得非常重要和流行，以至于这个缩写已经变成一个动词。如果我们想表达在某些约束条件下，通过 SFINAE 原则使模板代码生成无效代码，从而确保忽略这些约束条件下的函数模板，那么我们称为 “我们 SFINAE 掉了一个函数模板”。并且无论何时你在 C++ 标准中读到函数模板 “不应参与重载解析过程，除非……”，都意味着在某些情况下，使用 SFINAE 原则 “SFINAE 掉” 那个函数模板。

### 通过 `decltype` 来 SFINAE 掉表达式

对于某些限制条件，要找到并设计正确的表达式来 SFINAE 掉函数模板并不总是那么容易的。处理这种情况有一个常用模式或者说习惯用法。

- 通过尾置返回类型语法（函数名前用 `auto` 修饰，并在函数名后跟 `->`，再加末尾的返回类型）来指定返回类型。
- 使用 `decltype` 和逗号运算符来定义返回类型。
- 将所有必须成立的表达式放置于逗号运算符开头（表达式转换为 `void` 类型，以防逗号运算符重载）。
- 在逗号运算符末尾定义一个实际返回类型（类型为返回类型）的对象。

```c++
template <typename T>
auto len(T const& t) -> decltype((void)(t.size()), T::size_type()) {
    return t.size();
}
```

由于 `decltype` 构造的操作数是以逗号分隔的表达式列表，因此，最后一个表达式 `T::size_type()` 生成所需返回类型的值（`decltype` 将其转换为返回类型）。（最后一个）逗号之前的表达式是必须成立的，在本例中就是 `t.size()`。将表达式强制转换为 `void`，是为了避免由于用户自定义重载该表达式对应类型的逗号运算符而带来的问题。

`decltype` 的实参是一个未求值的操作数。这意味着可以在不调用构造函数的情况下创建 “虚对象”。

## 编译器 `if` 简介

偏特化、SFINAE 和 `std::enable_if<>` 允许我们在整体上启用或禁用模板。C++17 进一步引入编译期 `if` 语句。它允许基于编译期条件启用或禁用特定语句。通过 `if constexpr(...)` 语法，编译器使用编译期表达式来决定是使用 `then` 的部分还是 `else` 的部分（如果有的话）。

## 小结

- 模板提供了在编译期进行计算的能力（使用递归进行迭代和使用偏特化或运算符 `?:` 来做选择）。
- 通过 `constexpr` 函数，能将大多数编译期计算替换为编译器上下文中可调用的 “普通函数”。
- 通过偏特化，我们可以基于某些编译期约束条件在不同的类模板实现之间进行选择。
- 模板仅在需要时使用，对函数模板声明进行替换不会产生无效代码，这个原则称为 SFINAE（替换失败不是错误）。
- SFINAE 可以用来只为某些类型和（或）约束条件提供函数模板。
- 从 C++17 开始，编译期 `if` 允许我们根据编译期条件来使能或者丢弃语句（甚至可用于非模板中）。
