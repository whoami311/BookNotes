# 深入模板基础

## 参数化的声明

C++ 目前支持 4 种基本模板：类模板、函数模板、变量模板和命名模板。在类作用域中，它们是嵌套类模板、成员函数模板、静态数据成员模板和成员别名模板。这些模板的声明与常规类、函数、变量和类型别名（或其他的类成员）非常相似，区别在于是否通过参数化字句（parameterization clause）的形式引入：

```c++
template <parameters here>
```

在 C++17 中，变量（包括静态数据成员）和变量模板可以是“内联的”，这意味着它们的定义可以在不同编译单元之间重复。这对于变量模板来说是冗余的，变量模板总是可以在多个编译单元中定义。然而，与成员函数不同的是，在变量模板的封闭类中定义的静态数据成员不会内联：在所有情况下都必须指定关键字 `inline`。

定义在类外部的成员模板可能需要多个 `template<...>` 参数化子句：用于每个外部的类模板以及成员模板本身。子句从最外层的类模板开始列出。

### 类模板中的非模板成员

可以通过成为类模板的一部分来参数化普通类中的成员。它们偶尔（错误地）被视为成员模板。尽管可以被参数化，但这样的定义并不是第一级（first-class）的模板。它们的参数完全由所隶属的模板决定。

相关的定义仅为父类模板指定一个参数化子句，但没有为成员本身指定，因为它不是一个模板（也就是说，没有参数化子句与最后一个出现在 `::` 之后的名称相关联）。

尽管这种参数化定义的实体通常称为模板（template），但这个术语并不完全适用于它们。针对这些实体，建议使用术语 temploid。从 C++17 开始，C++ 标准定义了模板实体（template entity）的概念，其中包括模板和 temploid，以及在模板实体中递归地定义或创建任何实体的方法，比如，类模板中定义的友元函数或者模板中出现的 lambda 表达式中的闭包类型。到目前为止，无论是 temploid 还是模板实体都没有得到程序员广泛认同，但他们可能是将来精确交流 C++ 模板的不错术语。

### 虚成员函数

成员函数模板不能被声明为虚函数。施加这个约束是因为虚函数调用机制的普遍实现会使用一个固定大小的表，其中每个条目对应一个虚函数入口。然而，成员函数模板的实例个数在整个程序被编译之前是不固定的。

相反，类模板中的普通成员可以是虚函数，因为当类被实例化后，它们的个数是固定的。

### 模板的链接

每个模板都必须有一个名称，并且在其隶属的作用域下，该名称必须是唯一的，除了函数模板可以被重载之外。需要特别注意的是，类模板不能与其他类型的实体共享同一个名称，这一点与类类型是不同的。

模板通常具有外部链接。唯一的例外是带有 `static` 修饰符的命名空间作用域的函数模板、匿名命名空间（unnamed namespace）中的直接或间接成员（具有内部链接）的模板，以及匿名类（unnamed class）中的成员模板（无链接）。

目前模板不能在函数作用域或局部类作用域中声明，但是泛型 lambda 表达式具有包含成员函数模板的关联闭包类型（associated closure type），可以出现在局部类作用域中，这实际上意味着一种局部的成员函数模板。

模板实例的链接就是模板的链接。

### 主模板

模板的普通声明用于声明主模板。这类模板的声明不需要在模板名称后的角括号中添加模板实参。

非主模板在声明类或变量模板的偏特化时出现。函数模板必须始终是主模板。

## 模板参数

基本类型的模板参数有如下 3 种：

- 类型参数（目前比较常见）
- 非类型参数
- 模板的模板参数

这些基本类型的模板参数都可以作为模板参数包的基础。

模板参数是在模板声明的介绍性参数化子句中声明的。

### 类型参数

类型参数通过关键字 `typename` 或关键字 `class` 引入：两者完全等价。关键字后必须是一个简单的标识符，该标识符后的逗号（`,`）表示下一个参数声明的开始，后面闭合的角括号（`>`）表示参数化子句的结束，或使用等号（`=`）来表示一个默认模板实参的开始。

在模板声明中，类型参数的作用类似于类型别名。

### 非类型参数

非类型模板参数表示的是在编译期或链接期确定的常量值。这样的参数的类型（换句话说，这些常量值的类型）必须是下面的一种：

- 整型或枚举类型
- 指针类型
- 指涉成员的指针类型
- 左值引用类型（指涉对象和指涉函数的引用都是允许的）
- `std::nullptr_t`
- 包含 `auto` 或者 `decltype(auto)` 的类型（仅从 C++17 开始）

所有其他类型目前都被排除在外（虽然未来可能会添加浮点类型）。

函数类型和数组类型也可以指定为非类型参数，但要把它们隐式地转换为退化后所对应的指针类型。

非类型模板参数的声明与变量声明相似，但不能有 `static`、`mutable` 等非类型修饰符；可以有限定符 `const` 和 `volatile`。但如果这样的限定符出现在参数类型的最外层，则会被编译器忽略。

最后，非引用的非类型参数在表达式中使用时始终是纯右值。它们不能被取址，也不能被赋值。另外，左值引用类型的非类型参数可用于表示左值。

不允许使用右值引用。

### 模板的模板参数

模板的模板参数是类模板或别名模板的占位符。其声明很像类模板，但不能使用关键字 `struct` 和 `union`。

C++17 允许使用 `typename` 替代 `class`：这种改变是由于模板的模板参数不仅可以被类模板替代，也可以被别名模板（它实例化为任意类型）替代。

在模板的模板参数的声明范围内，使用模板的模板参数就像使用类模板或别名模板一样。
