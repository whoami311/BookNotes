# 深入模板基础

## 参数化的声明

C++ 目前支持 4 种基本模板：类模板、函数模板、变量模板和命名模板。在类作用域中，它们是嵌套类模板、成员函数模板、静态数据成员模板和成员别名模板。这些模板的声明与常规类、函数、变量和类型别名（或其他的类成员）非常相似，区别在于是否通过参数化字句（parameterization clause）的形式引入：

```c++
template <parameters here>
```

在 C++17 中，变量（包括静态数据成员）和变量模板可以是“内联的”，这意味着它们的定义可以在不同编译单元之间重复。这对于变量模板来说是冗余的，变量模板总是可以在多个编译单元中定义。然而，与成员函数不同的是，在变量模板的封闭类中定义的静态数据成员不会内联：在所有情况下都必须指定关键字 `inline`。

定义在类外部的成员模板可能需要多个 `template<...>` 参数化子句：用于每个外部的类模板以及成员模板本身。子句从最外层的类模板开始列出。

### 类模板中的非模板成员

可以通过成为类模板的一部分来参数化普通类中的成员。它们偶尔（错误地）被视为成员模板。尽管可以被参数化，但这样的定义并不是第一级（first-class）的模板。它们的参数完全由所隶属的模板决定。

相关的定义仅为父类模板指定一个参数化子句，但没有为成员本身指定，因为它不是一个模板（也就是说，没有参数化子句与最后一个出现在 `::` 之后的名称相关联）。

尽管这种参数化定义的实体通常称为模板（template），但这个术语并不完全适用于它们。针对这些实体，建议使用术语 temploid。从 C++17 开始，C++ 标准定义了模板实体（template entity）的概念，其中包括模板和 temploid，以及在模板实体中递归地定义或创建任何实体的方法，比如，类模板中定义的友元函数或者模板中出现的 lambda 表达式中的闭包类型。到目前为止，无论是 temploid 还是模板实体都没有得到程序员广泛认同，但他们可能是将来精确交流 C++ 模板的不错术语。

### 虚成员函数

成员函数模板不能被声明为虚函数。施加这个约束是因为虚函数调用机制的普遍实现会使用一个固定大小的表，其中每个条目对应一个虚函数入口。然而，成员函数模板的实例个数在整个程序被编译之前是不固定的。

相反，类模板中的普通成员可以是虚函数，因为当类被实例化后，它们的个数是固定的。

### 模板的链接

每个模板都必须有一个名称，并且在其隶属的作用域下，该名称必须是唯一的，除了函数模板可以被重载之外。需要特别注意的是，类模板不能与其他类型的实体共享同一个名称，这一点与类类型是不同的。

模板通常具有外部链接。唯一的例外是带有 `static` 修饰符的命名空间作用域的函数模板、匿名命名空间（unnamed namespace）中的直接或间接成员（具有内部链接）的模板，以及匿名类（unnamed class）中的成员模板（无链接）。

目前模板不能在函数作用域或局部类作用域中声明，但是泛型 lambda 表达式具有包含成员函数模板的关联闭包类型（associated closure type），可以出现在局部类作用域中，这实际上意味着一种局部的成员函数模板。

模板实例的链接就是模板的链接。

### 主模板

模板的普通声明用于声明主模板。这类模板的声明不需要在模板名称后的角括号中添加模板实参。

非主模板在声明类或变量模板的偏特化时出现。函数模板必须始终是主模板。

## 模板参数

基本类型的模板参数有如下 3 种：

- 类型参数（目前比较常见）
- 非类型参数
- 模板的模板参数

这些基本类型的模板参数都可以作为模板参数包的基础。

模板参数是在模板声明的介绍性参数化子句中声明的。

### 类型参数

类型参数通过关键字 `typename` 或关键字 `class` 引入：两者完全等价。关键字后必须是一个简单的标识符，该标识符后的逗号（`,`）表示下一个参数声明的开始，后面闭合的角括号（`>`）表示参数化子句的结束，或使用等号（`=`）来表示一个默认模板实参的开始。

在模板声明中，类型参数的作用类似于类型别名。

### 非类型参数

非类型模板参数表示的是在编译期或链接期确定的常量值。这样的参数的类型（换句话说，这些常量值的类型）必须是下面的一种：

- 整型或枚举类型
- 指针类型
- 指涉成员的指针类型
- 左值引用类型（指涉对象和指涉函数的引用都是允许的）
- `std::nullptr_t`
- 包含 `auto` 或者 `decltype(auto)` 的类型（仅从 C++17 开始）

所有其他类型目前都被排除在外（虽然未来可能会添加浮点类型）。

函数类型和数组类型也可以指定为非类型参数，但要把它们隐式地转换为退化后所对应的指针类型。

非类型模板参数的声明与变量声明相似，但不能有 `static`、`mutable` 等非类型修饰符；可以有限定符 `const` 和 `volatile`。但如果这样的限定符出现在参数类型的最外层，则会被编译器忽略。

最后，非引用的非类型参数在表达式中使用时始终是纯右值。它们不能被取址，也不能被赋值。另外，左值引用类型的非类型参数可用于表示左值。

不允许使用右值引用。

### 模板的模板参数

模板的模板参数是类模板或别名模板的占位符。其声明很像类模板，但不能使用关键字 `struct` 和 `union`。

C++17 允许使用 `typename` 替代 `class`：这种改变是由于模板的模板参数不仅可以被类模板替代，也可以被别名模板（它实例化为任意类型）替代。

在模板的模板参数的声明范围内，使用模板的模板参数就像使用类模板或别名模板一样。

### 模板参数包

从 C++11 开始，任何类型的模板参数都可以转换为模板参数包（template parameter pack），方法是在模板参数的名称之前引入省略号（`...`），或者如果模板参数是未命名的，则在模板参数名称出现的地方引入省略号。

模板参数包的行为类似于其基础模板参数，其中一个关键区别是：普通模板形参只能匹配一个模板参数，但模板参数包可以匹配任意数量的模板参数。

类似地，非类型模板参数包和模板的模板参数包可以分别接受任意数量的非类型模板参数或模板的模板参数。

C++17 提供了推导非类型参数的可能性，这在一定程度上可以绕过这个限制。

主类模板、变量模板和别名模板最多有一个模板参数包，而且如果存在，模板参数包必须作为最后一个模板参数。函数模板有一个较弱的限制：允许多个模板参数包。前提是模板参数包后面的每个模板参数都具有默认值或都可以被推导。

类模板和变量模板的偏特化的声明可以具有多个模板参数包，这与对应的主模板不同。这是因为偏特化是通过推导过程选择的，该推导过程与函数模板所用的推导过程几乎相同。

类型参数包不能在其参数化子句中展开。然而，嵌套模板可以实现类似的效果。

包含模板参数包的模板称为变参模板，因为其接收可变数量的模板参数。

### 默认模板实参

任何非模板参数包的模板参数都可以设置默认实参，尽管必须与相应的参数类型匹配（比如，类型参数不能有非类型的默认实参）。因为参数的名称直到默认实参之后才出现在作用域内，所以默认实参不能依赖于自身的参数。但是，默认实参可以依赖于之前声明的参数。

对于类模板、变量模板或别名模板的模板参数，只有在之后的参数也提供了默认实参时，才能具有默认模板实参。（默认函数调用参数存在类似的约束。）后面参数的默认值通常在同一个模板声明中提供，但也可以在前面的模板声明中提供。

对于函数模板的模板参数，默认模板实参不要求之后的模板参数也具有默认模板实参。

默认的模板实参不能重复声明。

许多上下文不允许使用默认模板实参。

- 偏特化
- 参数包
- 类模板成员的类外定义
- 友元类模板的声明
- 友元函数模板的声明（除非它是一个定义，并且没有在编译单元的其他地方声明）

## 模板实参

模板实参是指在实例化模板时用来替换模板形参的值。可以使用下面几种不同的机制来确定这些值。

- 显式模板实参：紧跟在模板名称后面，由角括号标识。所组成的整个实体称为模板 id。
- 注入式类名：对于具有模板参数 `P1`、`P2` 等的类模板 `X`，在其作用域内，模板的名称（即 `X`）等价于模板 id `X<P1, P2,...>`。
- 默认模板实参：如果提供默认的模板实参，则可以在模板的实例中省略显式的模板实参。然而，对于类模板或别名模板，即使所有模板参数都具有默认值，也必须提供角括号（角括号内可能为空）。
- 实参推导：对于不是显式指定的函数模板实参，可以在函数的调用语句中，根据函数调用实参的类型推导出函数模板实参。实际上，实参推导还可以在其他一些情况下出现。另外，如果可以推断出所有的模板实参，则不需要在函数模板的名称后指定角括号。C++17 引入了从变量声明的初始化程序或函数表示法类型转换来推导类模板实参的方式。

### 函数模板实参

对于函数模板实参，可以显式指定，也可以借助模板的使用方式进行推导，或者作为默认的模板实参来提供。

然而，某些模板实参永远无法被推导出来，因为对应的模板形参没有出现在函数模板形参列表中，或者出于其他原因。相应的形参通常放在函数模板形参列表的开头，以便可以显式地指定它们，同时允许推断其他实参。

因为函数模板可以被重载，所以对于函数模板而言，显示提供所有参数可能并不足以标识单个函数：在某些情况下，可以标识由许多函数组成的函数集合。

### 类型实参

模板的类型实参是用来指定模板类型参数的“值”。通常而言，任何类型（包括 `void`、函数类型、引用类型等）都可以作为模板实参，但前提是对模板参数进行替换之后必须产生有效的构造。

### 非类型模板参数

非类型模板实参是用来替换非类型参数的值。非类型模板实参必须符合以下条件之一。

- 具有一个右值类型的非类型模板实参。
- 一个编译期整数（或枚举）类型的常量值。这只有在对应参数的类型与值的类型匹配，或者值可以隐式转换为该类型而无需窄化类型转换的前提下，才可以被接受。
- 前面有一元运算符 `&`（即取地址）的外部变量或函数的名称。对于函数和数组变量，运算符 `&` 可以省略。这类模板实参可以匹配指针类型的非类型参数。C++17 放宽了这一约束，允许任何生成指针的常量表达式，生成的指针指涉函数或变量。
- 对于引用类型的非类型参数，前面没有前置运算符 `&` 的实参是可取的。同样，C++17 也放宽了约束，允许函数或变量使用任何常量表达式广义左值（const-expression glvalue）。
- 一个指涉成员的指针常量（pointer-to-member constant）。同样，在 C++17 中，实际的语法形式不再受到限制：对于匹配的指涉成员的指针常量，对其任意的常量表达式求值是允许的。
- 对于指针或指涉成员类型的指针的非类型参数，空指针常量是有效实参。

对于整数类型的非类型参数，考虑了对参数类型的隐式转换。C++11 中 `constexpr` 转换函数的引入意味着转换前的实参可以具有类类型。

在 C++17 之前，将实参与指针或引用类型的形参匹配时，不用考虑用户定义的转换（user-defined conversion，实参的构造函数和转换运算符）和从派生类到基类的转换，即使在其他情况下它们是有效的隐式转换。但使实参更 `const` 和（或）更 `volatile` 的隐式转换却是可以的。

模板实参的普遍约束是：在程序构建期，编译器或链接器必须能够确定实参的值。尽管如此，有些常量值目前仍是无效的：

- 浮点数
- 字符串字面量（string literal）

字符串字面量的问题之一是：两个相同的字面量可以存储在两个不同的地址中。一种适用（但很麻烦）的方法是在常量字符串上实例化模板时，引入一个额外的变量来保存字符串。

声明为引用或指针的非类型模板参数可以成为常量表达式（constant expression），要求是：在所有的 C++ 版本中都具有外部链接，从 C++11 开始具有内部链接或从 C++17 开始具有任意链接。

### 模板的模板实参

模板的模板实参通常必须是类模板或别名模板，其参数与所要替换的模板的参数必须精确匹配。在 C++17 之前，模板的模板实参的默认模板参数是被忽略的（但是，如果模板的模板参数具有默认参数，则在模板实例化时会将其考虑在内）。C++17 放宽了匹配规则的限制，仅要求模板的模板参数至少与相应模板的模板实参一样特化。

模板参数包只能匹配相同类型的模板参数。

在 C++17 之前，只能使用关键字 `class` 声明模板的模板参数，但这并不表示只有使用关键字 `class` 声明的类模板才可以作为替换参数。实际上，对于模板的模板参数，结构体模板、联合模板和别名模板都是有效的参数。这类似于下面的结果：任何类型都可以成为使用 `class` 关键字声明的模板类型参数的实参。

### 实参的等价性

当参数的值一对一相同时，则两组模板参数是等价的。对于类型实参，类型别名无关紧要：最终比较的是类型别名声明的原类型。对于整型的非类型模板实参，比较的是其参数的值，至于这些值是如何表达的，则无关紧要。

从函数模板生成（即模板实例化）的函数一定不会等价于普通函数，即使可能具有相同的类型和名称。针对类成员，可以引申出两点结论。

- 从成员函数模板生成的函数永远不会覆盖虚函数（进一步说明成员函数模板不能是一个虚函数）。
- 从构造函数模板生成的构造函数一定不会是拷贝构造函数或移动构造函数。类似地，从赋值运算符模板生成的赋值运算符也一定不会是拷贝赋值运算符或移动赋值运算符。

## 变参模板

变参模板是至少包含一个模板参数包的模板。当可以将模板的行为泛化成任意数量的参数时，变参模板非常有用。

当为变参模板确定模板实参时，对于变参模板中的每个模板参数包，将匹配一个由 0 个或多个模板实参组成的序列。该模板实参序列称为实参包（argument pack）。

### 包扩展

包扩展是将实参包扩展为单独的参数的构造。包扩展由列表中元素右侧的省略号（`...`）标识。

不能直接通过名称访问参数包中的各个元素，因为在可变参数模板中未定义诸如 `T1`、`T2` 等名称。如果需要这些类型，唯一能做的就是将它们（递归地）传递给另一个类或函数。

每个参数包扩展都有一个模式，这个模式是在参数包中的每个参数上重复的类型或表达式，通常位于表示扩展的省略号之前。

### 包扩展的时机

由于 C 语言在语法中提供逗号分隔列表，因此包扩展基本上可以在 C 语言的任何位置使用，具体如下：

- 在基类列表中。
- 在构造函数的基类初始化列表中。
- 在调用参数列表中（模式是参数表达式）。
- 在初始化列表中（比如，用花括号表示的初始化列表中）。
- 在类、函数或别名模板的模板参数列表中。
- 在函数可以抛出的异常列表中（在 C++11 和 C++14 中不推荐使用，在 C++17 中不允许）。
- 在属性中，如果属性本身支持包扩展（尽管 C++ 标准中没有这样的属性）。
- 当指定声明的对齐方式时。
- 当指定 lambda 表达式的捕获列表时。
- 在函数类型的参数列表中。
- 使用声明时（从 C++17 开始）。

### 函数参数包

函数参数包（function parameter pack），是匹配 0 个或多个函数调用参数的函数参数。与模板参数包一样，在函数参数名称之前（或代替参数的地方）使用省略号（`...`）来引入函数参数包，并且与模板参数包一样，必须通过包扩展方式扩展函数参数包。模板参数包和函数参数包统称为参数包（parameter pack）。

与模板参数包不同，函数参数包必须通过包扩展方式来扩展，因此，其声明的类型必须包含至少一个参数包。

函数模板的函数参数包可能依赖于在该模板中声明的模板参数包，这允许函数模板接收任意数量的调用参数而不会丢失类型信息。

### 多重和嵌套包扩展

包扩展的模式的复杂度是任意的，并且它可以包含多个不同的参数包。当实例化包含多个参数包的包扩展时，所有参数包的长度必须相同。通过将每个参数包的第 1 个参数代入模式中，然后是每个参数包的第 2 个参数，以此类推，按照元素的方式形成类型或值的结果序列。

包扩展也可以是嵌套的。在这种情况下，每次出现的参数包都会由最近的封闭包扩展（并且只能由该包扩展）。

### 零长度包扩展

包扩展的语法解释是一个有用的工具，可以帮助使用者理解变参模板的实例在不同数量的参数下的行为。但是，存在零长度参数包的情况下，语法解释会失败。

包扩展实际上是语义构造，并且任何大小的参数包的替换都不会影响包扩展（或其封装的变参模板）的解析方式。但是，当包扩展为空列表时，该程序的行为（语义上）就像该列表不存在一样。即使零长度包扩展的语法解释是定义明确（但不同）的代码，该语义规则仍然成立。

### 折叠表达式

c++17 新增了一个功能，即折叠表达式。它适用于除了 `.`、`->` 和 `[]` 以外的所有二元运算符。

给定一个未扩展的表达式模式包和一个非模式表达式的值，C++17 允许为任何这样的运算符 op 编写代码，比如：

```c++
(pack op ... op value)
```

是对于右折叠的运算符〔称为二元右折叠（binary right fold）〕，或者比如：

```c++
(value op ... op pack)
```

是对于左折叠的运算符〔称为二元左折叠（binary left fold）〕。注意，这里需要圆括号。

折叠操作适用于序列，该序列是通过扩展包，将值添加为序列的最后一个元素（对于右折叠）或作为序列的第 1 个元素（对于左折叠）而产生的。

正如期望的那样，折叠表达式就是包扩展。注意，如果包是空的，折叠表达式的类型仍可以通过非包操作数（上述形式的值）确定。

C++17 提供了另外两种形式：一元右折叠（unary right fold）

```c++
(pack op ...)
```

和一元左折叠（unary left fold）

```c++
(... op pack)
```

同样，圆括号也是必需的。显然，这给空扩展带来了问题：如何确定其类型和值？答案是，一元折叠的空扩展通常是错误的，但有以下 3 种例外情况。

- 空的 `&&` 的一元折叠的扩展会产生值 `true`。
- 空的 `||` 的一元折叠的扩展会产生值 `false`。
- 空的逗号运算符（`,`）的一元折叠的扩展会产生一个空的（`void`）表达式。

## 友元

### 类模板的友元

当类模板的实例声明为其他类或类模板的友元时，类模板必须是可见的。然而，对于普通类，则没有这样的要求。
