# 模板中的名称

## 名称的分类

| 分类 | 说明和要点 |
| - | - |
| 标识符（identifier） | 名称仅由字母、下划线（`_`）和数字不间断地组合而成。不能以数字开头，并且某些标识符是保留字，不能在程序中引入它们（另外，一条原则是，请避免使用下划线和两个连续的双下划线开头）。字母的概念具有更广泛的外延，包括特殊的通用字符名称（universal character name, UCN），UCN 采用非字符的编码格式来存储信息 |
| 运算符函数 id（operator-function-id） | 关键字 `operator` 后跟运算符的符号，比如，`operator new` 和 `operator []` |
| 转换函数 id（conversion-function-id） | 用于表示用户定义的隐式转换运算符，比如 `operator int&`，也可以被混淆为 `operator int bitand` |
| 字面量运算符 id（literal-operator-id） | 用于表示用户定义的字面量运算符，比如，运算符 `""_km`，将在编写像 `100_km` 这样的字面量时使用（在 C++11 中引入） |
| 模板 id（template-id） | 模板的名称，后紧跟由一对角括号表示的模板参数，比如，`List<T,int,0>`。模板 id 也可以是运算符函数 id 或字面量运算符 id，后面紧跟由一对角括号表示的模板参数。比如，`operator + <X<int>>` |
| 非受限 id（unqualified-id） | 广义上的标识符，可以是以上的任何一种（包括标识符、运算符函数 id、转换函数 id、字面量运算符 id 或模板 id）或析构函数的名称（比如，`~Data` 或 `~List<T,T,N>`） |
| 受限 id（qualified-id） | 使用类、枚举类型或命名空间的名称对非受限 id 进行限定，也可以只使用全局作用域解析运算符进行限定。注意，这样的名称本身也可以是多次受限的。比如，`::X`、`S::x`、`Array<T>::y` 和 `::N::A<T>::z` |
| 受限名称（qualified name） | 在标准中没有定义这个术语，但可以使用它来指涉经过受限查找的名称。具体来说，这是一个受限 id 或在前面显式使用成员访问运算符（即 `.` 或 `->`）的非受限 id。示例如下：`S::x`、`this->f` 和 `p->A::m`。然而，虽然在某些上下文中，`class_mem` 隐式等价于 `this->class_mem`，但是单独一个 `class_mem`（即前面没有 `->` 等）就不是一个受限名称，也就是说受限名称的成员访问运算符必须是显式给出的 |
| 非受限名称（unqualified name） | 除受限名称之外的非受限 id。这不是一个标准术语，而是调用非受限查找（unqualified lookup）时引用的名称 |
| 名称（name） | 受限名称或非受限名称 |
| 依赖型名称（dependent name） | 以某种方式依赖于模板参数的名称。通常，显式包含模板参数的受限名称或非受限名称都是依赖型名称。此外，对于一个用成员访问运算符（即 `.` 或 `->`）限定的受限名称，如果访问运算符左侧的表达式类型是泛型类型（type-dependent），则该受限名称也是依赖型名称。特别是，当 `this->b` 中的 `b` 出现在模板中时，它通常是一个依赖型名称。最后，依赖参数的名称查找，比如，在调用形式为 `ident(x, y)` 的函数中使用 `ident`，或在表达式 `x+y` 中使用 `+`，是依赖型名称，当且仅当任何参数表达式是泛型类型 |
| 非依赖型名称（nondependent name） | 根据上面的描述，即不属于依赖型名称的名称 |

1. 如果一个名称使用作用域运算符（即 `::`）或成员访问运算符（即 `.` 或 `->`）来表示所属的作用域，那么该名称为受限名称（qualified name）。比如，`this->count` 就是一个受限名称，但 `count` 不是（即使 `count` 实际上指涉的是一个类成员）。
2. 如果一个名称以某种方式依赖于模板参数，那么它就是依赖型名称（dependent name）。比如，如果 `T` 是一个模板参数，那么 `std::vector<T>::iterator` 通常是一个依赖型名称；但如果 `T` 是一个已知的类型别名（比如，`using T = int` 中的 `T`），那么 `std::vector<T>::iterator` 就不是一个依赖型名称。

## 名称查找

受限名称的名称查找是在受限作用域内部进行的，该受限作用域由限定的构造决定。如果该作用域是一个类，那么查找范围可以包括其基类，而不用考虑它实际的封闭作用域。

非受限名称的名称查找则与此相反，通常在连续封闭作用域中查找（但在某个类内部的成员函数定义中，会先查找类及其基类的作用域，然后才查找其他封闭作用域），而这种查找方式也称为普通查找（ordinary lookup）。

对于非受限名称的查找，新增了一种查找机制——除了普通查找之外——就是说非受限名称有时还可能需要依赖于参数的查找（argument-dependent lookup，ADL）。

### 依赖于参数的查找

ADL 主要应用于非受限名称。在函数调用或运算符调用中，这些名称看起来就像是非成员函数。如果普通查找发现下面的名称，则不会使用 ADL：

- 成员函数的名称
- 变量的名称
- 类型的名称
- 块作用域中声明的函数名称

如果名称后面是用圆括号标识的实参表达式列表，那么 ADL 将继续在与调用实参类型“关联”的命名空间和类中查找这个名称。

对于给定类型，由关联命名空间和关联类所组成的集合的精确定义可以通过以下规则确定。

- 对于内置（基本）类型，该集合是空集。
- 对于指针和数组类型，该集合是所引用类型的关联命名空间和关联类。
- 对于枚举类型，关联命名空间是指枚举声明所在的命名空间。
- 对于类成员，外部类是关联类。
- 对于类类型（包括联合类型），关联类的集合包括该类型本身、封闭（外部）类、任何直接和间接基类等。关联命名空间的集合是关联类声明所在的命名空间。如果这个类是一个类模板的实例，那么集合包括模板类型实参的类型、声明模板的模板参数所在的类和命名空间等。
- 对于函数类型，该集合包括所有参数的类型以及返回类型的关联命名空间和关联类。
- 对于类 X 的成员指针类型，除了成员相关的关联命名空间和关联类之外，该集合还包括与 X 相关的关联命名空间和关联类。（如果是指涉成员函数的类型，则参数和返回类型也可以包括在该集合之内）

ADL 会在所有关联命名空间中查找该名称，就好像依次地直接使用这些命名空间进行限定一样。唯一的例外情况是 `using` 指令将会被忽略。

### 依赖于参数的友元声明的查找

类中的友元函数声明可以是该友元函数的首次声明。这种情况下，对于包含这个友元函数的类，假设这个友元函数是在该类所属的最近命名空间作用域（可能是全局作用域）中声明的。但是，这样的友元声明在该作用域是不直接可见的。

依赖于参数的查找来查找友元声明和定义的功能有时被称为友元名称注入（friend name injection）。然而，这个术语有些误导性，因为它实际上是准标准 C++ 特性的名称，该特性确实将友元声明的名称注入封闭的作用域中，使它们对普通的名称查找可见。

### 注入的类名称

如果在类本身的作用域中注入该类的名称，则可以将该名称称为注入的类名称。它可以作为该类作用域中的一个非受限名称被访问。（但是，不能将其作为受限名称进行访问，因为在这里并没有使用该名称来表示构造函数。）

类模板也可以具有注入的类名称。然而，它们和普通的注入的类名称相比有些区别：它们的后面可以紧跟着模板实参（在这种情况下，它们也被称为注入的类模板名称），但是，如果它们后面没有跟着模板实参，则表示类，如果上下文需要类型，那么它们代表的就是用参数来代表类的实参（或者，对于偏特化，还可以用特化实参代表对应的模板实参）；或者上下文需要模板，则为模板。

注意，使用非受限名称来引用注入的类名称时，如果这些非受限名称的后面没有紧跟模板实参列表，那么是不会被作为模板名称的。为了解决这个问题，可以在查找的模板名称前加上作用域限定符 `::`，使得模板名称被强制找到。

变参模板的注入的类名称有一个额外的缺点：对于被注入的类名称，如果该名称是通过将变参模板的模板参数作为模板实参直接形成的，那么被注入的类名称将包含未扩展的模板参数包。因此，当为变参模板创建注入的类名称时，与模板参数包相对应的模板实参是一个包扩展，其模式是模板参数包。

### 当前的实例化

类或类模板的注入的类名称实际上是所定义类型的别名。对于非模板类，这个特性是显而易见的，因为类本身是在作用域内具有该名称的唯一类型。但是，在类模板或类模板的嵌套类中，每个模板的实例化都会产生不同的类型。这意味着注入的类名称引用了类模板的相同实例化，而不是该类模板的其他特化（对于类模板的嵌套类也是如此）。

在类模板中，注入的类名称或与任何封闭类或类模板注入的类名称（包括通过类型别名的声明进行查找）等价的任何类型都被称为指涉当前的实例化（current instantiation）。依赖于模板参数的类型，即依赖类型（dependent type），但不指涉当前的实例化的类型称为指涉未知的特化（unknown specialization），该特化可以从相同的类模板或一些完全不同的类模板中实例化。

## 解析模板

### 依赖类型的名称

通常，依赖的受限名称不代表一个类型，除非该名称紧跟在 `typename` 关键字后面。对于类型名称，如果在替换模板参数后，发现名称不是类型的名称，那么程序是无效的，C++ 编译器会在实例化过程中报错。注意，`typename` 的这种用法不同于表示模板的类型参数。与类型参数不同，不能将 `typename` 等价地替换为 `class`。

当名称满足以下所有条件时，就需要在该名称前添加 `typename` 前缀。

- 名称是受限的，而不是跟在 `::` 后面形成一个更加受限的名称。
- 名称不是详细类型说明符（elaborated-type-specifier）的一部分（比如，以关键字 `class`、`struct`、`union`、`enum` 等开头的类型名称）。
- 名称不在用于指定基类继承的列表中，也不在引入构造函数的成员初始化列表中。
- 名称依赖于模板参数。
- 名称是未知的特化的成员（member of an unknown specialization），这意味着由受限符命名的类型指涉一个未知的特化。

此外，除非至少前 2 个条件成立，否则不允许使用 `typename` 前缀。

### 依赖模板的名称

如果限定符前面的名称（或者表达式）的类型要依赖于某个模板参数，并且紧接在限定符后面的是一个模板 id（即一个后面带有由角括号标识的参数列表的模板名称），就应该使用关键字 `template`。

### `using` 声明中的依赖型名称

`using` 声明可以从两个位置（即命名空间和类）引入名称。如果引入位置是命名空间，将不会涉及上下文中相关的问题。实际上，从类中引入名称的 `using` 声明的功能有限，只能将名称从基类引入派生类。这种 `using` 声明的行为类似于从派生类访问基类的符号链接或快捷方式。因此，可以让派生类的成员访问 `using` 声明的名称，就像它是派生类中声明的成员一样。

同样，如果希望使用 `using` 声明引入的依赖型名称是一个类型，则必须通过插入 `typename` 关键字来显式地说明。

### 依赖型表达式

和名称一样，表达式本身也可以依赖于模板参数。依赖于模板参数的表达式，在不同的实例化之间表现不同（比如，选择不同的重载函数，或产生不同的类型或常数值）。相反，不依赖于模板参数的表达式，在所有实例化中都将提供相同的行为。

表达式可以有几种不同的方式依赖于模板参数。依赖型表达式中最常见的是类型依赖的表达式（type-dependent expression），其中表达式本身的类型可以从一个实例化到下一个实例化（比如，一个指涉函数参数的表达式，其类型是模板参数的类型）。

对于具有类型依赖的子表达式，其表达式本身通常也是类型依赖的。

并非所有涉及模板参数的表达式都是类型依赖的。比如，涉及模板参数的表达式，可以在从一个实例化到下一个实例化时产生不同的常量值。这样的表达式称为值依赖的表达式（value-dependent expression），其中最简单的是那些引用非依赖类型的非类型模板参数。

与类型依赖的表达式一样，如果一个表达式由其他值依赖的表达式组成，那么它通常也是值依赖的。

任何涉及模板参数的表达式都是实例化依赖的表达式（instantiation-dependent expression），即使它的类型和常量值在有效的实例化中都是不变的。但是，实例化依赖的表达式可能会在实例化时无效。

类型依赖、值依赖和实例化依赖可以被看作一系列越来越具有包容性的表达式分类。任何类型依赖的表达式也被认为是值依赖的，因为如果表达式的类型随着实例化的不同而不同，那么它的常量值自然会随着实例化的不同而不同。类似地，对于类型或值因实例化的不同而不同的表达式，它以某种方式依赖于模板参数，因此，类型依赖的表达式和值依赖的表达式都是实例化依赖的。

### 编译器错误

在模板的所有实例化都产生错误时，C++ 编译器允许（但不是必需的）在解析模板时诊断错误。

## 继承和类模板

### 非依赖型类模板

在一个类模板中，非依赖型基类是具有完整类型的类，并且不需要知道模板的参数就可以完全确定类型。也就是说，这个基类的名称是用非依赖型名称来表示的。

模板中的非依赖型基类的行为与普通非模板类中的基类的行为非常相似，但有一个稍微令人感到遗憾的意外：当在模板的派生类中查找非受限名称时，会先查找非依赖型基类，再查找模板参数列表。这是违反直觉的查找，并且要求派生模板的作者知道它所派生的非依赖型基类中的这些名称（即使这种派生是间接的，或者这些名称是私有的）。最好将模板的参数放置在它们“模板化”的实体的作用域中。

### 依赖型基类

C++ 标准规定：一旦遇到出现在模板中的非依赖型名称，就立即查找它。

C++ 标准规定：非依赖型名称不会在依赖型基类中进行查找（但一旦遇到它们，仍然会马上进行查找）。

在当前实例化中搜索受限名称时，C++ 标准指定查找时：首先在当前实例化和所有非依赖型基类中进行搜索，类似于对该名称执行非受限查找的方式。如果可以找到任何名称，那么受限名称将指涉当前实例化的成员，而不是依赖型名称；如果没有找到这样的名称，并且类具有任何依赖型基类，那么受限名称将指涉未知特化的成员。
