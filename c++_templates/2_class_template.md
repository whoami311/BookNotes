# 类模板

## 类模板 Stack 的实现

如果在类模板内使用不跟模板实参的类名，则表示该类以其模板参数类型作为其实参类型。

不同于非模板类，不能在函数或者块作用域内声明或定义类模板。通常模板只能在全局 / 命名空间作用域或者类声明中定义。

## 类模板 Stack 的使用

只有被调用的模板（成员）函数才会实例化代码。对于类模板，成员函数只有在使用时才实例化。这当然节省了时间和空间，并且允许只部分使用类模板。

如果一个类模板含有静态成员，对于该类模板用到的每种类型，这些静态成员只实例化一次。

可以像使用任何其他类型一样使用实例化后的类模板类型，可以用 `const` 或 `volatile` 限定符修饰它，或者基于它生成数组和引用类型，也可以将其用作 `typedef` 或 `using` 类型定义的一部分，或在构建其他模板类型时将其用作类型参数。

## 部分使用类模板

类模板通常会对其用来实例化的模板实参应用多种操作（包含构造和析构）。这可能会给我们留下这样的印象：这些模板实参必须为类模板的所有成员函数提供一切必要操作。但事实并非如此：模板实参只须提供那些必要操作（而不是可能需要用到的操作）。

从 C++11 开始，至少可以通过使用关键字 `static_assert` 和一些预定义的类型特征来检查基本约束。

## 类模板的特化

可以用某些模板实参来特化类模板。类似函数模板重载，通过特化类模板，可以优化基于某些特定类型的实现，或者修复类模板实例化过程中某些特定类型所出现的行为缺陷。不过，如果特化类模板，还必须特化其所有成员函数。尽管可以特化类模板的单个成员函数，但一旦这么做了，就再也不能特化该成员函数所属的整个类模板实例了。

## 类型别名

### 别名模板

与 `typedef` 不同，别名声明可以模板化，以便为一系列类型提供名字。这一称为别名模板的特性也是从 C++11 开始生效的。

### 类型特征后缀 `_t`

从 C++14 开始，标准库就使用这种技巧来为标准库中萃取所得类型的全部类型特征定义快捷方式。

## 类模板实参推导

在 C++17 出现之前，始终必须传递所有模板参数类型给类模板（除非它们有默认值）。从 C++17 开始，放宽了总是需要显式指定模板实参的限制。如果构造函数能够推导出所有模板参数（没有默认值），则可以忽略该限制。

### 推导指引

可以通过定义特定的推导指引，来提供附加的或者修正已有的类模板实参推导规则。

## 模板化聚合体

聚合类（是这样的类或结构体：非用户提供、显式定义或者继承的构造函数，没有 `private` 或者 `protected` 的非静态数据成员，没有虚函数，没有 `virtual`、`private` 或者 `protected` 的基类）也可以是模板。

## 小结

- 类模板是使用一个或多个类型未定的参数来实现的类。
- 要使用类模板，可以将未定类型作为模板实参传递，然后用这些类型实例化（并编译）类模板。
- 对于类模板，只实例化那些会调用到的成员函数。
- 可以用某种特定类型来特化类模板。
- 可以用某种特定类型来偏特化类模板。
- 从 C++17 开始，可以从构造函数中自动推导出类模板实参。
- 可以定义聚合类的类模板。
- 如果声明为传值调用，则调用的模板参数类型会退化。
- 只能在全局 / 命名空间作用域内或者类声明中声明和定义模板。
