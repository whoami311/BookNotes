# 函数模板

## 1.1 函数模板初探

### `max()` 函数模板

`max()` 模板根据 [StepanovNotes] 有意返回 `b < a ? a : b` 而不是 `a < b ? b : a`，以确保即使两个不同对象的值相等但不相同，函数也能正确执行。

```c++
template <typename T>
T max(T a, T b) {
    return b < a ? a : b;
}
```

### `void` 是有效的模板实参

如果生成的代码有效，`void` 就是有效的模板实参。

```c++
template <typename T>
T foo(T*) {}

void* vp = nullptr;
foo(vp);            // 正确，推导为 void foo(void*)
```

### 两阶段编译

模板分两个阶段“编译”。
1. 定义期间不会实例化，可以忽略模板参数，只检查模板代码自身的正确性。这包含以下几个方面。
    - 发现语法错误，比如少了分号。
    - 发现使用独立于模板参数的未知名称（类型名、函数名等）。
    - 检查独立于模板参数的静态断言。
2. 实例化期间会再次检查模板代码以确保所有代码的有效性。也就是说在当前阶段会复查所有依赖于模板参数的部分。

## 1.2 模板实参推导简介

1. 类型推导中的类型转换
    在类型推导过程中的自动类型转换是受限的。
    - 当声明调用参数是按引用传递时，即使再细微的转换也不适用于类型推导，使用相同模板参数 `T` 声明的两个实参必须完全匹配。
    - 当声明调用参数是按值传递时，仅支持退化的简单转换：忽略 `const` 和 `volatile` 限定符，引用转换为引用类型，原始数组或函数转换为相应的指针类型。对于使用相同模板参数 `T` 声明的两个实参，退化后的类型必须匹配。
2. 默认实参的类型推导
    类型推导对默认调用实参不起作用。为了应对这种情况，还必须为模板参数声明一个默认实参。

## 1.3 多模板参数

从 C++11 开始，C++ 标准库提供了一种指定选择“更一般类型”的方法。`std::common_type<>::type` 萃取作为模板实参传递的两个（或更多）不同类型的“公共类型”。

从 C++14 开始，你可以通过在特征名称后附加 `_t` 并省略 `typename` 和 `::type` 来简化特征的用法。

在内部，它根据运算符 `?:` 的语言规则或具体类型的特化来选择结果类型。`std::common_type<>::type` 也是会退化的。

## 1.4 默认模板实参简介

原则上，可以为前导函数模板参数设置默认实参，即使后面那些参数都没有设置。

## 1.5 重载函数模板简介

一个非模板函数可以和一个与其同名且可以用相同类型实例化的函数模板共存。在所有其他因素都相同的情况下，重载解析过程优先选择非模板函数而不是从模板实例化出的函数。不过，如果模板可以生成匹配度更高的函数，就会选择这个模板。

也可以显式指定一个空模板实参列表，此语法表明只有模板可以解析此次调用，但所有模板参数都应该从调用实参中推导出来。

确保在调用函数之前，函数的所有重载版本已声明。

## 1.6 难道，我们不应该......

### 传值还是传引用

一般来说，传值通常更好。

- 语法简单。
- 编译器优化更好。
- 移动语义拷贝成本低。
- 有时完全没有拷贝或移动。

此外，传值对模板的特定影响如下。

- 模板既可以用于简单类型，也可以用于复杂类型。但是选择适用于复杂类型的方式，可能会对简单类型不利。
- 作为调用者，通常仍然可以决定使用 `std::ref()` 和 `std::cref()` 来按引用传递实参。
- 尽管按值传递字符串字面量和原始数组总会成为问题，但按引用传递它们常常被认为是更大的问题。

### 为什么不使用 `inline`

通常，函数模板不必用 `inline` 来声明。与普通的非内联函数不同，我们可以在头文件中定义非内联函数模板。并在多个编译单元里包含这个头文件。

此规则的唯一例外是针对特定类型的模板全局特化，于是生成的代码不再是泛型的（定义了所有模板参数）。

## 1.7 小结

- 函数模板为不同模板实参定义了一系列参数。
- 当根据模板参数将实参传递给函数参数时，函数模板会为相应的参数类型推导要实例化的模板参数。
- 可以显式限定前导模板参数的类型。
- 可以定义模板参数的默认实参。这些默认实参可引用在其之前声明的模板参数，后面跟着没有默认实参的模板参数。
- 可以重载函数模板。
- 当与其他函数模板一起重载函数模板时，应确保任何函数调用都只有其中一个模板与之匹配。
- 当重载函数模板时，更改要限制在只改变模板参数的数量或者显式指定模板参数。
- 在调用函数模板之前，确保编译器可以看到函数模板的所有重载版本。
