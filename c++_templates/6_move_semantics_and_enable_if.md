# 移动语义和 `enable_if<>`

移动语义可以用来优化拷贝和赋值操作，可以将内部资源从原对象移动（“窃取”）到目标对象，而不是复制这些内容。可以这么做的前提条件是源对象不再需要其内部值或状态（因为它们将被丢弃）。

移动语义对模板设计有重要影响，在泛型代码中引入了特殊规则来支持移动语义。

## 完美转发简介

C++11 引入了完美转发参数的特殊规则。实现这一目标的惯用代码如下：

```c++
template <typename T>
void f(T&& val) {
    g(std::forward<T>(val));    // 完美转发 val 给 g()
}
```

- 具体类型 `X` 的 `X&&` 声明了一个右值引用参数。它只能绑定到一个可移动对象（一个纯右值 prvalue，比如临时对象，或一个将亡值 xvalue，比如用 `std::move()` 传递的对象）上。它总是可变的，而且总是可以“窃取”对象的值。
- 模板参数 `T` 的 `T&&` 声明了一个转发引用（亦称万能引用）。它可以绑定到可变的、不可变的（即 `const`）或可移动的对象上。在函数定义中，参数是可变的、不可变的或者可以从中“窃取”内部资源的值的引用。

`T` 必须确实是模板参数的名字，而仅仅依靠模板参数是不够的。对于模板参数 `T`，比如 `typename T::iterator&&` 只声明一个右值引用，而不是一个转发引用。

## 通过 `std::enable_if<>` 禁用模板

从 C++11 开始，C++ 标准库提供了一个辅助模板 `std::enable_if<>`，用以在某些编译期条件下忽略函数模板。

`std::enable_if<>` 是一种类型特征，会对作为其（第 1 个）模板实参传入的、给定的编译期表达式求值，其行为如下。

- 如果表达式的结果为 `true`，则其类型成员 `type` 返回一个类型：如果没有传递第 2 个模板实参，则类型为 `void`，否则，该类型是第 2 个模板实参的类型。
- 如果表达式的结果为 `false`，则其成员类型是未定义的。由于名为 SFINAE（替换失败不是错误）的模板特性，其具有忽略带有 `std::enable_if<>` 表达式的函数模板的效果。

因为自 C++14 以来，所有类型特征的萃取所得都是类型，所以有相应的别名模板 `std::enable_if_t<>`，其允许略过 `typename` 和 `::type`。

在声明中使用 `enable_if<>` 表达式的做法相当拙劣。为此，使用 `std::enable_if<>` 的常用方法是使用带有默认值的附加函数模板实参。

## 使用 `enable_if<>`

一般来说我们不能使用 `enable_if<>` 来禁用预定义的拷贝 / 移动构造函数和（或）赋值运算符。原因是成员函数模板从不算作特殊成员函数，于是某些情况下会被忽略。

## 小结

- 在模板中，可以通过将参数声明为转发引用（万能引用，使用由模板参数名称后跟 `&&` 构成的类型进行声明），并在转发调用中使用 `std::forward<>()`，来“完美”地转发它们。
- 当将完美转发用于成员函数模板时，对于拷贝和移动对象来说，它们可能比预定义的特殊成员函数更匹配。
- 通过使用 `std::enable_if<>`，可以在编译条件为 `false` 时禁用函数模板（一旦该条件成立，就会忽略这个模板）。
- 通过使用 `std::enable_if<>`，能够避免当可为单一实参调用的构造函数模板或赋值构造函数模板比隐式生成的特殊成员函数更加匹配时所出现的问题。
- 可以通过删除 `const volatile` 类型参数的预定义特殊成员函数（并结合应用 `enable_if<>`），来将特殊成员函数模板化。
- 概念将允许我们使用更直观的语法来指定对函数模板的需求（或约束）。
