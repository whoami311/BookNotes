# 模板的多态

多态（polymorphism）是一种可以将不同的特定行为与单个泛型符号相关联的能力。多态也是面向对象编程范例的一块基石，C++ 主要通过类继承和虚函数来支持多态。因为这两个机制（至少一部分）是在运行期处理的，所以我们讨论动多态（dynamic polymorphism）。平时讨论的多态指的就是动多态。然而，模板也可以将不同的特定行为与单个泛型符号相关联，但是这种关联通常在编译期处理，我们称之为静多态（static polymorphism）。

## 动多态

在 C++ 历史上，开始人们只是通过使用继承和虚函数来支持多态。在这种情况下，多态设计的思想在于：识别相关对象类型中的一组公共功能，并将它们声明为公共基类中的虚函数接口。

动多态最引人瞩目的特性可能是处理异类对象集合的能力。简单表达式会根据迭代的元素的动态类型，而调用不同的成员函数。

## 静多态

模板也可以用来实现多态。但是，它们不依赖于基类中包含公共行为的因素。具体类别是相互独立定义的。当模板被具体类实例化时，多态的能力就可以得到体现。

但是，异类集合不能再被透明地处理。这就是静多态的静态特性所施加的约束：所有的类型都必须在编译期确定。我们不再要求集合仅限于指针，从而能够在性能和类型安全方面有一些显著的优势。

## 动多态与静多态

1. 术语

    - 通过继承实现的多态是绑定的和动态的。
      - 绑定：意味着参与多态行为的类型的接口是由公共基类的设计预先确定的（这个概念的其他术语是侵入的和插入的）。
      - 动态：意味着接口的绑定是在运行期（动态地）完成的。
    - 通过模板实现的多态是非绑定的和静态的。
      - 非绑定：意味着参与多态行为的类型的接口不是预先确定的（这个概念的其他术语是非侵入的和非插入的）。
      - 静态：意味着接口的绑定是在编译期（静态地）完成的。

    因此，严格地说，在 C++ 标准中，动多态和静多态分别是绑定动多态和非绑定静多态的简称。

2. 优点和缺点

    C++ 中的动多态表现出以下优点。

    - 优雅地处理异类集合。
    - 可执行代码的大小可能更小（因为只需要一个多态函数，而静多态必须生成不同的模板实例来处理不同的类型）。
    - 代码可以完全编译，因此，不必发布任何实现源代码（分发模板库通常需要分发模板实现的源代码）。

    C++ 中的静多态具有下列优点。

    - 内置类型的集合很容易实现。更一般地说，接口公共性不需要通过公共基类来实现。
    - 生成的代码效率更高（因为事先不需要通过指针进行间接调用，而且可以更频繁地内联非虚函数）。
    - 如果应用程序只执行了部分接口，那么仍然可以使用只提供部分接口的具体类型。

    静多态通常被认为比动多态更安全，因为所有绑定都是在编译期检查的。

    在实践中，当不同的语义隐藏在看起来相同的接口后面时，模板实例化也会引起一些问题。

3. 结合这两种多态

    当然，我们可以把这两种多态结合起来。

## 使用概念

反对模板静多态的一个理由是，接口的绑定是通过实例化相应的模板来完成的。这意味着没有公共接口（类）可供程序设计。只要所有实例化的代码都有效，模板的任何用法都可以实现。否则，可能会产生让人难以理解的错误消息，甚至出现有效但非预期的行为。

为此，C++ 语言设计者一直致力于为模板参数显式提供检查接口的功能。这样的接口通常被称为 C++ 中的概念（concept）。它表示一组约束，模板实参必须满足这些约束才可以成功实例化模板。

## 新形式的设计模式

C++ 中的静多态为实现经典设计模式提供了新的方法。以桥接模式（bridge pattern）为例，它在许多 C++ 程序设计中起着重要作用。使用桥接模式的一个目标是在同一接口的不同实现之间切换。

根据 [DesignPatternGoF]，这通常是通过使用接口类来完成的，该接口类嵌入一个指针来提供实际的实现，并通过该指针对所有调用进行授权。

然而，如果实现的类型在编译期是已知的，那么我们将利用模板的强大功能，这将带来更高的类型安全性（部分原因是可以避免使用指针转换）和更好的性能。

## 泛型程序设计

静多态引出了泛型程序设计的概念。然而，泛型程序设计并没有统一的定义（正如面向对象编程也没有统一的定义）。[CzarneckiEiseneckerGenProg] 将泛型程序设计定义为从使用泛型参数程序设计到寻找高效算法的最抽象表示。该书总结如下：泛型程序设计是计算机科学的一个分支学科，它研究如何找到高效算法、数据结构和其他软件概念的抽象表示，以及它们的系统化组织方式……泛型程序设计侧重于表示一组相关的领域概念。

在 C++ 的上下文中，泛型程序设计有时被定义为运用模板的程序设计（而面向对象的程序设计被认为是运用虚函数的程序设计）。在这个意义上，C++ 模板的使用都可以被看做泛型程序设计的一个实例。然而，开发人员通常认为泛型程序设计有一个额外的基本要素：在一个框架中，模板的设计是为了获得多种有用的组合。

到目前为止，对这一领域最重要的贡献是标准模板库（STL），该库后来被采纳并引入 C++ 标准库中。

泛型程序设计之所以实用，是因为它依赖于在编译期解析接口的静多态。

## 后记

即使在今天相对成熟的 “模板时代”，许多项目仍然会在处理多态性的方法上做出次优化的选择。显然，在许多情况下，动多态是正确的选择，异类迭代就是一个例子。然而，同样地，许多程序任务都是使用模板自然而高效地完成的，同类容器就是一个例子。

静多态很适用于编写基本的计算结构。而动多态需要选择公共基类，意味着动多态通常必须做出特定于某一领域的选择。因此，C++ 标准库的 STL 部分从不包含多态容器，这是不足为奇的，但是它包含一组使用静多态的容器和迭代器。
