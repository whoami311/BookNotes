# 元编程

元编程的内涵包括“对一个程序进行编程”。换句话说，编程系统将会执行我们所涉及的代码，以生成新的代码，而这些新代码将实现我们真正想要的功能。通常，元编程这个术语意味着一个反身的属性。元编程组件既是程序的一部分，又为其所在的程序生成了一部分代码或程序。

为什么要进行元编程？正如大多其他的编程技巧，进行元编程的目标是实现事半功倍，结果可以用代码大小、维护成本等来衡量。元编程的特色是某些用户定义的计算在翻译期发生。进行元编程的深层次的动机经常是提高性能（翻译期计算的东西往往可以优化掉）或者简化接口（元编程通常比它扩展的程序更加短小），或兼顾两者。

## 现代 C++ 元编程的状况

### 值元编程

### 类型元编程

```c++
// 基本模板：一般产生的是给定的类型
template <typename T>
struct RemoveAllExtentsT {
  using Type = T;
};

// 为（有界或无界的）数组类型偏特化
template <typename T, std::size_t SZ>
struct RemoveAllExtentsT<T[SZ]> {
  using Type = typename RemoveAllExtentsT<T>::Type;
};

template <typename T>
struct RemoveAllExtentsT<T[]> {
  using Type = typename RemoveAllExtentsT<T>::Type;
};

template <typename T>
using RemoveAllExtents = typename RemoveAllExtentsT<T>::Type;
```

这里，`RemoveAllExtents` 是一个类型元函数（即一种生产类型的计算工具），它将从一个类型中移除任意数量的顶层“数组层”。

元函数通过让与顶层数组相匹配的偏特化递归地“调用”元函数本身来执行其任务。

假如我们所能用的都只是标量值，那么用值进行计算就是非常受限的。幸运的是，几乎任何编程语言都至少有一个值容器构造，它极大地扩展了该语言的功能（大多数语言都有各种容器类型，如数组 / `vector`、哈希表等）。类型元编程的情况也是如此：增加一个“类型的容器”构造会扩大该技术的适用范围。幸运的是，现代 C++ 包含能够开发这样一个容器的机制。

### 混合元编程

通过值元编程和类型元编程，我们可以在编译时计算值和类型。然而最终，我们对运行期的效果感兴趣，所以我们在运行期的代码中，在预期有类型和常量的地方使用元编程。不过，元编程能做的还不止这些。我们可以在编译期以编程方式组装具有运行期效果的代码片段。我们称之为混合元编程。

我们在前面提到，如果有一个“类型的容器”，类型元编程的能力就会得到极大的增强。我们已经看到，在混合元编程中，一个固定长度的数组类型可能是有用的。尽管如此，混合元编程中真正的“英雄容器”是元组。元组是一个值的序列，每个值都有一个可选择的类型。C++ 标准库包含一个支持这种观念的 `std::tuple` 类模板。比如，

```c++
std::tuple<int, std::string, bool> tVal{ 42, "Answer", true};
```

上述的 `tVal` 的类型与一个简单的 `struct` 类型非常相似，如：

```c++
struct MyTriple {
  int vl;
  std::string v2;
  bool v3;
};
```

既然对于数组类型和（简单的）`struct` 类型，我们已经有了灵活的 `std::array` 和 `std::tuple` 分别与之对应，自然会想到，对于简单的 `union` 类型，它的模板对应物对混合计算是否同样有用。答案是“是的”。C++ 标准库在 C++17 中为此目的引入了 `std::variant` 模板。

因为 `std::tuple` 和 `std::variant` 同 `struct` 类型一样，都是异质类型，使用这种类型的混合元编程有时被称为异质元编程。

### 单位类型的混合元编程

另一个展示混合计算能力的例子是能够计算不同单位类型的值的计算结果的库。值的计算在运行期进行，但结果单位的计算在编译期就确定了。

让我们用一个高度简化的例子来说明这一点。我们将以它们对于主要单位的比值（分数）来记录单位。例如，如果时间的主要单位是秒（s），那么 1ms 就用比值 1/1000 表示，1min 用比值 60/1 表示。所以，关键是要定义一个比值类型，其中每个值都有自己的类型：

```c++
template <unsigned N, unsigned D = 1>
struct Ratio {
  static constexpr unsigned num = N;    // 分子
  static constexpr unsigned den = D;    // 分母
  using Type = Ratio<num, den>;
};
```

现在我们可以进行编译期的计算，如两个比值相加：

```c++
// 两个比值相加的实现
template <typename R1, typename R2>
struct RatioAddImpl {
  private:
    static constexpr unsigned den = R1::den * R2::den;
    static constexpr unsigned num = R1::num * R2::den + R2::num * R1::den;
  public:
    typedef Ratio<num, den> Type;
};

// using 声明以方便使用
template <typename R1, typename R2>
using RatioAdd = typename RatioAddImpl<R1, R2>::Type;
```

这使我们能够在编译期计算出两个比值的和。

我们现在可以为持续时间定义一个类模板，以一个任意的值类型和一个 `Ratio<>` 实例化后的单位类型作为它的参数。

```c++
template <typename T, typename U = Ratio<1>>
class Duration {
  public:
    using ValueType = T;
    using UnitType = typename U::Type;
  private:
    ValueType val;
  public:
    constexpr Duration(ValueType v = 0) : val(v) {}

    constexpr ValueType value() const {
        return val;
    }
};
```

值得注意的是 `operator+` 的定义。将两个持续时间相加：

```c++
// 将两个单位类型可能不同的持续时间相加
template <typename T1, typename U1, typename T2, typename U2>
auto constexpr operator+(Duration<T1, U1> const& lhs, Duration<T2, U2> const& rhs) {
  // 结果类型是一个单位，其分子是 1，分母是将两个单位的比值相加后所得分数的分母
  using VT = Ratio<1, RatioAdd<U1, U2>::den>;
  // 结果的值是转换到结果单位类型的两个值的和
  auto val = lhs.value() * VT::den / U1::den * U1::num +
             rhs.value() * VT::den / U2::den * U2::num;
  return Duration<decltype(val), VT>(val);
}
```

参数可以有不同的单位类型：`U1` 和 `U2`。使用这些单位类型计算出持续时间，使其具有相应的单位类型，即相应的单位分数（分子为 `1` 的分数）。

关键的“混合”效果是，编译器在编译期确定结果的单位类型，并在运行期计算结果的值所需要的代码，而值会根据结果的单位类型进行调整。

由于值类型是一个模板参数，我们可以使用的值类型不限于 `int` 的 `Duration` 类，甚至可以使用异质的值类型（只要类型的值的加法运算是定义好的）。

此外，如果值在编译期已知，编译器甚至可以在编译期计算出值，因为持续时间的 `operator+` 是 `constexpr`。

C++ 标准库的类模板 `std::chrono` 使用了这种方法，并做了一些改进，例如使用预定义的单位（如 `std::chrono::milliseconds`）支持持续时间字面量（例如 `10ms`），以及处理溢出。

## 反射元编程的维度

之前，我们描述了基于 `constexpr` 求值的值元编程和基于递归模板实例化的类型元编程。这两种元编程，在现在 C++ 中都是可用的，它们显然涉及驱动计算的不同方法。事实证明，值元编程也可以以递归模板实例化的方式来驱动，而且，在 C++11 中引入 `constexpr` 函数之前，这正是其实现机制。

无论如何，可以看到，元编程的计算引擎有可能有许多潜在选项。然而，计算引擎并不是考虑这些选项的唯一维度。进一步说，一个全面的 C++ 元编程解决方法必须以 3 个维度做出选择：

- 计算
- 反射
- 生成
 
反射是指以编程方式检查程序的特性的能力。生成是指为程序生成额外代码的能力。

我们已经看到了计算的两种选择：递归实例化和 `constexpr` 求值。对于反射，我们已经在类型特征中找到了部分解决方案。尽管可用的特征能够实现相当多的高阶模板技术，但它们远远没有涵盖语言中反射功能的所有需求。

17.9 节也展示了一种潜在的、未来的代码生成机制。在现有的 C++ 语言中创建一个灵活的、通用的、对程序员友好的代码生成机制仍然是一个挑战，各方都在探讨。然而，实例化模板其实一直就是某种代码生成机制。此外，编译器在将小型函数调用展开为内联方面已经变得足够可靠，以至于该机制可被用作代码生成的工具。结合更强大的反射功能，现有的技术已经可以实现出色的元编程效果。

## 递归实例化的代价

当编译器对以下表达式求值时：

```c++
(16 <= 8 * 8) ? Sqrt<16, 1, 8>::value : Sqrt<16, 9, 16>::value;
```

它不但会去实例化肯定分支，也会去实例化否定分支（`Sqrt<16, 9, 16>`）。进而，因为代码尝试使用 `::` 运算符去访问结果类类型的一个成员，该类类型的所有成员都会被实例化。

幸好，有技巧可以减轻实例化数目的爆炸型增长。这里的关键变化是使用 `IfThenElse` 模板。请记住，`IfThenElse` 模板是一个基于给定的布尔常数在两种类型之间进行选择的工具。如果常数为 `true`，第 1 种类型被类型别名为 `Type`；否则，`Type` 代表第 2 种类型。在此，重要的是记住，为一个类模板定义一个类型别名并不会导致 C++ 编译器对该实例的内容进行实例化。因此，当我们写

```c++
using SubT = IfThenElse<N<mid*mid>,
                          Sqrt<N, LO, mid-1>,
                          Sqrt<N, mid, HI>>;
```

`Sqrt<N, LO, mid-1>` 和 `Sqrt<N, mid, HI>` 都没有完全被实例化。无论两个类型中的那一个最终成为 `SubT` 的别名，只有查找 `SubT::value` 时该类型才被完全实例化。与第一种方法相比，这种方法带来的实例化的数量与 log2(N) 成正比：当 N 变得相当大时，这就非常显著地降低了元编程的成本。

## 计算完备性

模板元编程可以包括如下内容。

- 状态变量：模板形参。
- 循环构造：通过递归。
- 执行路径选择：通过使用条件表达式或者特化。
- 整型算术。

如果不限制实例化的层数以及状态变量的数目，可以证明这些足以进行任何可计算的计算。然而，使用模板进行这样的计算可能并不方便。此外，因为模板实例化需要相当可观的编译器资源，大量的递归实例化会迅速拖慢编译器甚至耗尽可用的资源。C++ 标准建议最少允许 1024 层递归实例化，但不强制要求，这对大多数（当然不是全部）模板元编程任务是够用的。

所以，在实践中，应当克制地使用模板元编程。不过有几种情况中，要实现方便的模板时，它们是不可替代的手段。特别地，它们有时可以在更加常规的模板内部为关键算法实现提高性能。

## 递归实例化还是递归模板实参

较新的 C++ 实现考虑到了嵌套的模板标识在现代 C++ 程序中相当普遍，并使用巧妙的压缩技术来大大减少名称编码的增长。这些较新的编译器也避免了在实际不需要的情况下生成一个重整过的名称，因为实际上没有为模板实例生成低级代码。尽管如此，在其他条件相同的情况下，也许更好的方式是组织递归实例化从而避免将模板参数也递归嵌套。

## 枚举值还是静态常量

C++11 中引入了 `constexpr` 静态数据成员，它们并不限于整型。它们解决不了地址（左值引用参数传址）问题，但是除了这个缺点，它们目前是元程序给出结果的一个通用方式。它们的优势在于拥有正确的类型（而非徒有表面形式的枚举类型），并且以 `auto` 类型说明符声明的时候类型能被推导出来。C++17 增加了 `inline` 静态数据成员，它解决了上述的地址问题，并能和 `constexpr` 配合使用。
