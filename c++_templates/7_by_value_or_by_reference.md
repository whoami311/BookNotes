# 传值还是传引用

从一开始，C++ 就提供了传值调用和传引用调用两种传参方式，但决定选用哪一种并不总是那么容易：通常复杂对象传引用调用成本更低但也更复杂。C++ 在原先两种方式的基础上增加了移动语义，这意味着现在我们可能通过不同的方式来传引用。

- `X const&`（常量左值引用）：参数引用传递对象，但不能修改它。
- `X&`（非常量左值引用）：参数引用传递对象，并能修改它。
- `X&&`（右值引用）：参数通过移动语义引用传递对象，这意味着可以修改或“窃取”值。

决定如何用已知的具体类型来声明参数已经够复杂了。在模板中，类型是未知的，因此很难决定哪种传递方式是适合的。

尽管如此，我们确实建议在函数模板中用传值的方式来传参，除非有充分的理由，比如以下情况：

- 无法拷贝。
- 参数用于返回数据。
- 模板保留原始实参的所有属性，只是转发参数到其他地方。
- 性能可获得明显提升。

## 传值

当按值传递实参时，原则上必须拷贝每个参数。因此，每个参数都成为传递实参的一份副本。对于类，通过拷贝创建的对象通常由拷贝构造函数初始化。

事实上，编译器可能会优化掉拷贝对象的拷贝操作，并且通过使用移动语义，甚至可以让复杂对象的传递成本变得很低。

当以纯右值（动态创建或由另一个函数返回的临时对象）直接调用函数模板时，编译器通常会优化实参传递，因此，根本不会调用拷贝构造函数。从 C++17 开始，这种优化是必需的。在 C++17 之前，编译器即使不优化掉拷贝操作，至少必须尝试使用移动语义，这通常会使得拷贝成本较低。

### 传值导致类型退化

传值还有一个必须提到的特性：当按值传递实参给形参时，类型会退化。这意味着原始数组转换为指针，并且像 `const` 和 `volatile` 这样的限定符会被移除（就像用该值来初始化一个用 `auto` 声明的对象一样）。

## 传引用

在所有情况下，传引用都不会创建副本（因为形参只是传入实参的引用），而且传递的实参类型永远不会退化。然而，有时是不能传引用的，而且即使可以传引用，在某些情况下，作为推导结果的参数类型也可能会带来问题。

### 传递常量引用

在底层，按引用传递实参是通过传递实参的地址来实现的。地址编码紧凑，因此，这对于将地址从调用者传送到被调用者本身来说很有帮助。但是，当编译调用者的代码时，传递地址可能会给编译器带来不确定性：被调用者会如何处理这个地址？理论上，被调用者可以更改通过该地址“可访问”的所有值。这意味着，编译器必须假设它可能缓存的所有值（通常存储在设备寄存器中）在调用之后都是无效的，而重新加载所有值的代价很高。你或许会想我们可以传递常量引用：难道编译器不能由此推导出不可能发生任何更改吗？遗憾的是，事实上确实不能，因为调用者可以通过自己的非常量引用来修改这个被引用的对象。

不过对于内联函数来说情况会好些：如果编译器可以展开内联调用，那么他可以将调用者和被调用者放在一起推理，并且在许多情况下“看到”该地址除了传递底层原始数值外没有任何其他用途。函数模板常常很短，因此很可能会被选中进行内联展开。但是，如果模板封装了更复杂的算法，就不太可能会进行内联展开了。

#### 传引用不会导致类型退化

当按引用传递实参时，其类型不会退化。也就是说原始数组不会转换为指针，并且也不会移除诸如 `const` 和 `volatile` 之类的限定符。不过，由于调用参数声明为 `T const&`，模板参数 `T` 本身不会推导为 `const` 类型。

### 传递非常量引用

当希望通过传递实参来返回（其修改后的）变量值时（即当想使用 out 或 inout 参数时），必须使用非常量引用（除非你更喜欢通过指针传递实参）。同样，这意味着在传递参数时，不会创建任何副本。被调用函数模板的参数直接就是所传实参。

如果想禁止传递常量对象给非常量引用，可以执行以下操作。

- 使用静态断言来触发编译器错误。
- 通过使用 `std::enable_if<>` 来禁用此情况下的模板。

### 传递转发引用

使用转发引用的一个原因是其能够完美转发参数。当使用转发引用时，其定义为一个模板参数的右值引用，适用于特殊规则。

可以将任意类型参数传递给转发引用，而且像普通传引用一样不会创建任何副本。

## 使用 `std::ref()` 和 `std::cref()`

从 C++11 开始，调用者可以自行决定对于函数模板实参是传值还是传引用。当模板声明为按值获取实参时，调用者可以使用在头文件 `<functional>` 中声明的 `std::ref()` 和 `std::cref()` 来按引用传递实参。

然而，`std::cref()` 并不会改变模板内部处理参数的方式。而是它使用了一个技巧：通过一个行为类似引用的对象来包装传递的实参。实际上，它创建了一个 `std::reference_wrapper<>` 类型的对象，该对象引用了原始实参，并将这个对象以值的形式传递给函数模板。这个包装器或多或少支持一种操作：将隐式类型转换回原始类型，生成原始实参对象。因此，只要对于传递对象存在有效操作（符），就可以改用引用包装器。

编译器必须知道隐式转换回原始类型是必要的（才会进行隐式转换）。正因如此，`std::ref()` 和 `std::cref()` 通常只有在通过泛型代码传递对象时才能正常工作。

类 `std::reference_wrapper<>` 的作用是让我们使用引用，可以拷贝它并按值传递给函数模板，也可以在类中使用它。但是最终还是需要将其转换回底层原始类型。

## 处理字符串字面量和原始数组

将字符串字面量和原始数组用作模板参数（传值和传引用）时的不同效果。

- 传值的参数类型会退化，因而它们变成指向元素且与之类型匹配的指针。
- 由于任何形式传引用的参数类型都不会退化，因此实参成为仍指向数组的引用。

两种方式各有好坏。一方面，当数组退化为指针时，就无法区分是在处理指向元素的指针还是传入的数组。另一方面，当处理的参数可能是传入的字符串字面量时，没有类型退化也会成为一个问题，因为不同长度的字符串字面量具有不同的类型。

退化在许多情况下也是有帮助的，特别是在检查两个对象（都作为实参传递，或者一个作为实参传递，并用它给另一个赋值）是否具有或者可转换为同样类型时，一个典型用法是完美转发。但如果想使用完美转发，必须将参数声明为转发引用。在这些情况下，可以使用类型特征 `std::decay<>()` 来显式退化实参类型。
