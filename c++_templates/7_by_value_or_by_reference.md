# 传值还是传引用

从一开始，C++ 就提供了传值调用和传引用调用两种传参方式，但决定选用哪一种并不总是那么容易：通常复杂对象传引用调用成本更低但也更复杂。C++ 在原先两种方式的基础上增加了移动语义，这意味着现在我们可能通过不同的方式来传引用。

- `X const&`（常量左值引用）：参数引用传递对象，但不能修改它。
- `X&`（非常量左值引用）：参数引用传递对象，并能修改它。
- `X&&`（右值引用）：参数通过移动语义引用传递对象，这意味着可以修改或“窃取”值。

决定如何用已知的具体类型来声明参数已经够复杂了。在模板中，类型是未知的，因此很难决定哪种传递方式是适合的。

尽管如此，我们确实建议在函数模板中用传值的方式来传参，除非有充分的理由，比如以下情况：

- 无法拷贝。
- 参数用于返回数据。
- 模板保留原始实参的所有属性，只是转发参数到其他地方。
- 性能可获得明显提升。

## 传值

当按值传递实参时，原则上必须拷贝每个参数。因此，每个参数都成为传递实参的一份副本。对于类，通过拷贝创建的对象通常由拷贝构造函数初始化。

事实上，编译器可能会优化掉拷贝对象的拷贝操作，并且通过使用移动语义，甚至可以让复杂对象的传递成本变得很低。

当以纯右值（动态创建或由另一个函数返回的临时对象）直接调用函数模板时，编译器通常会优化实参传递，因此，根本不会调用拷贝构造函数。从 C++17 开始，这种优化是必需的。在 C++17 之前，编译器即使不优化掉拷贝操作，至少必须尝试使用移动语义，这通常会使得拷贝成本较低。

### 传值导致类型退化

传值还有一个必须提到的特性：当按值传递实参给形参时，类型会退化。这意味着原始数组转换为指针，并且像 `const` 和 `volatile` 这样的限定符会被移除（就像用该值来初始化一个用 `auto` 声明的对象一样）。

## 传引用

在所有情况下，传引用都不会创建副本（因为形参只是传入实参的引用），而且传递的实参类型永远不会退化。然而，有时是不能传引用的，而且即使可以传引用，在某些情况下，作为推导结果的参数类型也可能会带来问题。

### 传递常量引用

在底层，按引用传递实参是通过传递实参的地址来实现的。地址编码紧凑，因此，这对于将地址从调用者传送到被调用者本身来说很有帮助。但是，当编译调用者的代码时，传递地址可能会给编译器带来不确定性：被调用者会如何处理这个地址？理论上，被调用者可以更改通过该地址“可访问”的所有值。这意味着，编译器必须假设它可能缓存的所有值（通常存储在设备寄存器中）在调用之后都是无效的，而重新加载所有值的代价很高。你或许会想我们可以传递常量引用：难道编译器不能由此推导出不可能发生任何更改吗？遗憾的是，事实上确实不能，因为调用者可以通过自己的非常量引用来修改这个被引用的对象。

不过对于内联函数来说情况会好些：如果编译器可以展开内联调用，那么他可以将调用者和被调用者放在一起推理，并且在许多情况下“看到”该地址除了传递底层原始数值外没有任何其他用途。函数模板常常很短，因此很可能会被选中进行内联展开。但是，如果模板封装了更复杂的算法，就不太可能会进行内联展开了。

#### 传引用不会导致类型退化

当按引用传递实参时，其类型不会退化。也就是说原始数组不会转换为指针，并且也不会移除诸如 `const` 和 `volatile` 之类的限定符。不过，由于调用参数声明为 `T const&`，模板参数 `T` 本身不会推导为 `const` 类型。

### 传递非常量引用

当希望通过传递实参来返回（其修改后的）变量值时（即当想使用 out 或 inout 参数时），必须使用非常量引用（除非你更喜欢通过指针传递实参）。同样，这意味着在传递参数时，不会创建任何副本。被调用函数模板的参数直接就是所传实参。

如果想禁止传递常量对象给非常量引用，可以执行以下操作。

- 使用静态断言来触发编译器错误。
- 通过使用 `std::enable_if<>` 来禁用此情况下的模板。

### 传递转发引用

使用转发引用的一个原因是其能够完美转发参数。当使用转发引用时，其定义为一个模板参数的右值引用，适用于特殊规则。

可以将任意类型参数传递给转发引用，而且像普通传引用一样不会创建任何副本。

## 使用 `std::ref()` 和 `std::cref()`

从 C++11 开始，调用者可以自行决定对于函数模板实参是传值还是传引用。当模板声明为按值获取实参时，调用者可以使用在头文件 `<functional>` 中声明的 `std::ref()` 和 `std::cref()` 来按引用传递实参。

然而，`std::cref()` 并不会改变模板内部处理参数的方式。而是它使用了一个技巧：通过一个行为类似引用的对象来包装传递的实参。实际上，它创建了一个 `std::reference_wrapper<>` 类型的对象，该对象引用了原始实参，并将这个对象以值的形式传递给函数模板。这个包装器或多或少支持一种操作：将隐式类型转换回原始类型，生成原始实参对象。因此，只要对于传递对象存在有效操作（符），就可以改用引用包装器。

编译器必须知道隐式转换回原始类型是必要的（才会进行隐式转换）。正因如此，`std::ref()` 和 `std::cref()` 通常只有在通过泛型代码传递对象时才能正常工作。

类 `std::reference_wrapper<>` 的作用是让我们使用引用，可以拷贝它并按值传递给函数模板，也可以在类中使用它。但是最终还是需要将其转换回底层原始类型。

## 处理字符串字面量和原始数组

将字符串字面量和原始数组用作模板参数（传值和传引用）时的不同效果。

- 传值的参数类型会退化，因而它们变成指向元素且与之类型匹配的指针。
- 由于任何形式传引用的参数类型都不会退化，因此实参成为仍指向数组的引用。

两种方式各有好坏。一方面，当数组退化为指针时，就无法区分是在处理指向元素的指针还是传入的数组。另一方面，当处理的参数可能是传入的字符串字面量时，没有类型退化也会成为一个问题，因为不同长度的字符串字面量具有不同的类型。

退化在许多情况下也是有帮助的，特别是在检查两个对象（都作为实参传递，或者一个作为实参传递，并用它给另一个赋值）是否具有或者可转换为同样类型时，一个典型用法是完美转发。但如果想使用完美转发，必须将参数声明为转发引用。在这些情况下，可以使用类型特征 `std::decay<>()` 来显式退化实参类型。

### 字符串字面量和原始数组的特殊实现

有时可能必须根据传递的是指针还是数组来区分不同的实现方式，要区分这些情况，必须检查传入的是否是数组。基本上有两种选择。

- 可以声明模板参数，使其仅对数组有效（只能接收数组作为参数）。

```c++
template <typename T, std::size_t L1, std::size_t L2>
void foo(T (&arg1)[L1], T (&arg2)[L2]) {
    T* pa = arg1;   // arg1 退化
    T* pb = arg2;   // arg2 退化
    if (compareArrays(pa, L1, pb, L2)) {
        ...
    }
}
```

- 可以使用类型特征来检查是否传递了数组（或指针）。

```c++
template <typename T, typename = std::enable_if_t<std::is_array_v<T>>>
void foo(T&& arg1, T&& arg2) {
    ...
}
```

由于这些特殊实现的方式太过复杂，往往以不同方式处理数组的最佳方法，仅仅就是简单使用不同的函数名。当然更好的方法是确保模板调用者使用 `std::vector` 或者 `std::array` 来传递参数。但只要字符串字面量还是原始数组，就必须始终单独考虑它们。

## 处理返回值

对于返回值来说，也可以决定是按值返回还是按引用返回。然而因为引用的对象已经失控，返回引用可能是问题的根源。不过在以下情况中，返回引用是常见的编程惯例。

- 返回容器或者字符串中的元素（例如，通过 `operator[]` 或 `front()`）。
- 允许写访问类成员。
- 为链式调用返回对象（对于流操作的 `operator<<` 和 `operator>>`，以及通常类对象的赋值运算符 `operator=`）。

此外，通过返回常量引用来给予成员只读访问权限也是很常见的。

我们应该确保函数模板按值返回结果。安全起见，有两种选择。

- 适用类型特征 `std::remove_reference<>` 将类型 `T` 转换为非引用类型。
- 通过仅声明返回类型为 `auto`（从 C++14 开始），让编译器来推导返回类型。因为 `auto` 总会导致类型退化。

## 推荐的模板参数声明方法

- 将参数声明为**按值**传递。
    这种方法很简单，它会使字符串字面量和原始数组类型退化，但对于大型对象而言性能不佳。调用者仍然可以决定使用 `std::cref()` 和 `std::ref()` 来传引用，但必须确认引用对象是否有效。
- 将参数声明为**按引用**传递。
    这种方法经常能为一些大型对象提供较好的性能，尤其是在做以下传递时。
    - 传递现存对象（左值）给左值引用。
    - 传递临时对象（纯右值）或可移动对象（将亡值）给右值引用。
    - 或以上两者都传递给转发引用。

1. 一般性建议

对于函数模板我们的建议如下。

- 默认情况下，将参数声明为**按值传递**。这种方法比较简单，即使是字符串字面量通常也可以正常工作。对于小型实参、临时对象或可移动对象来说性能很好。当传递现存的大型对象（左值）时，调用者有时可以使用 `std::ref()` 和 `std::cref()` 来避免高昂的拷贝成本。
- 如果有充分的理由，则采用其他方法。
    - 如果需要 out 或 inout 参数（该参数返回一个新对象或允许修改调用者的实参），就按非常量引用来传递实参（除非你更喜欢传递指针）。然后，需要考虑禁止意外接收 `const` 对象。
    - 如果模板是用来**转发**实参的，就使用完美转发。也就是将参数声明为转发引用并在合适的地方使用 `std::forward<>()`。考虑使用 `std::decay<>` 或者 `std::common_type<>`，使得对不同的字符串字面量和原始数组类型的处理方式一致。
    - 如果**性能**是关键，而且预计实参拷贝成本很高，就使用常量引用。当然，如果无论如何还是需要本地副本，那么这条建议不适用。

2. 不要过度泛化

在实践中，函数模板常常并不是适用于任意实参类型的，而是有所限制。在这种情况下，最好不要将函数模板声明得过于泛化（可能会出现令人意外的副作用）。

3. 以 `std::make_pair<>()` 为例

```c++
template <typename T1, typename T2>
constexpr pair<typename decay<T1>::type, typename decay<T2>::type>
make_pair(T1&& a, T2&& b) {
    return pair<typename decay<T1>::type,
                typename decay<T2>::type>(forward<T1>(a),
                                          forward<T2>(b));
}
```

完整的实现甚至更复杂：为了支持 `std::ref()` 和 `std::cref()`，该函数还会将 `std::reference_wrapper` 的实例展开为真正的引用。

目前 C++ 标准库在许多地方都通过类似方法完美地转发传递的实参，而且经常结合使用 `std::decay<>`.

## 小结

- 使用不同长度的字符串字面量来测试模板。
- 传值的话模板参数的类型会退化，传引用则不会。
- 类型特征 `std::decay<>` 允许手动退化按引用传递的模板参数类型。
- 在某些情况下，当函数模板声明为传值时，可以使用 `std::ref()` 和 `std::cref()` 来间接模拟传引用。
- 传值简单但可能不会带来最佳性能。
- 除非有充分理由，否则函数模板的参数按值传递。
- 确保返回值通常按值传递（这可能意味着模板参数不能直接指定为返回类型）。
- 当性能很重要时，始终要实际测试。不要依赖直觉：它可能是错的。
