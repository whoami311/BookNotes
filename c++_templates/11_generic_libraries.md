# 泛型库

## 可调用对象

C++ 的一些类型适用于回调，因为它们既可以作为函数的调用实参被传入，也可以按照 `f(...)` 的形式直接被调用。

- 指涉函数类型的指针。
- 带有重载运算符 `()`〔有时称为仿函数（functor）〕的类类型，包括 lambda 表达式。
- 带有转换函数的类类型，该转换函数返回一个指涉函数的指针或函数引用。这些类型称为函数对象类型（function object type），这样的类型的值称为函数对象（function object）。

C++ 标准库引入了更广泛的可调用类型（callable type）的概念，既可以是函数对象类型，也可以是指涉成员的指针。方便起见，可调用类型的对象被称为可调用对象（callable object）。

泛型代码通常能够接收任意类型的可调用对象，而模板使其成为可能。

### 函数对象的支持

- 当把函数名称作为函数参数传入时，真正传入的并不是函数本身，而是指涉函数的指针或引用。同数组一样，按值传递时，函数参数退化（decay）为指针。对于类型为参数模板形参的参数，将推导成指涉函数类型的指针。

同数组一样，按引用传递的函数不会发生退化。但是，实际上函数类型不能使用 `const` 修饰符约束。（总体来说，主流 C++ 代码中很少使用函数引用。）

- 通过传入函数名称的地址，显式地使用了函数指针。
- 当传入仿函数时，传入的是类类型对象作为可调用对象。通常调用类类型相当于调用其 `operator()`。因此，以下调用
    ```c++
    op(*current);
    ```
    通常会转换为
    ```c++
    op.operator()(*current); //调用 op 的函数 operator()，参数为 *current
    ```
    注意，当定义 `operator()` 时，通常应该将其定义为常量成员函数。否则，当框架或库期望调用不会改变传入对象的状态时，可能会出现细微的错误消息。
    类类型也可以隐式转换为指涉代理调用函数（surrogate call function）的指针或者引用。在这种情况下，如下调用
    ```cpp
    op(*current);
    ```
    通常会转换为
    ```cpp
    (op.operator F())(*current);
    ```
    其中，`F` 是由类类型对象转化成的指涉函数的指针类型或者指涉函数的引用类型。这很不寻常。
- lambda 表达式生成仿函数〔也称为闭包（closure）〕，这种情况与仿函数的情况相似。

有意思的是，以 `[]` 开始的 lambda 表达式（没有捕获）会生成一个向函数指针转换的运算符，但是，却从来不会被当作代理调用函数，这是因为其匹配的情况总是比常规闭包的 `operator()` 要差。

### 处理成员函数及额外的参数

从 C++17 开始，C++ 标准库提供了一个实用工具 `std::invoke()`，该工具能方便地统一这种情况与常规函数的调用语法，从而可以使用同一种方式调用任意可调用对象。

`std::invoke()` 按照如下方式处理相关参数。

- 如果可调用对象是一个指涉成员函数的指针，它使用第 1 个附加参数作为 `this` 对象，剩余的所有附加参数作为参数传递给可调用对象。
- 否则，所有附加参数作为参数传递给可调用对象。

### 封装函数调用

`decltype(auto)`（从 C++14 开始可用）是一个占位符类型（placeholder type），它可以根据关联表达式的类型（如初始化器、返回值或模板实参）来确定变量的类型、返回类型或模板实参。

然而，使用 `decltype(auto)` 也存在一个问题：如果调用对象返回 `void` 类型，则将 `ret` 初始化为 `decltype(auto)` 是不可以的，因为 `void` 是非完整类型。但有以下几种选择。

- 在当前行语句前声明一个对象，并在其析构函数中实现期望的行为。
- 实现 `void` 和非 `void` 的不同情况。

## 实现泛型库的其他工具

### 类型特征

标准库提供了各种称为类型特征的实用工具。该实用工具允许开发者计算和修改类型。这样，就能在各种情况下支持泛型代码必须适配其实例化的类型的功能或对其做出反应。

通过检查某些条件，可以在模板的不同实现中进行选择。可以使用编译期的 `if` 特性，该特性从 C++17 开始可用，也可以使用 `std::enable_if<>`、偏特化或者 SFINAE 来启用或禁用帮助模板。

```c++
std::remove_const_t<int const&>     // 返回 int const&
```

这里，因为引用不是常量（虽然无法改变它），所以此调用没有生效，并且返回传入的类型。

```c++
is_copy_assignable_v<int>   // 返回 true（通常，可以使用一个 int 类型的数据给另一个 int 类型的数据赋值）
is_assignable_v<int, int>   // 返回 false（无法调用 42 = 42）
```

`is_copy_assignable` 通常只会检查是否可以将一个 `int` 类型的数据赋值给另一个 `int` 类型的数据（检查左值的相关操作）。而 `is_assignable` 则会考虑值类别（value category），检查能否将一个纯右值（prvalue）赋值给另外一个纯右值。也就是说，第 1 个表达式等同于

```c++
is_assignable_v<int&, int&>     // 返回 true
```

出于同样原因：

```c++
is_swappable_v<int>             // 返回 true（假设左值）
is_swappable_v<int&, int&>      // 返回 true（等同于前一个检查）
is_swappable_with_v<int, int>   // 返回 false（考虑值类别）
```
