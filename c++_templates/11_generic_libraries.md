# 泛型库

## 可调用对象

C++ 的一些类型适用于回调，因为它们既可以作为函数的调用实参被传入，也可以按照 `f(...)` 的形式直接被调用。

- 指涉函数类型的指针。
- 带有重载运算符 `()`〔有时称为仿函数（functor）〕的类类型，包括 lambda 表达式。
- 带有转换函数的类类型，该转换函数返回一个指涉函数的指针或函数引用。这些类型称为函数对象类型（function object type），这样的类型的值称为函数对象（function object）。

C++ 标准库引入了更广泛的可调用类型（callable type）的概念，既可以是函数对象类型，也可以是指涉成员的指针。方便起见，可调用类型的对象被称为可调用对象（callable object）。

泛型代码通常能够接收任意类型的可调用对象，而模板使其成为可能。

### 函数对象的支持

- 当把函数名称作为函数参数传入时，真正传入的并不是函数本身，而是指涉函数的指针或引用。同数组一样，按值传递时，函数参数退化（decay）为指针。对于类型为参数模板形参的参数，将推导成指涉函数类型的指针。

同数组一样，按引用传递的函数不会发生退化。但是，实际上函数类型不能使用 `const` 修饰符约束。（总体来说，主流 C++ 代码中很少使用函数引用。）

- 通过传入函数名称的地址，显式地使用了函数指针。
- 当传入仿函数时，传入的是类类型对象作为可调用对象。通常调用类类型相当于调用其 `operator()`。因此，以下调用
    ```c++
    op(*current);
    ```
    通常会转换为
    ```c++
    op.operator()(*current); //调用 op 的函数 operator()，参数为 *current
    ```
    注意，当定义 `operator()` 时，通常应该将其定义为常量成员函数。否则，当框架或库期望调用不会改变传入对象的状态时，可能会出现细微的错误消息。
    类类型也可以隐式转换为指涉代理调用函数（surrogate call function）的指针或者引用。在这种情况下，如下调用
    ```cpp
    op(*current);
    ```
    通常会转换为
    ```cpp
    (op.operator F())(*current);
    ```
    其中，`F` 是由类类型对象转化成的指涉函数的指针类型或者指涉函数的引用类型。这很不寻常。
- lambda 表达式生成仿函数〔也称为闭包（closure）〕，这种情况与仿函数的情况相似。

有意思的是，以 `[]` 开始的 lambda 表达式（没有捕获）会生成一个向函数指针转换的运算符，但是，却从来不会被当作代理调用函数，这是因为其匹配的情况总是比常规闭包的 `operator()` 要差。

### 处理成员函数及额外的参数

从 C++17 开始，C++ 标准库提供了一个实用工具 `std::invoke()`，该工具能方便地统一这种情况与常规函数的调用语法，从而可以使用同一种方式调用任意可调用对象。

`std::invoke()` 按照如下方式处理相关参数。

- 如果可调用对象是一个指涉成员函数的指针，它使用第 1 个附加参数作为 `this` 对象，剩余的所有附加参数作为参数传递给可调用对象。
- 否则，所有附加参数作为参数传递给可调用对象。

### 封装函数调用

`decltype(auto)`（从 C++14 开始可用）是一个占位符类型（placeholder type），它可以根据关联表达式的类型（如初始化器、返回值或模板实参）来确定变量的类型、返回类型或模板实参。

然而，使用 `decltype(auto)` 也存在一个问题：如果调用对象返回 `void` 类型，则将 `ret` 初始化为 `decltype(auto)` 是不可以的，因为 `void` 是非完整类型。但有以下几种选择。

- 在当前行语句前声明一个对象，并在其析构函数中实现期望的行为。
- 实现 `void` 和非 `void` 的不同情况。

## 实现泛型库的其他工具

### 类型特征

标准库提供了各种称为类型特征的实用工具。该实用工具允许开发者计算和修改类型。这样，就能在各种情况下支持泛型代码必须适配其实例化的类型的功能或对其做出反应。

通过检查某些条件，可以在模板的不同实现中进行选择。可以使用编译期的 `if` 特性，该特性从 C++17 开始可用，也可以使用 `std::enable_if<>`、偏特化或者 SFINAE 来启用或禁用帮助模板。

```c++
std::remove_const_t<int const&>     // 返回 int const&
```

这里，因为引用不是常量（虽然无法改变它），所以此调用没有生效，并且返回传入的类型。

```c++
is_copy_assignable_v<int>   // 返回 true（通常，可以使用一个 int 类型的数据给另一个 int 类型的数据赋值）
is_assignable_v<int, int>   // 返回 false（无法调用 42 = 42）
```

`is_copy_assignable` 通常只会检查是否可以将一个 `int` 类型的数据赋值给另一个 `int` 类型的数据（检查左值的相关操作）。而 `is_assignable` 则会考虑值类别（value category），检查能否将一个纯右值（prvalue）赋值给另外一个纯右值。也就是说，第 1 个表达式等同于

```c++
is_assignable_v<int&, int&>     // 返回 true
```

出于同样原因：

```c++
is_swappable_v<int>             // 返回 true（假设左值）
is_swappable_v<int&, int&>      // 返回 true（等同于前一个检查）
is_swappable_with_v<int, int>   // 返回 false（考虑值类别）
```

### `std::addressof()`

`std::addressof<>()` 函数模板返回一个对象或函数的实际地址。即使一个对象重载了运算符 `&`，也可以工作。

### `std::declval()`

`std::declval<>()` 函数模板可以用作特定类型对象的引用的占位符。因为该函数模板没有定义，所以不能被调用（也不能创建对象）。因此，该函数模板只能用于未评估的操作数（unevaluated operand），比如 `decltype` 和 `sizeof` 构造的操作数。也因此，其可以在不创建对象的情况下，假设有相应类型的可用对象。

## 完美转发临时变量

有些时候，泛型代码需要完美转发一些并不是通过参数传入的数据。在这种情况下，可以使用 `auto&&` 来创建一个可以被转发的变量。

## 作为模板参数的引用

由于使用 `decltype(auto)` 可以很容易地得到引用类型，因此在这一类的上下文（默认使用 `auto`）中应该尽量避免使用 `auto`。

出于这个原因，C++ 标准库有时会有令人惊讶的规范和约束，具体如下。

- 尽管模板参数被实例化为引用类型，但为了能正常使用赋值运算符，相比使用默认行为，类 `std::pair<>` 和 `std::tuple<>` 很好地实现了赋值运算符。
- 由于可能存在的副作用的复杂性，在 C++17 标准库中，使用引用类型来实例化类模板 `std::optional<>` 和 `std::variant<>` 一直是非正式的（至少在 C++17 中是这样的）。

一般来说，引用类型和其他类型不太一样，并且遵循一些特有的语言规则。比如，这会影响调用参数的声明和类型特征的定义。

## 关于泛型库的思考

下面列出了一些在实现泛型库时需要记住的事情。

- 使用转发引用来转发模板中的值。如果这些值不依赖于模板参数，请使用 `auto&&`。
- 当参数被声明为转发引用时，模板参数在传递左值时应具有引用类型。
- 当需要依赖模板参数的对象的地址时，请使用 `std::addressof()`，以避免绑定具有重载运算符 `&` 的类型时出现意外。
- 对于成员函数模板，请确保预定义的拷贝/移动构造函数或赋值运算符要比其本身匹配的更好。
- 当模板参数可能是字符串字面值，并且不通过值传递时，考虑使用 `std::decay<>`。
- 当根据模板参数使用参数 out 或 inout 时，请准备好处理可能指定常量模板参数的情况。
- 准备好处理引用类型的模板参数带来的副作用。尤其是，希望能够确保返回的不是引用类型。
- 准备好处理非完整类型，以支持递归数据结构等。
- 重载所有的数组类型，而不仅仅是 `T[SZ]`。

## 小结

- 模板允许将函数、函数指针、函数对象、仿函数和 lambda 表达式作为可调用对象进行传递。
- 使用定义带有重载 `operator()` 的类时，应将其声明为 `const`（除非调用改变其状态）。
- 使用 `std::invoke()`，可以实现处理所有可调用函数的代码（包括成员函数）。
- 使用 `decltype(auto)` 可以完美转发返回值。
- 类型特征是用于检查类型的属性和功能的类型函数。
- 当需要模板中对象的地址时，请使用 `std::addressof()`。
- 使用 `std::declval()` 在未求值的表达式中创建特定类型的值。
- 如果对象的类型不依赖于模板参数，在泛型代码中，可以使用 `auto&&` 完美转发该对象。
- 准备好处理引用类型的模板参数带来的副作用。
- 使用模板来延迟表达式的求值（比如在类模板中使用非完整类型）。
