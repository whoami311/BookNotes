# 特化与重载

## 当“泛型代码”不是特别适用的时候

### 透明自定义

C++ 模板提供了透明自定义函数模板和类模板的一些方法。对于函数模板的透明自定义，可以通过重载机制来实现。

## 重载函数模板

### 签名

如果两个函数有不同的签名，那么它们可以在一个程序中同时存在。我们对函数签名的定义如下。

- 函数的非受限名称（或产生自函数模板的这类名称）。
- 该名称的类作用域或命名空间作用域。如果该函数名称具有内部链接，则作用域为该名称声明所在的编译单元。
- 函数的 `const`、`volatile` 或 `const volatile` 限定符（如果它是一个具有这类限定符的成员函数）。
- 函数的 `&` 或 `&&` 限定符（如果它是一个具有这类限定符的成员函数）。
- 函数参数的类型（如果这个函数是由函数模板生成的，那么指的是模板参数被替换之前的类型）。
- 如果这个函数是由函数模板生成的，那么包括它的返回类型。
- 如果这个函数是由函数模板生成的，那么包括它的模板参数和模板实参。

### 正式的排序规则

重载解析规则明确如下内容。

- 默认实参包含的函数调用参数和未使用的省略号参数，在后面的内容中将不再考虑。
- 然后，我们通过替换每个模板参数来虚构两个不同的实参类型（或转换函数模板的返回类型）列表，如下所示。
    - 用唯一的类型替换每个模板类型参数。
    - 用唯一的类模板替换每个模板参数。
    - 用适当类型的唯一值替换每个非类型模板参数（在此上下文中创建的类型、模板和值，不同于程序员在其他上下文中使用的或编译器在其他上下文中合成的任何其他类型、模板和值）。
- 如果第 2 个模板可以成功对第 1 个综合参数类型列表进行模板实参演绎，并且能够精确匹配，但反之则不然，则第 1 个模板比第 2 个模板更加特殊。与此相反，如果第 1 个模板可以成功对第 2 个综合参数类型列表进行模板实参演绎，并且能够精确匹配，但反之则不然，则第 2 个模板比第 1 个模板更加特殊。否则的话（要么都没有演绎成功，要么两者都演绎成功），我们认为这两个模板之间没有排序关系。

### 模板和非模板

函数模板可以和非模板函数重载。在其他条件相同的时候，实际的函数调用将会优先选择非模板函数。

当成员函数模板可能隐藏拷贝或移动构造函数时，通常必须部分禁用它们。

### 变参函数模板

当正式的排序规则应用于变参模板时，每个模板参数包都被一个单独的组合类型、类模板或值所取代。
