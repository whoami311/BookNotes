# 特化与重载

## 当“泛型代码”不是特别适用的时候

### 透明自定义

C++ 模板提供了透明自定义函数模板和类模板的一些方法。对于函数模板的透明自定义，可以通过重载机制来实现。

## 重载函数模板

### 签名

如果两个函数有不同的签名，那么它们可以在一个程序中同时存在。我们对函数签名的定义如下。

- 函数的非受限名称（或产生自函数模板的这类名称）。
- 该名称的类作用域或命名空间作用域。如果该函数名称具有内部链接，则作用域为该名称声明所在的编译单元。
- 函数的 `const`、`volatile` 或 `const volatile` 限定符（如果它是一个具有这类限定符的成员函数）。
- 函数的 `&` 或 `&&` 限定符（如果它是一个具有这类限定符的成员函数）。
- 函数参数的类型（如果这个函数是由函数模板生成的，那么指的是模板参数被替换之前的类型）。
- 如果这个函数是由函数模板生成的，那么包括它的返回类型。
- 如果这个函数是由函数模板生成的，那么包括它的模板参数和模板实参。

### 正式的排序规则

重载解析规则明确如下内容。

- 默认实参包含的函数调用参数和未使用的省略号参数，在后面的内容中将不再考虑。
- 然后，我们通过替换每个模板参数来虚构两个不同的实参类型（或转换函数模板的返回类型）列表，如下所示。
    - 用唯一的类型替换每个模板类型参数。
    - 用唯一的类模板替换每个模板参数。
    - 用适当类型的唯一值替换每个非类型模板参数（在此上下文中创建的类型、模板和值，不同于程序员在其他上下文中使用的或编译器在其他上下文中合成的任何其他类型、模板和值）。
- 如果第 2 个模板可以成功对第 1 个综合参数类型列表进行模板实参演绎，并且能够精确匹配，但反之则不然，则第 1 个模板比第 2 个模板更加特殊。与此相反，如果第 1 个模板可以成功对第 2 个综合参数类型列表进行模板实参演绎，并且能够精确匹配，但反之则不然，则第 2 个模板比第 1 个模板更加特殊。否则的话（要么都没有演绎成功，要么两者都演绎成功），我们认为这两个模板之间没有排序关系。

### 模板和非模板

函数模板可以和非模板函数重载。在其他条件相同的时候，实际的函数调用将会优先选择非模板函数。

当成员函数模板可能隐藏拷贝或移动构造函数时，通常必须部分禁用它们。

### 变参函数模板

当正式的排序规则应用于变参模板时，每个模板参数包都被一个单独的组合类型、类模板或值所取代。

## 显式特化

类模板和变量模板是不能被重载的。因此，我们选择了另一种机制来实现类模板的透明自定义：显式特化。C++ 标准中显式特化是指一种我们也称之为全局特化的语言特性。它为模板提供了一个实现，模板参数被完全替换：没有模板参数被保留。类模板、函数模板和变量模板可以完全专用化。

### 全局的类模板特化

全局特化是由 3 个标记——`template`、`<` 和 `>` 组成的序列。此外，类名称声明后面的内容是要进行特化的模板实参。

全局特化的实现不需要和泛型定义有任何关联：这允许我们拥有不同名称的成员函数。全局特化完全由类模板的名称决定。

指定的模板实参列表必须和模板参数列表一一对应。例如，为模板类型参数指定非类型参数是非法的。但是，如果模板参数具有默认模板实参，那么模板实参就是可选的。

（模板）全局特化的声明并不一定必须是定义。但是，当全局特化声明后，泛型定义将不再用于给定的模板实参集。因此，如果需要该特化的定义，但在这之前并没有提供这个定义，那么程序将出错。对于类模板特化来说，“前置声明”类型有时会很有用，因为这样就可以构造相互依赖的类型。全局特化声明与普通类声明是类似的（它并不是模板声明），唯一的区别在于语法和该特化的声明必须匹配前面的模板声明。因为全局特化声明并不是模板声明，所以可以使用普通的类外成员定义语法，来定义全局类模板特化的成员（换句话说，不能指定 `template<>` 前缀）。

全局特化是对泛型模板某个实例化体的替换。如果程序中同时存在模板的显式版本和生成的版本，那么该程序将是无效的。

必须注意确保特化的声明对泛型模板的所有用户都是可见的。实际上，这意味着：特化的声明通常应该在其头文件中的模板声明之后。当泛型实现来自外部资源时（因此不应修改相应的头文件），这种做法不一定很适用，但我们可以创建一个包含泛型模板的头文件，然后对该特化进行声明，以避免这些难以发现的错误，这可能是很有必要的。我们发现，一般来说，最好避免外部资源的模板的特化，除非它明确是为此目的而设计的。

### 全局的函数模板特化

（显式的）全局的函数模板特化背后的语法和原理和全局的类模板特化背后的语法和原理大致是相同的，只是函数模板特化引入了重载和实参演绎的概念。

如果可以通过实参演绎（使用声明中给出的实参类型作为参数类型）和局部排序来确定要特化的模板，则全局特化声明可以省略显式的模板实参。

全局的函数模板特化不能包含默认实参值。然而，对于特化的模板所指定的任何默认实参，其仍然适用于显式特化版本。这是因为全局特化提供了一个替代定义，而不是一个替代声明。在调用函数模板时，调用完全是基于函数模板的。

全局特化声明在许多方面都类似于普通声明（或者更确切地说，是普通声明的再次声明）。特别是，它不声明模板，因此，对于非内联的全局的函数模板特化而言，它的定义只能在程序中出现一次。但是，我们仍然必须确保：模板后面有一个全局特化的声明，以避免试图使用由模板生成的函数。因此，通常将模板 `g()` 的声明和全局特化的声明放在两个文件中，如下所示。

- 接口文件包含基本模板和偏特化的定义，但仅声明全局特化。
- 相应的实现文件定义为全局特化。

或者，该特化声明为内联函数，在这种情况下，它的定义就可以（而且应该）放在头文件中。

### 全局的变量模板特化

变量模板也可以全局特化，语法如下：

```c++
template <typename T> constexpr std::size_t SZ = sizeof(T);
template<> constexpr std::size_t SZ<void> = 0;
```

显然，特化可提供一个不同于模板生成值的初始值。有趣的是，变量模板特化不需要具有与被特化的模板匹配的类型。

### 全局的成员特化

除了成员模板，类模板的普通静态数据成员和成员函数也可以被全局特化。语法要求给每个封闭类模板加上 `template<>` 前缀。如果要对成员模板进行特化，则还必须加上 `template<>`，以表示它是一个特化。

与全局的函数模板特化一样，我们需要一种方法来声明类模板普通成员的特化，而且可以不指定定义（以防止有多处定义）。尽管对类的函数和静态数据成员来说，非定义的类外声明在 C++ 中是不允许的，但对类模板的特化成员来说，这种声明是合理的。

对于只能使用默认构造函数初始化的类型，对静态数据成员进行全局特化，则必须使用初始化列表语法。

### 类模板偏特化

表示偏特化的语法是：模板参数列表声明（`template<...>`）加类模板名称显式指定的模板实参列表。

偏特化声明的参数和实参列表存在如下约束。

- 偏特化的实参必须和基本模板的相应参数在种类（类型、非类型或模板）上相匹配。
- 偏特化的参数列表不能有默认实参，但可以使用基本模板的默认实参。
- 偏特化的非类型模板实参应该是非依赖型值，或普通的非类型模板参数。它们不能是更复杂的依赖型表达式，例如 `2*N`（其中，`N` 是模板参数）。
- 偏特化的模板实参列表不应和基本模板的参数列表相同（不考虑重新命名）。
- 假如其中一个模板实参是包扩展的，那么它必须位于模板参数列表的末尾。

每个偏特化和每个全局特化都会和基本模板产生关联。当使用模板时，基本模板总是被查找，但实参会和相关特化的实参进行匹配（使用模板参数演绎），然后确定模板实现。与函数模板实参演绎一样，SFINAE 原则也适用于此。假如在尝试匹配偏特化时形成了一个无效的构造，则该特化将被静默丢弃，并且检查另一个候选者是否可用。如果未找到匹配的特化，则会选择基本模板。如果找到多个匹配的特化，则选择最特殊的一个特化（从重载函数模板定义的意义上）；如果没有找到最特殊的一个特化，那么程序将会存在二义性错误。

类模板偏特化的参数个数，完全有可能比基本模板的参数个数更多或更少。

### 变量模板偏特化

下面是基于 C++ 的实现（允许这样的偏特化），而不是 C++ 标准。

变量模板偏特化的语法类似于全局变量模板特化的语法，只是 `template<>` 被实际的模板声明头替换，并且变量模板名称后面的模板参数列表必须依赖于模板参数。

与变量模板的全局特化一样，变量模板偏特化不要求偏特化的类型与基本模板的类型相匹配。

变量模板偏特化指定的模板实参类型的规则与类模板特化指定的规则相同。类似地，未给定的具体模板实参列表选择特化的规则也是相同的。
