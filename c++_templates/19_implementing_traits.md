# 特征的实现

## 一个实例：累加一个序列

### 固定特征

特征模板：持有其参数类型的特征（一般来说，可能有多个特征和多个参数）。

### 值特征

特征表示与给定主类型相关的额外类型信息。这些额外的信息并不局限于类型。常量和其他类型的值也可以与类型相关联。

特征不仅仅是额外的类型。特征可以是一种机制。特征概念的关键部分在于：特征为泛型计算提供了一条配置具体元素（主要是类型）的途径。

## 特征、policy 及 policy 类

### 特征和 policy 的区别

policy 只是特征的一个特例或者说特征只用于实现 policy。

*New Shorter Oxford English Dictionary* 中对特征和 policy 的定义如下。

- 特征：用来刻画一个事物的与众不同的特性。
- policy：为了某种有益或有利的目的而采用的一系列动作。

基于上述定义，我们倾向于将 policy 类这个概念的使用表示为对某种操作的类的编码，这些操作在很大程度上同任何其他的模板参数（与之组合）都是正交的。这与 Andrei Alexandrescu 在他的 *Modern C++ Design* 中的声明是一致的：

    policy 与特征有很多共同点，不同的是，特征更注重类型，而 policy 更注重行为。

引入特征技术的 Nathan Myers 提出了下面这个更开放的定义：

    特征类：是一种用来代替模板参数的类。作为一个类，它可以是有用的类型，也可以是常量；作为一个模板，它提供了一条实现“额外层次间接性”的途径，而正是这种“额外层次间接性”解决了大量的软件问题。

一般来说，我们倾向于使用下面的（并不是非常准确的）定义。

- 特征表示模板参数的一些额外的自然属性。
- policy 表示泛型函数和泛型类的一些可配置行为（通常具有被经常使用的默认值）。

为了进一步阐述这两个概念之间可能存在的区别，我们列出了以下关于特征的观点。

- 特征可以是固定特征（fixed trait，即不能通过模板参数进行传递的特征）。
- 特征参数通常有非常自然的默认值（它很少被改写，或者根本不能被改写）。
- 特征参数往往与一个或多个主参数密切相关。
- 特征大多是对类型和常量进行组合，而不是成员函数。
- 特征通常都是用特征模板实现的。

对于 policy 类，我们发现了以下事实。

- 如果 policy 类不作为模板参数传递，那么 policy 类几乎不起作用。
- policy 参数并不需要有默认值，并且通常是显式指定的（尽管许多泛型组件配置了常用的默认 policy）。
- policy 参数主要与一个模板的其它参数正交。
- policy 一般都包含成员函数。
- policy 既可以用普通类实现，也可以用类模板实现。

显然，这两个概念之间有一条模糊的界线。

### 成员模板和模板的模板参数

通过模板的模板参数访问 policy 类的主要优点是：使 policy 类更容易携带一些状态信息（即静态数据成员），其类型取决于模板参数（静态数据成员需嵌入成员类模板中）。

然而，使用模板的模板参数的方法的一个缺点是，policy 类现在必须被写成模板，模板参数的确切个数由我们的接口定义。这会使特征本身的表达比简单的非模板类更冗长，更不自然。

### 组合多个 policy 和（或）特征

特征和 policy 并不能完全代替多个模板参数。然而，特征和 policy 确实把模板参数的个数减少到可以控制的范围内。那么，一个有趣的问题是：如何对这么多的参数进行排序？

一个简单的策略是：根据已选择并可能用于递增的参数的默认值对各个参数进行排序。通常，这意味着特征参数将位于 policy 参数的后面，因为后者在客户端代码中更经常被重写。

## 类型函数

可以对依赖于某些类型的行为进行定义。在传统意义上，在 C 和 C++ 中，我们可以定义更准确的称为值函数（value function）的函数：它们将一些值作为参数，并返回另一个值。通过模板，我们还可以定义类型函数（type function）：将某些类型作为实参，并生成一个类型或常量的函数。

### 元素类型

### 转换特征

除了提供对基本参数特定方面的访问之外，特征还可以对类型执行转换，例如删除或添加引用、`const` 和 `volatile` 限定符等。

### 谓词特征

一种特殊形式的类型特征——谓词特征（产生一个布尔值的类型函数）。

1. ```IsSameT```

```c++
template <typename T1, typename T2>
struct IsSameT {
    static constexpr bool value = false;
};

template <typename T>
struct IsSameT<T, T> {
    static constexpr bool value = true;
};
```

2. `true_type` 与 `false_type`
