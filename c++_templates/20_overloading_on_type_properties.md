# 类型属性重载

## 算法特化

引入更特殊的泛型算法变体的设计和优化方法被称为算法特化。更特殊的变体应用于泛型算法的有效输入的子集，基于类型的特定类型或属性来识别该子集，并且通常比该泛型算法的最常用实现更为有效。

实现算法特化的关键是：当更特殊的变体适用时，算法会自动选择，而调用方不必注意这些变体是存在的。

并不是所有特化程度更高的算法变体都可以直接转换为函数模板，这些函数模板提供了正确的局部排序实现。

## 标签调度

算法特化的一种方法是：使用标识变体的唯一类型来“标识”算法的不同实现变体。

在 C++ 标准库中，可用的标签定义如下（它们使用继承关系来表达某个标签类型是从另一个类别派生而来的）：

```c++
namespace std {
    struct input_iterator_tag {};
    struct output_iterator_tag {};
    struct forward_iterator_tag : public input_iterator_tag {};
    struct bidirectional_iterator_tag : public forward_iterator_tag {};
    struct random_access_iterator_tag : public bidirectional_iterator_tag {};
}
```

有效利用标签调度的关键在于标签之间的关系。

当算法使用的属性有一个自然的层次结构和一组提供这些标签的现有特征时，标签调度可以很好地工作。当算法特化依赖于特定类型属性时，就不那么方便了，例如类型 `T` 是否有一个普通的拷贝赋值运算符。为此，我们需要一种更强大的技术。

## 启用 / 禁用函数模板

算法特化涉及提供基于模板实参属性选择的不同函数模板。遗憾的是，函数模板的局部排序和重载解析都不足以表示更高级形式的算法特化。

C++ 标准库提供的一个 helper 类是 `std::enable_if`，本节讨论如何通过引入相应的别名模板来实现这个 helper 类。

```c++
// typeoverlaod/enableif.hpp
template <bool, typename T = void>
struct EnableIfT {};

template <typename T>
struct EnableIfT<true, T> {
    using Type = T;
};

template <bool Cond, typename T = void>
using EnableIf = typename EnableIfT<Cond, T>::Type;
```

由于 `EnableIf` 扩展到一个类型，因此实现为一个别名模板。我们希望使用偏特化来实现它，但是别名模板不能偏特化。幸运的是，我们可以引入一个 helper 类模板 `EnableIfT`，它完成了我们需要的实际工作，如果只需从 helper 模板中选择结果类型，就可以启用别名模板。当条件为 `true` 时，`EnableIfT<...>::Type`（因此 `EnableIf<...>`）只计算第 2 个模板实参 `T`。当条件为 `false` 时，`EnableIf` 不会生成有效的类型，因为 `EnableIfT` 的主类模板没有名为 `Type` 的成员。通常，这会是一个错误，但在 SFINAE 上下文（如函数模板的返回类型）中，它会导致模板实参演绎失败，从而将函数模板从考虑范围中删除。

我们现在已经确定了：如何显式地“激活”应用于类型的特化较好的模板。但是，这还不够：我们还必须“禁用”特化不理想的模板，因为编译器无法对这两个模板进行“排序”，如果两个模板都适用，则会报告一个二义性错误。幸运的是，实现这一点并不难：我们可以在特化程度不好的模板上使用相同的 `EnableIf` 模式，并否定条件表达式。

### 提供多种特化

前面的模式一般适用于需要两个以上替代实现的情况：我们为每个替代实现配置 `EnableIf` 构造，这些构造的条件对于一组特定的具体模板实参是互斥的。这些条件通常会利用可以通过特征表达的各种属性。

通过使每个函数模板的 `EnableIf` 条件与其他每个函数模板的 `EnableIf` 条件互斥，我们可以确保，对于给定的实参集，至多有一个函数模板将成功地进行模板实参演绎。

使用 `EnableIf` 进行算法特化的一个缺陷：每次引入新的算法变体时，都需要重新访问所有算法变体的条件，以确保所有变体都是互斥的。

标签调度和 `EnableIf` 这两种技术在不同的上下文中都很有用：一般来说，标签调度支持基于层次标签的简单调度，而 `EnableIf` 支持基于类型特征确定的任意属性集的更高级调度。

### `EnableIf` 去往何处

`EnableIf` 通常用于函数模板的返回类型。但是，这种方法不适用于构造函数模板或转换函数模板，因为它们都没有指定的返回类型。此外，`EnableIf` 的用法会使返回类型难以阅读。在这种情况下，我们可以将 `EnableIf` 嵌入默认模板实参中。

然而，这里有一个问题。如果我们尝试添加另一个重载，程序将出现错误。

问题是除了默认模板实参外，这两个构造函数模板是相同的，但是在确定两个模板是否相同时，不考虑默认模板实参。

我们可以通过添加另一个默认模板参数来缓解此问题，因此这两个构造函数模板的模板参数个数不同。

### 编译器 `if`

在许多情况下，C++17 的 `constexpr` 特性减弱了 `EnableIf` 的必要性。使用 `constexpr if` 更为清楚。

只有当泛型组件中的差异可以完全在函数模板的主体中表示时，才可能使用 `constexpr if`。我们仍然需要 `EnableIf` 的情况如下：

- 涉及不同的“接口”
- 需要不同的类定义
- 某些模板实参列表，不应存在有效的实例化

## 类特化

类模板偏特化可以用来为特定的模板实参提供类模板的替代的特化实现，就像我们为函数模板使用重载一样。而且，和重载函数模板一样，根据模板实参的属性来区分偏特化也是有意义的。

### 启用 / 禁用类模板

启用 / 禁用类模板的不同实现的方法是，使用类模板的启用 / 禁用偏特化。要将 `EnableIf` 与类模板偏特化一起使用。

与重载函数模板不同，我们不需要禁用基本模板上的任何条件，因为任何偏特化都优先于基本模板。

### 类模板的标签调度

标签调度也可用于在类模板偏特化之间进行选择。

## 实例化安全模板

`EnableIf` 技术的本质是：当且仅当模板实参满足某些特定条件时，才启用特定模板或偏特化。

如果我们将这个技术的作用发挥到极致，将模板对其模板实参执行的每个操作编码为 `EnableIf` 条件的一部分，会怎么样？这种模板的实例化始终是成功的，因为不提供所需操作的模板实参将导致演绎失败（通过 `EnableIf`），而不是允许实例化继续。我们将此类模板称为“实例化安全模板”。

在某些上下文中，可以隐式地使用到 `bool` 的显式转换，包括在控制流语句（如 `if`、`while`、`for` 和 `do`）的布尔条件中内置的 `!`、`&&` 和 `||` 等运算符，以及三元运算符（`?:`）。在这些上下文中，这些值被称为上下文转换的 `bool`。

然而，我们坚持对 `bool` 进行通用的、隐式转换的结果是实例化安全模板受到过度约束。也就是说，它的指定需求（在 `EnableIf` 中）比它的实际需求（模板需要正确实例化的内容）强。

我们需要一个特征来确定：类型 `T` 是否可以在上下文中转换为 `bool`。控制流语句对定义这个特征并没有帮助，因为这些语句和逻辑操作都不能出现在 SFINAE 上下文中，对于任意类型，逻辑操作都可能被重载。幸运的是，三元运算符（`?:`）是一个表达式，不可重载，因此可以利用它来测试类型在上下文中是否可转换为 `bool`。

描述非常规模板的需求的具体方法是将各种需求检查组合成描述某些类型的特征，并在 `EnableIf` 中组合这些特征。这样做既有更好的重载行为，又可以消除编译器在嵌套模板实例化中深层捕捉错误时易产生的“新”错误。另外，上述操作提供的错误消息往往很难明确特定操作失败的原因。

## 在标准库中

C++ 标准库为输入、输出、转发、双向、随机访问的迭代器标签提供相应的迭代器类别标签，我们在本书的示例中就使用了这些标签。这些迭代器类别标签是标准迭代器特征（`std::iterator_traits`）和迭代器要求的一部分，因此它们可以安全地给调度目的标注标签。

C++ 标准库中的 `std::enable_if` 类模板和这里提到的 `EnableIf` 类模板非常相似。唯一的区别是类型名称不同：前者使用的是 `type`，而后者使用的是 `Type`。

算法特化在 C++ 标准库中的许多地方使用。大多数标准库实现都倾向于使用标签调度（tag dispatching），不过最近，有些标准库使用 `std::enable_if` 来实现算法特化。还有，许多 C++ 标准库也在实现内部使用这些技术，来实现各种标准算法的算法特化。这些算法特化不是由 C++ 标准以同样的方式强制实现的，实现者为了提高效率而选择提供它们。

C++ 标准库强烈建议在实际需求中使用 `std::enable_if<>` 或类似的基于 SFINAE 的技术。
