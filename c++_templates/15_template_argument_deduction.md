# 模板实参推导

## 推导的过程

针对函数调用，基本推导过程会对“调用实参的类型”和“函数模板的相应参数化类型（即 `T`）”进行比较，然后针对要被推导的一个或多个参数，分别推导出正确的替换实参。需要记住：每个实参-参数对的分析都是相互独立的。因此，如果最后得出的结论不同，那么推导过程将会失败。

即使所有被推导的模板参数都可以一致性确定（即不发生矛盾），推导过程也可能会失败。这种情况就是：在函数声明中，进行替换的模板实参可能会导致无效的构造。

进行描述的概念包括根据匹配类型 `A`（来自实参的类型）和参数化类型 `P`（来自参数的声明）。如果被声明的参数是一个引用声明（即 `T&`），那么 `P` 是所引用的类型（即 `T`），而 `A` 仍然是实参的类型。否则，`P` 是所声明的参数类型，而 `A` 则是通过将数组或函数类型退化为相应的指针类型而从实参类型获得的，还会忽略高层次的 `const` 和 `volatile` 限定符。

## 推导的上下文

复杂的类型声明都是由更基本的构造〔比如指针、引用、数组和函数声明子（declarator）、成员声明子、模板 id等〕组建的。匹配过程从最顶层的构造开始，然后不断递归各个组成元素（即子构造）。可以认为：大多数的类型声明构造都可以使用这种方式进行匹配，这些构造也被称为推导的上下文（deduced context）。然而，某些构造就不能作为推导的上下文。如下。

- 受限的类型名。比如，类型名 `Q<T>::X` 不能被用来作为推导模板的参数 `T`。
- 除了非类型参数之外，模板参数还包含其他成分的非类型表达式。比如，类似 `S<I+1>` 这样的类型名不能用于推导 `I`。另外，`T` 也不能通过匹配 `int(&)` 等类型的参数来推导。

具有这些约束是很正常的，因为通常而言，尽管有时候会很容易忽略受限类型的名称，但推导过程并不是唯一的（甚至不一定是有限的）。并且，一个不能推导的上下文不会自动表明：所对应的程序就是错误的，甚至正在分析的参数也不能参与类型推导。

## 特殊的推导情况

存在两种特殊的推导情况，其中用于推导的实参-参数对（`A` 和 `P`）并不是来自函数调用的实参和函数模板的参数。第 1 种情况出现在取函数模板的地址的时候。

类似地，函数类型也可用于 `P` 和 `A`，适用于如下一些特殊的情况。

- 确定重载函数模板之间的部分顺序
- 将显式特化与函数模板相匹配
- 将显式实例化与模板相匹配
- 将友元函数模板特化与模板相匹配
- 将 placement operator delete（或 placement operator delete[]）与相应的 placement operator new（或 placement operator new[]）的模板相匹配。

转换函数模板还存在第 2 种特殊情况。

## 初始化列表

当函数调用的参数是一个初始化列表时，该参数没有特定的类型，因为通常不会从给定的实参-参数对（`A` 和 `P`）进行推导（因为 `A` 并不存在）。

但是，参数类型 `P` 在移除引用以及顶层 `const` 和 `volatile` 限定符后，对于某些具有可推导模式的类型 P′，其等价于 `std::initializer_list<P′>`，通过将 P′ 与初始化列表中每个元素的类型进行比较，只有当所有元素具有相同的类型时，才算推导成功。

同样地，如果参数类型 `P` 是数组类型的指涉，这个数组里的元素类型为 P′，并且某些 P′ 类型具有可推导的模式，那么通过比较 P′ 与初始化列表中的每个元素的类型进行推导，仅当所有元素具有相同的类型时，才算推导成功。此外，如果绑定具有可推导模式（即只是命名一个非类型模板参数），那么该绑定将被推导为列表中元素的数量。

## 参数包

当对变参模板执行模板实参推导时，相同的参数包（P）与多个参数（A）匹配，并且每次匹配都会为 P 中的任何模板参数包产生额外的值。

因为函数参数包的推导使用扩展模式进行比较，所以模式的复杂度可以是任意的，并且可以从每个实参类型中确定多个模板参数和参数包的值。

参数包的推导不限于函数参数包，其中实参-参数对来自调用的实参。实际上，只要包扩展位于函数参数列表或模板实参列表的末尾，就可以使用这个推论进行推导。

### 字面量运算符模板

字面量运算符模板以一种独特的方式确定其参数。

## 右值引用

### 引用折叠规则

不允许程序员直接声明“引用的引用”。但是，通过替换模板参数，类型别名或 `decltype` 结构体的方式来组合类型，这是允许的。

通过这种组合产生类型的规则称为引用折叠（reference collapsing）规则。首先，任何应用于内部引用之上的 `const` 或 `volatile` 限定符将会被简单地丢弃（即只有内部引用之下的限定符才会被保留）。然后根据下列引用折叠规则将两个引用简化为单个引用。总体来说，就是如果其中一个引用是左值引用，那么结果的类型也是左值引用；否则，结果的类型就是右值引用。

### 转发引用

当函数形参是转发引用（forwarding reference，对该函数模板的模板参数的右值引用）时，模板实参推导采用的是一种特殊的方式。因为在这种情况下，模板参数推导不仅要考虑函数调用参数的类型，还要考虑该参数是左值还是右值。在实参是左值的情况下，由模板实参推导确定的类型是对实参类型的左值引用，引用折叠规则则可以确保被替换的参数将会是左值引用。否则，模板参数推导出的类型仅仅只是实参类型（而不是引用类型），而被替换的参数则是该类型的右值引用。

### 完美转发

完美转发与变参模板结合的很好，允许函数模板接受任意数量的函数调用参数，并将它们逐个转发到另一个函数。

实际上，完美转发并不是“完美”的，因为它并没有捕获表达式中所有有趣的属性。比如，它并不区分左值是否是位域左值，也不捕获表达式具有的特定的常量值。而后者通常会导致问题，特别是在处理空指针常量时。空指针常量是一个整数类型的值，其计算结果为常量值 0。

### 推导的意外情况

右值引用的特殊推导规则的结果对完美转发非常有用。但是，可能会让人感到意外的是，函数模板通常会泛化函数签名中的类型，但是不会影响它准许的实参类型（左值或右值）。

只有当函数参数是使用“模板-参数 `&&` ”（template-parameter `&&`）的形式编写的（作为函数模板的一部分），并且命名的模板参数是由该函数模板声明的时，这种推导行为才适用。

尽管这个模板推导规则的行为令人惊讶，但实际上，这种行为导致问题的情况并不常见。当它发生时，可以结合使用 SFINAE 和 类型特征来将模板限制为右值。如 `std::enable_if<>`。

## SFINAE

SFINAE（替换失败不是错误）原则是模板参数推导非常重要的一个方面，它可以防止不相关的函数模板在重载解析过程中产生错误。

在任何其他的上下文中，尝试访问不存在的嵌套类型将会导致即时编译期错误。在模板实参的替换过程中，SFINAE 将这些错误转化为推导失败，并将函数模板从候选匹配列表中删除。

### 即时上下文

SFINAE 用于防止试图形成无效的类型或表达式，包括函数模板替换的即时上下文（immediate context），这是由于二义性或违反访问控制而导致的错误。通过定义不在上下文中的内容，可以更容易地定义函数模板替换的即时上下文。具体来说，在用于推导的函数模板的替换期间，实例化过程中发生的任何事情都不属于该函数模板所替换的即时上下文。具体包括如下事情：

- 类模板的定义（即它的主体和基类列表）
- 函数模板的定义（主体，如果是构造函数，那么是它的构造函数初始化器）
- 变量模板的初始化式
- 默认参数
- 默认的成员初始化器
- 异常规范

替换过程所触发的特殊成员函数的任何隐式定义都不属于替换的即时上下文，而其他一切则都属于该即时上下文。

因此，如果替换函数模板声明的模板参数需要实例化类模板的主体，因为该类的一个成员正在被指涉，那么实例化过程中的错误并不会出现在函数模板替换的即时上下文中，所以这是一个真正的错误（即使另一个函数模板匹配时没有错误）。

SFINAE 最初旨在消除由于函数模板重载的意外匹配而导致的错误。但是，检测无效表达式或类型的功能支持出色的编译期技术，它可以用于确定特定语法是否有效。

## 推导的限制

### 可行的实参转换

通常，模板实参推导试图找到函数模板参数的替换，使得参数化类型 P 与类型 A 相同。然而，如果这是不可能的，那么当 P 在可推导的上下文中包含一个模板参数时，下面的这些差异是可以容忍的。

- 如果原始参数是使用引用声明符声明的，那么替换的 P 类型可能比 A 类型更符合 `const` \ `volatile` 限定。
- 如果 A 类型是指针或指涉成员的指针类型，那么可以通过限定转换〔换句话说，添加 `const` 和（或）`volatile` 限定符的转换〕转换为替换的 P 类型。
- 除非对转换运算符模板进行推导，否则替换的 P 类型可以是 A 类型的基类类型，或是指涉类类型的基类类型的指针，而 A 是一个指针类型。

如果 P 在推导的上下文中不包含模板参数，那么所有的隐式转换都是允许的。

只有在不可能进行精确匹配的情况下，才考虑降低匹配的要求。尽管如此，只有在找到了一个替换方式，使得 A 类型与即将被替换的 P 类型匹配时，才算推导成功。

注意，这些规则的作用域非常有限，并且忽略了（比如）可以应用于函数参数，使得调用成功的各种转换。

当两个参数具有从公共基类派生的不同类类型时，编译器在推导过程中，不会将该公共基类作为推导类型的候选类。

### 类模板实参

在 C++17 之前，模板实参推导只适用于函数模板和成员函数模板。特别地，类模板的实参并不是从其构造函数之一所调用的实参推导出来的。

这个限制在 C++17 被解除了。

### 默认调用实参

默认的函数调用实参可以在函数模板中指定，就像在普通函数一样。

默认函数调用实参可以依赖于模板形参。这样一个依赖的默认实参只有在没有提供显式实参的情况下才会被实例化。

即使默认调用实参不是依赖的，它也不能用于推导模板实参。

### 异常规范

与默认调用实参一样，异常规范只在需要时实例化。这意味着它们不参与模板实参的推导。

同样的规则也适用于列出了潜在异常类型的异常规范。

但是，这些“动态”异常规范从 C++11 开始已经被弃用，并在 C++17 中被移除。

## 显式函数模板参数

当无法推导出函数模板实参时，可以在函数模板名称之后显示地指定它。对于可推导的模板参数也可以这样做。

一旦显式地指定了模板实参，它对应的参数就不再需要进行推导。但是，这反过来又允许对函数的调用参数进行转换，而这在推导调用中是不可能的。

可以显式地指定一些模板实参，同时推导其他参数。但是，显式指定的实参总是从左到右与模板参数进行匹配。所以，应该首先指定不能推导出的参数（或可能显式指定的参数）。

指定一个空的模板实参列表是有用的，这样可以确保所选的参数是一个模板示例，同时仍然使用推导来确定模板实参。

当使用普通标识符命名友元函数时，该函数只在最近的封闭范围内进行查找，如果在该范围内没有找到，就会在该范围内声明一个新的实体（但除非通过 ADL，否则该实体仍是“不可见的”）。但是，当命名的友元标识符后面跟着模板实参列表时，模板必须通过普通查找才可见，并且普通查找将向上移动可能需要的任意数量的作用域。

使用 SFINAE 原则替换显式指定的模板实参：如果替换导致该替换的直接上下文中出现错误，函数模板将会被丢弃，但其他模板可能仍然会替换成功。

变参函数模板也可以与显式模板实参一起使用。一个实参包可以部分通过显式指定，部分通过推导得出。

## 基于初始化器和表达式的推导

### `auto` 类型的推导

`auto` 类型说明符可以用在很多地方（主要是命名空间作用域和局部作用域），以便从变量的初始化器中推导出变量的类型。在这种情况下，`auto` 称为占位符类型（placeholder type）。

`auto` 的推导与模板实参推导具有相同的机制。

除了引用之外，还可以结合 `auto` 类型说明符来创建 `const` 变量、指针、成员指针等，但 `auto` 必须是声明中的“主要”类型说明符，它不能嵌套在模板参数或类型说明符后面的部分声明符中。

1. 推导返回的类型

C++14 添加了另一种可推导的 `auto` 占位符类型：函数返回类型。

默认情况下，lambda 表达式同样存在相同的机制：如果没有显式指定返回类型，那么 lambda 表达式的返回类型将被推导为 `auto`。

函数可以与它们的定义分开声明。对于推导出返回类型的函数来说，也是如此。但是在这种情况下，前置声明的用途非常有限，因为定义必须在使用函数的任何地方都可见。提供带有“已解析”返回类型的前置声明是无效的。

在大多数情况下，由于风格的偏好，在前置声明的函数中使用推导返回类型的功能，只适用于将成员函数的定义转移到类定义之外的情况。

2. 可推导的非类型参数

在 C++17 之前，必须使用特定的类型来声明非类型模板实参。但是，该类型可以是模板参数的类型。

对于具有这种可推导的非类型参数的模板定义，通常还需要表示相应实参的实际类型。使用 `decltype` 构造可以很容易做到这一点。

`auto` 非类型模板参数也可以用于参数化类成员的模板。

该特性也可用于非类型参数包。

### 使用 `decltype` 表示一个表达式的类型

`decltype` 关键字允许程序员表示一个表达式或声明的精确类型。

- 如果 `e` 是一个实体（如变量、函数、枚举常量或数据成员）的名称或类成员访问的名称，`decltype(e)` 将生成该实体或指定的类成员声明的类型（declared type）。因此，`decltype` 可以用来检查变量的类型。
- 否则，如果 `e` 是任何其他表达式，那么 `decltype(e)` 会生成一个反映该表达式的类型和值类别的类型，示例如下。

如果 `e` 是 `T` 类型的左值（lvalue），那么 `decltype(e)` 将会生成 `T&`。
如果 `e` 是 `T` 类型的消亡值（xvalue），那么 `decltype(e)` 将会生成 `T&&`。
如果 `e` 是 `T` 类型的左值（prvalue），那么 `decltype(e)` 将会生成 `T`。

### `decltype(auto)`

C++14 增加了一个结合了 `auto` 和 `decltype` 的特性：`decltype(auto)`。和 `auto` 类型说明符一样，它是一个占位符类型，变量、返回类型或模板实参的类型均由相关表达式（初始化器、返回值或模板实参）的类型来确定。但是，与 `auto` 不同的是，它使用模板实参推导规则来确定感兴趣的类型，实际类型则通过直接对表达式应用 `decltype` 构造来确定。

与 `auto` 不同，`decltype(auto)` 不允许说明符或声明符运算符修改其类型。

从 C++17 开始，`decltype(auto)` 也可以用于推导非类型参数。

### `auto` 推导的特殊情况

对于原本简单的 `auto` 推导规则。也有一些特殊情况。一种情况是当变量的初始化器是初始化列表式时，函数调用的相应推导将会失败，因为不能从初始化列表的实参中推导出模板类型参数。

拷贝初始化（即使用 `=` 初始化）一个带有初始化列表的 `auto` 变量，因此根据更具体的参数定义：

```c++
auto primes = { 2, 3, 5, 7 };   // primes 是 std::initializer_list<int>
deduceT(primes);                // T 推导为 std::initializer_list<int>
```

在 C++17 之前，`auto` 变量的相应直接初始化（即没有 `=`）也是以这种方式处理的，但 C++17 对此进行了更改，以便更好地匹配大多数程序员所期望的行为：

```c++
auto oops { 0, 8, 15 };     // C++17 中是错误的
auto val { 2 };             // 正确，val 具有 int 类型（C++17 中）
```

在 C++17 之前，两个初始化都是有效的，并且 `oops` 和 `val` 的初始化类型都为 `initializer_list<int>`。

有趣的是，对于具有推导占位符类型的函数，返回使用花括号的初始化列表则是无效的：

```c++
auto subtleError() {
    return { 1, 2, 3 }; // 错误
}
```

这是因为函数作用域中的初始化列表是一个指向底层的数组对象（具有列表中指定的元素值），该对象在函数返回时过期。因此，这实际上是允许构造悬空的引用。

在多个变量声明共享同一个 `auto` 时，每个声明都可以独立进行推导。换句话说，首先有一个创建的模板类型参数 `T1`，然后有一个创建的模板类型参数 `T2`。只有当两个推导都成功，并且 `T1` 和 `T2` 的推导类型都相同时，声明的语法才是正确的。

对于推导的返回类型的占位符，还可能出现类似的特殊情况。在这种情况下，每个返回语句都是独立推导的，但是如果推导的类型不同，则程序无效。如果返回的表达式递归地调用该函数，就不能进行推导，除非之前的推导已经确定了返回类型，否则程序无效。

推导的返回类型有另一种特殊情况，即在推导的变量类型或推导的非类型参数类型中没有对应的类型：

```c++
auto f1() { }           // 正确：返回类型为 void
auto f2() { return; }   // 正确：返回类型为 void
```

`f1` 和 `f2` 都是有效的，并且返回类型为 `void`。但是，如果返回类型模式不能匹配 `void`，那么这样的代码就是无效的：

```c++
auto* f3() {}           // 错误：auto* 不能推导为 void
```

任何使用推导的返回类型的函数模板都需要立即实例化，以确定其返回类型。然而，当涉及 SFINAE 时，这会产生一个令人惊讶的结果。重要的是记住，推导的返回类型（deduced return type）并不只是复杂的显式返回类型的简写，应该谨慎使用它们（即要理解不应在依赖于 SFINAE 属性的其他函数模板的签名中调用它们）。

### 结构化绑定

C++17 添加了一个称为结构化绑定（structured binding）的新特性。

从语法上讲，结构化绑定必须总是具有 `auto` 类型，可选择使用 `const`、`volatile` 限定符、`&`、`&&` 声明符运算符进行扩展（但不是使用 `*` 指针声明符或其他声明符进行构造）。它后面是一个包含至少一个标识符的括号列表（让人想起 lambda 表达式的“捕获”列表）。接着必须有一个初始化器。

可以用于初始化结构化绑定的实体有 3 种，分别对应 3 种情况。

第 1 种情况是简单类类型。对于这种情况，所有的非静态数据成员都必须是公共的（要么全部直接在类本身中，要么都在同一个、明确的公共基类中，并且将不涉及匿名联合）。在这种情况下，方括号中的标识符的数量必须等于成员的数量，并且在结构化绑定的范围内，使用这些标识符中的一个相当于使用 `e` 所表示的对象的相应成员〔具有所有关联的属性，比如，如果对应的成员是位域（bit field），则不能获取它的地址〕。

第 2 种情况对应于数组。方括号中的初始化器只是未命名数组变量中相应元素的简写。数组中元素的数量必须等于方括号中的初始化器的数量。在执行数组的结构化绑定时是不会发生指涉数组退化为指针的。

第 3 种情况允许类似 `std::tuple` 的类使用 `get<>()`，并通过基于模板的协议分解其中的元素。只需要包含 `<utility>`，就可以使用两个类似于元组的访问帮助函数 `std::tuple_size<>` 和 `std::tuple_element<>`。其对方括号内的初始化器进行了实际初始化，并且绑定的是实际的引用变量，它们不仅仅是另一个表达式的别名（这与使用简单类类型和数组的前两种情况不同）。这很有趣，因为引用初始化还可能会出错。

### 泛型 lambda 表达式

C++14 引入了“泛型” lambda 表达式的概念，其中一个或多个参数的类型可以使用 `auto` 进行推导。

lambda 表达式参数中的 `auto` 的处理方式与带有初始化器的变量的类型的 `auto` 处理方式相似：它将会被新创建的模板类型参数 `T` 替换。但是，与变量的情况不同的是，推导不会立即执行，因为在创建 lambda 表达式时，该参数还是未知的。
