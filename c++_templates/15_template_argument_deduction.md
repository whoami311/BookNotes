# 模板实参推导

## 推导的过程

针对函数调用，基本推导过程会对“调用实参的类型”和“函数模板的相应参数化类型（即 `T`）”进行比较，然后针对要被推导的一个或多个参数，分别推导出正确的替换实参。需要记住：每个实参-参数对的分析都是相互独立的。因此，如果最后得出的结论不同，那么推导过程将会失败。

即使所有被推导的模板参数都可以一致性确定（即不发生矛盾），推导过程也可能会失败。这种情况就是：在函数声明中，进行替换的模板实参可能会导致无效的构造。

进行描述的概念包括根据匹配类型 `A`（来自实参的类型）和参数化类型 `P`（来自参数的声明）。如果被声明的参数是一个引用声明（即 `T&`），那么 `P` 是所引用的类型（即 `T`），而 `A` 仍然是实参的类型。否则，`P` 是所声明的参数类型，而 `A` 则是通过将数组或函数类型退化为相应的指针类型而从实参类型获得的，还会忽略高层次的 `const` 和 `volatile` 限定符。

## 推导的上下文

复杂的类型声明都是由更基本的构造〔比如指针、引用、数组和函数声明子（declarator）、成员声明子、模板 id等〕组建的。匹配过程从最顶层的构造开始，然后不断递归各个组成元素（即子构造）。可以认为：大多数的类型声明构造都可以使用这种方式进行匹配，这些构造也被称为推导的上下文（deduced context）。然而，某些构造就不能作为推导的上下文。如下。

- 受限的类型名。比如，类型名 `Q<T>::X` 不能被用来作为推导模板的参数 `T`。
- 除了非类型参数之外，模板参数还包含其他成分的非类型表达式。比如，类似 `S<I+1>` 这样的类型名不能用于推导 `I`。另外，`T` 也不能通过匹配 `int(&)` 等类型的参数来推导。

具有这些约束是很正常的，因为通常而言，尽管有时候会很容易忽略受限类型的名称，但推导过程并不是唯一的（甚至不一定是有限的）。并且，一个不能推导的上下文不会自动表明：所对应的程序就是错误的，甚至正在分析的参数也不能参与类型推导。

## 特殊的推导情况

存在两种特殊的推导情况，其中用于推导的实参-参数对（`A` 和 `P`）并不是来自函数调用的实参和函数模板的参数。第 1 种情况出现在取函数模板的地址的时候。

类似地，函数类型也可用于 `P` 和 `A`，适用于如下一些特殊的情况。

- 确定重载函数模板之间的部分顺序
- 将显式特化与函数模板相匹配
- 将显式实例化与模板相匹配
- 将友元函数模板特化与模板相匹配
- 将 placement operator delete（或 placement operator delete[]）与相应的 placement operator new（或 placement operator new[]）的模板相匹配。

转换函数模板还存在第 2 种特殊情况。

## 初始化列表

当函数调用的参数是一个初始化列表时，该参数没有特定的类型，因为通常不会从给定的实参-参数对（`A` 和 `P`）进行推导（因为 `A` 并不存在）。

但是，参数类型 `P` 在移除引用以及顶层 `const` 和 `volatile` 限定符后，对于某些具有可推导模式的类型 P′，其等价于 `std::initializer_list<P′>`，通过将 P′ 与初始化列表中每个元素的类型进行比较，只有当所有元素具有相同的类型时，才算推导成功。

同样地，如果参数类型 `P` 是数组类型的指涉，这个数组里的元素类型为 P′，并且某些 P′ 类型具有可推导的模式，那么通过比较 P′ 与初始化列表中的每个元素的类型进行推导，仅当所有元素具有相同的类型时，才算推导成功。此外，如果绑定具有可推导模式（即只是命名一个非类型模板参数），那么该绑定将被推导为列表中元素的数量。

## 参数包

当对变参模板执行模板实参推导时，相同的参数包（P）与多个参数（A）匹配，并且每次匹配都会为 P 中的任何模板参数包产生额外的值。

因为函数参数包的推导使用扩展模式进行比较，所以模式的复杂度可以是任意的，并且可以从每个实参类型中确定多个模板参数和参数包的值。

参数包的推导不限于函数参数包，其中实参-参数对来自调用的实参。实际上，只要包扩展位于函数参数列表或模板实参列表的末尾，就可以使用这个推论进行推导。

### 字面量运算符模板

字面量运算符模板以一种独特的方式确定其参数。

## 右值引用

### 引用折叠规则

不允许程序员直接声明“引用的引用”。但是，通过替换模板参数，类型别名或 `decltype` 结构体的方式来组合类型，这是允许的。

通过这种组合产生类型的规则称为引用折叠（reference collapsing）规则。首先，任何应用于内部引用之上的 `const` 或 `volatile` 限定符将会被简单地丢弃（即只有内部引用之下的限定符才会被保留）。然后根据下列引用折叠规则将两个引用简化为单个引用。总体来说，就是如果其中一个引用是左值引用，那么结果的类型也是左值引用；否则，结果的类型就是右值引用。

### 转发引用

当函数形参是转发引用（forwarding reference，对该函数模板的模板参数的右值引用）时，模板实参推导采用的是一种特殊的方式。因为在这种情况下，模板参数推导不仅要考虑函数调用参数的类型，还要考虑该参数是左值还是右值。在实参是左值的情况下，由模板实参推导确定的类型是对实参类型的左值引用，引用折叠规则则可以确保被替换的参数将会是左值引用。否则，模板参数推导出的类型仅仅只是实参类型（而不是引用类型），而被替换的参数则是该类型的右值引用。

### 完美转发

完美转发与变参模板结合的很好，允许函数模板接受任意数量的函数调用参数，并将它们逐个转发到另一个函数。

实际上，完美转发并不是“完美”的，因为它并没有捕获表达式中所有有趣的属性。比如，它并不区分左值是否是位域左值，也不捕获表达式具有的特定的常量值。而后者通常会导致问题，特别是在处理空指针常量时。空指针常量是一个整数类型的值，其计算结果为常量值 0。

### 推导的意外情况

右值引用的特殊推导规则的结果对完美转发非常有用。但是，可能会让人感到意外的是，函数模板通常会泛化函数签名中的类型，但是不会影响它准许的实参类型（左值或右值）。

只有当函数参数是使用“模板-参数 `&&` ”（template-parameter `&&`）的形式编写的（作为函数模板的一部分），并且命名的模板参数是由该函数模板声明的时，这种推导行为才适用。

尽管这个模板推导规则的行为令人惊讶，但实际上，这种行为导致问题的情况并不常见。当它发生时，可以结合使用 SFINAE 和 类型特征来将模板限制为右值。如 `std::enable_if<>`。

## SFINAE

SFINAE（替换失败不是错误）原则是模板参数推导非常重要的一个方面，它可以防止不相关的函数模板在重载解析过程中产生错误。

在任何其他的上下文中，尝试访问不存在的嵌套类型将会导致即时编译期错误。在模板实参的替换过程中，SFINAE 将这些错误转化为推导失败，并将函数模板从候选匹配列表中删除。

### 即时上下文

SFINAE 用于防止试图形成无效的类型或表达式，包括函数模板替换的即时上下文（immediate context），这是由于二义性或违反访问控制而导致的错误。通过定义不在上下文中的内容，可以更容易地定义函数模板替换的即时上下文。具体来说，在用于推导的函数模板的替换期间，实例化过程中发生的任何事情都不属于该函数模板所替换的即时上下文。具体包括如下事情：

- 类模板的定义（即它的主体和基类列表）
- 函数模板的定义（主体，如果是构造函数，那么是它的构造函数初始化器）
- 变量模板的初始化式
- 默认参数
- 默认的成员初始化器
- 异常规范

替换过程所触发的特殊成员函数的任何隐式定义都不属于替换的即时上下文，而其他一切则都属于该即时上下文。

因此，如果替换函数模板声明的模板参数需要实例化类模板的主体，因为该类的一个成员正在被指涉，那么实例化过程中的错误并不会出现在函数模板替换的即时上下文中，所以这是一个真正的错误（即使另一个函数模板匹配时没有错误）。

SFINAE 最初旨在消除由于函数模板重载的意外匹配而导致的错误。但是，检测无效表达式或类型的功能支持出色的编译期技术，它可以用于确定特定语法是否有效。

## 推导的限制

### 可行的实参转换

通常，模板实参推导试图找到函数模板参数的替换，使得参数化类型 P 与类型 A 相同。然而，如果这是不可能的，那么当 P 在可推导的上下文中包含一个模板参数时，下面的这些差异是可以容忍的。

- 如果原始参数是使用引用声明符声明的，那么替换的 P 类型可能比 A 类型更符合 `const` \ `volatile` 限定。
- 如果 A 类型是指针或指涉成员的指针类型，那么可以通过限定转换〔换句话说，添加 `const` 和（或）`volatile` 限定符的转换〕转换为替换的 P 类型。
- 除非对转换运算符模板进行推导，否则替换的 P 类型可以是 A 类型的基类类型，或是指涉类类型的基类类型的指针，而 A 是一个指针类型。

如果 P 在推导的上下文中不包含模板参数，那么所有的隐式转换都是允许的。

只有在不可能进行精确匹配的情况下，才考虑降低匹配的要求。尽管如此，只有在找到了一个替换方式，使得 A 类型与即将被替换的 P 类型匹配时，才算推导成功。

注意，这些规则的作用域非常有限，并且忽略了（比如）可以应用于函数参数，使得调用成功的各种转换。

当两个参数具有从公共基类派生的不同类类型时，编译器在推导过程中，不会将该公共基类作为推导类型的候选类。

### 类模板实参

在 C++17 之前，模板实参推导只适用于函数模板和成员函数模板。特别地，类模板的实参并不是从其构造函数之一所调用的实参推导出来的。

这个限制在 C++17 被解除了。

### 默认调用实参

默认的函数调用实参可以在函数模板中指定，就像在普通函数一样。

默认函数调用实参可以依赖于模板形参。这样一个依赖的默认实参只有在没有提供显式实参的情况下才会被实例化。

即使默认调用实参不是依赖的，它也不能用于推导模板实参。

### 异常规范

与默认调用实参一样，异常规范只在需要时实例化。这意味着它们不参与模板实参的推导。

同样的规则也适用于列出了潜在异常类型的异常规范。

但是，这些“动态”异常规范从 C++11 开始已经被弃用，并在 C++17 中被移除。

## 显式函数模板参数

当无法推导出函数模板实参时，可以在函数模板名称之后显示地指定它。对于可推导的模板参数也可以这样做。

一旦显式地指定了模板实参，它对应的参数就不再需要进行推导。但是，这反过来又允许对函数的调用参数进行转换，而这在推导调用中是不可能的。

可以显式地指定一些模板实参，同时推导其他参数。但是，显式指定的实参总是从左到右与模板参数进行匹配。所以，应该首先指定不能推导出的参数（或可能显式指定的参数）。

指定一个空的模板实参列表是有用的，这样可以确保所选的参数是一个模板示例，同时仍然使用推导来确定模板实参。

当使用普通标识符命名友元函数时，该函数只在最近的封闭范围内进行查找，如果在该范围内没有找到，就会在该范围内声明一个新的实体（但除非通过 ADL，否则该实体仍是“不可见的”）。但是，当命名的友元标识符后面跟着模板实参列表时，模板必须通过普通查找才可见，并且普通查找将向上移动可能需要的任意数量的作用域。

使用 SFINAE 原则替换显式指定的模板实参：如果替换导致该替换的直接上下文中出现错误，函数模板将会被丢弃，但其他模板可能仍然会替换成功。

变参函数模板也可以与显式模板实参一起使用。一个实参包可以部分通过显式指定，部分通过推导得出。

## 基于初始化器和表达式的推导

### `auto` 类型的推导

`auto` 类型说明符可以用在很多地方（主要是命名空间作用域和局部作用域），以便从变量的初始化器中推导出变量的类型。在这种情况下，`auto` 称为占位符类型（placeholder type）。

`auto` 的推导与模板实参推导具有相同的机制。

除了引用之外，还可以结合 `auto` 类型说明符来创建 `const` 变量、指针、成员指针等，但 `auto` 必须是声明中的“主要”类型说明符，它不能嵌套在模板参数或类型说明符后面的部分声明符中。

1. 推导返回的类型

C++14 添加了另一种可推导的 `auto` 占位符类型：函数返回类型。

默认情况下，lambda 表达式同样存在相同的机制：如果没有显式指定返回类型，那么 lambda 表达式的返回类型将被推导为 `auto`。

函数可以与它们的定义分开声明。对于推导出返回类型的函数来说，也是如此。但是在这种情况下，前置声明的用途非常有限，因为定义必须在使用函数的任何地方都可见。提供带有“已解析”返回类型的前置声明是无效的。

在大多数情况下，由于风格的偏好，在前置声明的函数中使用推导返回类型的功能，只适用于将成员函数的定义转移到类定义之外的情况。

2. 可推导的非类型参数

在 C++17 之前，必须使用特定的类型来声明非类型模板实参。但是，该类型可以是模板参数的类型。

对于具有这种可推导的非类型参数的模板定义，通常还需要表示相应实参的实际类型。使用 `decltype` 构造可以很容易做到这一点。

`auto` 非类型模板参数也可以用于参数化类成员的模板。

该特性也可用于非类型参数包。

### 使用 `decltype` 表示一个表达式的类型

`decltype` 关键字允许程序员表示一个表达式或声明的精确类型。

- 如果 `e` 是一个实体（如变量、函数、枚举常量或数据成员）的名称或类成员访问的名称，`decltype(e)` 将生成该实体或指定的类成员声明的类型（declared type）。因此，`decltype` 可以用来检查变量的类型。
- 否则，如果 `e` 是任何其他表达式，那么 `decltype(e)` 会生成一个反映该表达式的类型和值类别的类型，示例如下。

如果 `e` 是 `T` 类型的左值（lvalue），那么 `decltype(e)` 将会生成 `T&`。
如果 `e` 是 `T` 类型的消亡值（xvalue），那么 `decltype(e)` 将会生成 `T&&`。
如果 `e` 是 `T` 类型的左值（prvalue），那么 `decltype(e)` 将会生成 `T`。
