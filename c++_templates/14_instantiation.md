# 实例化

## 按需实例化

当 C++ 编译器遇到模板特化时，它会利用所给的实参替换对应的模板参数，从而产生该模板的特化。这个过程是自动进行的，并不需要用户代码（或者不需要模板定义）来引导。另外，按需实例化有时也被称为隐式实例化或者自动实例化。

按需实例化意味着：编译器通常需要访问模板和某些模板成员的完整定义（即只有声明是不够的）。

在源代码中，访问类模板的成员的需求并不总是显式可见的。比如，C++ 重载解析规则要求：如果候选函数的参数是类类型，那么该类型所对应的类就必须是可见的。

## 延迟实例化

### 部分和完全实例化

如果只是指涉类模板的一个实例，并且该实例不需要是一个完整类型，则编译器不应该对这个类模板的实例执行完全实例化。

### 实例化组件

当隐式（完全）实例化类模板时，也实例化了该类模板的每个成员的声明，但并没有实例化相应的定义（也就是说，类模板的成员被部分实例化）。但也存在一些例外的情况：首先，如果类模板包含一个匿名的联合，那么该联合定义的成员也被实例化了。有一个异常情况发生在虚函数身上。作为实例化类模板的结果，虚函数定义可能已被实例化，但也可能还没有被实例化。实际上，许多实现将会实例化（虚函数）这个定义，这是因为对于实现虚函数调用机制的内部结构，要求虚函数作为实际可链接的实体存在。

当实例化模板的时候，默认的函数调用参数需要分开考虑。准确来说，只有这个被调用的函数（或成员函数）确实使用了默认实参，才会实例化该实参。另外，如果函数使用显式的实参覆盖默认实参，就不会实例化默认实参。

类似地，除非需要，否则异常规范和默认成员初始化器不会被实例化。

通常，运算符 `->` 必须返回一个指针类型或其他适用的类类型作为结果。然而，由于某些自然的类模板的定义会触发这些类型的定义，语言规则则更加灵活。对于用户定义的运算符 `->`，如果该运算符实际上是由重载决议选择的，只需要返回另一个运算符 `->`（比如内置运算符）所适用的类型。即使在模板外部也是如此（尽管在这些上下文中，放松的行为也并不是那么有用）。

## C++ 的实例化模型

模板实例化的过程是：根据相应的模板实体，适当地替换模板参数，从而获取普通类型、函数或变量的过程。

### 两阶段查找

第一阶段发生在模板的解析阶段，第二阶段发生在模板的实例化阶段。

在第一阶段解析模板时，使用普通查找规则（ordinary lookup rule）和（如果适用）ADL 规则查找非依赖型名称。另外，非受限的依赖型名称（之所以说它们是依赖型的，是因为它们看起来就像一个带有依赖型参数的函数调用中的函数名称）也使用普通查找规则进行查找，但它查找的结果是不完整的（即查找还没有结束），直到另一个查询在第二阶段（模板实例化时），还会再次执行查找。

第二阶段发生在模板实例化时，也称此时发生实例化的位置为实例化点（point of instantiation，POI）。受限的依赖型名称就是在此阶段进行查找的（查找的目的：通过使用模板实参替换模板参数，以获取特定的实例化体）。另外，对于第一阶段的非受限的依赖型名称，也会在此阶段再次执行 ADL。

对于非受限的依赖型名称，使用初始的普通查找（虽然不是完全查找）来确定该名称是否为模板。

### 实例化点

当某些代码的构造指涉了模板的特化，需要实例化相应模板的定义时，就会在源代码中创建一个 POI。POI 指的是源代码中的一个位置，在该位置会插入替换后的模板实例。

对于指涉函数模板特化的引用，C++ 把它的 POI 定义在“包含这个引用的定义或声明之后的最近的命名空间作用域”中。

变量模板的 POI 的处理类似于函数模板的 POI 的处理。

指涉生成的类实例的 POI 定义为：紧邻在最近的命名空间作用域的声明或定义之前的位置，它包含对该实例的指涉。

一个编译单元通常会包含同一个实例的多个 POI。对于类模板实例而言，在每个编译单元中，只有第 1 个 POI 被保留，而其他的 POI（其实它们并不会被认为是真正的 POI）则会被忽略。对于函数和变量模板的实例，会保留所有的 POI。然而，在上面的任何一种情况下，ODR 都要求，保留的任何一个 POI 处所出现的实例化都是等价的，但 C++ 编译器既不需要验证这种约束，也没有要求诊断是否违反这种约束。这就允许 C++ 编译器可以选择一个非类型的 POI 来执行所需要的实例化，而不必担心另一个 POI 可能导致不同的实例化。

实际上，大多数编译器会延迟非内联函数模板的实例化，直到编译单元的末尾处，才进行真正的实例化。但一些实例化不能延迟，包括需要使用实例化来确定推导的返回类型的情况，以及在函数是 `constexpr` 的情况下，必须通过求值来产生一个常量的结果。某些编译器是在第 1 次潜在的内联即时调用时进行内联函数的实例化的。这有效地将相应模板特化的 POI 移动到编译单元的末尾，而这正是 C++ 标准所允许的可替换 POI。

### 包含模型

当遇到 POI 的时候，（编译器要求）必须以某种方式访问相应模板的定义。对于类特化而言，这意味着：在编译单元中，类模板的定义必须在它的 POI 之前就已经是可见的。对于函数模板和变量模板（以及类模板中的成员函数和静态数据成员）的 POI 而言，这也是需要的。通常，模板的定义会被放入一个头文件中，然后在需要该定义的时候，把这个头文件通过 `#include` 引入这个编译单元中，即使它们是非类型模板，也是如此。这个模板定义的源模型称为包含模型（inclusion model），它是目前 C++ 标准中支持的唯一的模板自动源模型。
