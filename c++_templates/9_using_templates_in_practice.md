# 在实践中使用模板

## 包含模型简介

在声明模板的头文件中包含模板的定义。这种组织模板的方法称为包含模型。

这种方法大大增加了包含头文件的成本。该成本不是有模板定义自身大小所造成的，事实上是由还必须包含我们模板定义所用到的头文件造成的。这是一个很实际的问题，因为它大大增加了编译器编译复杂程序所需的时间。

关于包含模型，另一个更不易察觉的问题是非内联函数模板相比内联函数和宏有一个重要区别：它们不会在调用处展开，而是当它们实例化时创建一个函数的新副本。因为这是一个自动化过程，编译器最终可能会在两个不同的文件中创建两个副本，当某些链接器发现同一函数的两个不同定义时会报错理论上这不是我们需要关心的：C++ 编译系统应该解决这个问题。实际上，大多数时候事情都很顺利，我们根本不需要处理这个问题。但是对于创建自己代码库的大型项目，问题偶尔会出现。

## 模板和 `inline`

声明内联函数是提高程序运行期性能的常用手段。`inline` 限定符是为了给编译器实现一个提示，即优先在调用处用函数体来做内联替换，而不是通常的函数调用机制。

然而编译器具体实现时可能会忽略该提示。因此，`inline` 唯一可以保证的结果是允许函数定义在程序中多次出现（因为它通常处于被多处包含的头文件中）。

和内联函数类似，也可以在多个编译单元中定义函数模板。这通常是通过将定义放在由多个 CPP 文件包含的头文件中来实现的。

但这并不意味着函数模板会默认使用内联替换。优先于通常的函数调用机制，是否以及何时在调用处进行函数模板体的内联替换，完全取决于编译器。令人惊讶的是，编译器通常比程序员更善于评估内联替换能否提升净性能。因此，关于 `inline` 的精确策略因编译器而异，甚至取决于为特定编译选择的选项。

函数模板的全局特化在这方面与普通函数表现相似：它们的定义只能出现一次，除非它们定义为 `inline`。

## 预编译头文件

编译器供应商实现通常称为预编译头文件（precompiled header，PCH）的方案。此方案不在 C++ 标准的规定范围内，具体实现方式取决于供应商的选择。

预编译头文件方案依赖于一个事实，即代码能以这样一种方式来组织：许多文件都以相同的几行代码作为开始。让我们假设要编译的每个文件都以相同的 N 行代码开头。我们可以编译这 N 行代码，并将此时编译器的完整状态保存在一个预编译头文件中。然后，对于程序中的每个文件，我们可以重新加载保存的状态并在第 N+1 行开始编译。此时值得注意的是，重新加载保存的状态是一个比实际编译前 N 行代码要快几个数量级的操作。然而，首次保存此状态的成本通常比只编译 N 行代码要高，时间成本增幅在 20% 和 200% 之间。

有效利用预编译头文件的关键是，确保（尽可能多的）文件以最大数量的公共代码行作为开头。实际上，这意味着这些文件必须以相同的 `#include` 指示符（包含相同的头文件）开始，这（如此所述）消耗了大量的编译时间。因此，注意保持包含头文件顺序的一致性，对预编译来说是非常有利的。

一些程序员认为，包含（`#include`）一些额外非必要的头文件，比创造机会利用预编译头文件来加速文件编译更好。这一决定可以极大简化包含策略管理。

管理预编译头文件的一个妙招是创建它们的层级架构，从最广泛使用和最稳定的头文件开始，到那些预期不会一直改变，因而仍然值得预编译的头文件。然而，如果头文件正处于频繁变动的开发阶段，那么为它们创建预编译头文件所花的时间会超过重用它们而节省的时间。这种方法的一个关键理念是，弱稳定层级的头文件可以通过重用为强稳定层级创建的预编译头文件来提高预编译效率。

## 后记

将源代码以头文件和 CPP 文件的形式来组织，是在实践中遵守单一定义规则（one-definition rule，ODR）的体现。

包含模型是一个实用方案，这在很大程度上是由 C++ 编译器的现有实践所决定的（现代 C++ 编译器实现也大多采用这种方案）。

## 小结

- 包含模型是一种组织模板代码的方法。
- 当在类或结构体之外的头文件中定义函数模板时，只有全局特化版本才需要使用内联。
- 为了充分利用预编译头文件的好处，要确保包含头文件的顺序相同。
- 调试模板相关代码会很有挑战性。
