# 模板基本术语

## 是“类模板”还是“模板类”

C++ 中，结构体、类和联合统称为类类型（class type）。如果没有额外的限定，纯文本类型中的“类”一词意味着包含由关键字 `class` 或者 `struct` 引入的类类型。需要注意的是，“类类型”包括联合，但是“类”却不包括。

- 术语类模板表示类是一个模板，即类模板是一族类的参数化描述。
- 术语模板类则可以：
    - 作为类模板的同义词；
    - 指代模板生成的类；
    - 指代名称为模板 id（模板名和紧跟其后的模板参数的组合，参数用 < 和 > 指定，即模板名 + <模板参数>）的类。

## 替换、实例化和特化

用具体的模板实参替换模板形参的过程称为模板实例化（template instantiation），该过程从模板中创建了常规类（regular class）、类型别名（type alias）、函数、成员函数或者变量的定义。

令人意外的是，关于通过模板参数的替换创建声明（不是定义）的过程，目前还没有任何标准或者共识。有人使用短语部分实例化（partial instantiation）或者声明实例化（instantiation of a declaration），但做法并不统一。可能一个更直观的术语是非完全实例化（incomplete instantiation），在类模板中，非完全实例化将生成一个非完整类。

通过实例化或者非完全实例化产生的实体（比如，类、函数、成员函数或者变量）通常称为特化（specialization）。

然而在 C++ 中，实例化的过程并不是产生特化的唯一方式。另外一些方式允许程序员显式地指定一个声明——该声明绑定了模板参数的特别替换。严格来说，这称为显式特化（explicit specialization，相对于实例化或者生成特化）。

带有模板参数的特化成为偏特化（partial specialization）。当讨论（显式或者偏）特化时，通用模板也称为主模板（primary template）。

## 声明和定义

声明是 C++ 中的一种构造方式，它在 C++ 的作用域中引入或重新引入一个名称。

当声明的构造细节已知，或者对于变量来说，必须要分配存储空间时，声明就变成了定义。对于类类型的定义来说，意味着必须提供花括号 {} 中包含的主体。对于函数定义来说，意味着必须提供花括号 {} 中包含的函数主体（通常情况下），或者函数必须被指定为 `=default` 或者 `=delete`。对于变量来说，初始化或者 `extern` 修饰符的缺失将使得声明变成定义。作为扩展，如果类模板或者函数模板的声明中包含主体，那么该声明被称为定义。

### 完整类型和非完整类型

类型可以是完整的或者非完整的——这是一个与声明和定义之间的区别密切相关的概念。一些语言结构需要完整类型，而其他语言结构需要非完整类型。

非完整类型包含以下情况。

- 类类型被声明却没有被定义。
- 没有指定边界的数组类型。
- 带有非完整元素类型的数组类型。
- `void`。
- 类型未定义或者枚举值未定义的枚举类型。
- `const` 和（或）`volatile` 修饰的上述任意类型。

其余类型都是完整类型。

## 单一定义规则

C++ 语言对实体的重复定义做出了约束。这些约束总的来说就是单一定义规则（ODR）。

- 在整个程序中，普通（比如非模板）非内联函数和成员函数，以及（非内联）全局变量和静态数据成员只被定义一次。
- 在每个编译单元（translation unit）中，类类型（包括结构体和联合）、模板（包括偏特化，但不包括全局特化）、内联函数和变量最多只被定义一次，并且不同编译单元间的这些定义都是相同的。

编译单元是对源文件预处理后得到的结果。也就是说，它包括由文件包含命令 `#include` 引入的头文件的内容和宏扩展后生成的内容。

## 模板实参和模板形参

模板名称和后面角括号里的模板实参的组合被称为模板 id。

区分模板形参和模板实参非常重要。简而言之，可以认为“形参是由实参初始化的”。更准确的说法如下。

- 模板形参是在模板声明或定义中出现在关键字 `template` 后面的角括号中的名称。
- 模板实参是用来代替模板形参的项。不同于模板形参，模板实参不只是“名称”。

当指出模板的模板 id 时，用模板实参替换模板形参的方式是显式的，但很多情况下，替换是隐式的（比如，用默认值替换模板形参的情况）。

一个基本原则是，任意的模板实参必须可以在编译期（compile time）确定其数量或值。该原则为模板实体的运行期成本（run-time cost）方面带来了巨大的收益。因为模板形参最终会被编译期的值（compile-time value）所替换，所以它们可以用来形成编译期表达式（compile-time expression）。

可以进一步推敲：因为模板形参是编译期的实体，所以它们可以用来创建有效的模板实参。

## 小结

- 对于那些模板的类、函数和变量，我们称之为类模板、函数模板和变量模板。
- 模板实例化是通过用模板实参替换模板形参，从而创建常规的类或函数的过程。最终产生的实体是特化的结果。
- 类型可以是完整的或非完整的。
- 根据单一定义规则（ODR），在整个程序中，普通非内联函数、成员函数、全局变量和静态数据成员只能被定义一次。
