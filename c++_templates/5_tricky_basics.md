# 基本技巧

## 关键字 `typename`

通过在 C++ 标准化过程中引入关键字 `typename` 来说明模板内部的标识符是一种类型。

通常而言，无论何时，只要依赖模板参数的名称是一种类型，就必须使用 `typename`。

## 零初始化

可以显式调用内置类型的默认构造函数，将它们初始化为 0（对于 `bool` 类型则初始化为 `false`，对于指针类型则初始化为 `nullptr`）。

```c++
template <typename T>
void foo() {
    T x{};
}
```

这种初始化方式称为值初始化，这意味着要么调用本身提供的构造函数，要么用 0 来初始化对象。即使构造函数是显式的也这么做。

在 C++11 之前，确保正确初始化的语法是：

```c++
T x = T();
```

在 C++17 之前，只有选择用于拷贝初始化的构造函数（拷贝构造函数）为非显式的时，该语法才起作用（目前依然支持）。C++17 中的强制拷贝省略解除了这一限制，因而两种语法都可用。但如果没有可用的默认构造函数，花括号初始化符可以使用 `initializer-list` 构造函数。

## 使用 `this->`

对于基类依赖于模板参数的类模板，使用名称 `x` 本身并不总是等同于 `this->x`，即使成员 `x` 是继承来的。

目前，作为经验法则，我们建议始终使用 `this->` 或 `Base<T>::` 来限定修饰在基类中声明，并在某种程度上依赖于模板参数的任何符号。

## 成员模板

1. 成员函数模板的特化

不需要也不能够声明特化；只能定义它们。由于这是在头文件中定义的全局特化，为了避免该定义可能被不同编译单元包含而引发的重复定义错误，必须将其定义成 `inline` 的形式。

2. 特殊成员函数模板

只要特殊成员函数允许拷贝或者移动对象，就可以使用成员函数模板。但请注意，构造函数模板或赋值运算符模板不会替换预定义的构造函数或赋值运算符，成员函数模板不算作拷贝或移动对象的特殊成员函数。

这种效果有利有弊。

- 尽管提供的模板版本仅用于初始化其他类型，但是构造函数模板或者赋值运算符模板有可能会比预定义的拷贝 / 移动构造函数和赋值运算符更匹配。
- “模板化”拷贝 / 移动构造函数不易，例如要能限制它们的存在。

### `.template` 构造

有时，在调用成员模板时，需要显式限定模板实参（指定模板实参类型）。在这种情况下，必须使用 `template` 关键字来确保符号 `<` 会解析为模板实参列表的起始符。

`.template` 标识符（以及类似的标识符，比如 `->template` 和 `::template`）应该只在模板内部使用，并且只有当位于它们之前的对象依赖模板参数时才使用。

## 变量模板

从 C++14 开始，变量也可以通过特定类型来参数化，称之为变量模板。

1. 数据成员的变量模板

变量模板的一个实际应用是定义代表类模板成员的变量。

2. 类型特征后缀 `_v`

自 C++17 以来，标准库使用变量模板技术来为标准库中所有的萃取所得为（布尔）值的类型特征定义快捷表达式。

## 模板的模板参数简介

通常，可以使用关键字 `class` 代替 `typename` 来声明模板参数。C++11 之前，只能用类模板的名称来代替。从 C++11 开始，我们还可以用别名模板的名称替代，但直到 C++17 才作出相应更改，以允许使用关键字 `typename` 而不是 `class` 来声明模板的模板参数。

### 模板的模板实参匹配

在 C++17 之前，模板的模板实参必须是一个模板，其参数必须与其所要替代的模板的模板参数的参数完全匹配，变参模板有些例外。

## 小结

- 如果要访问依赖模板参数的类型名称，必须使用前导关键字 `typename` 限定修饰该名称。
- 如果要访问依赖模板参数的基类成员，必须使用 `this->` 或者其类名限定修饰该成员。
- 嵌套类和成员函数也可以是模板，一种应用是可以通过内部类型转换来实现泛型操作。
- 构造函数或者赋值运算符的模板版本不会取代预定义的构造函数或赋值运算符。
- 通过使用花括号初始化符或显式调用默认构造函数，可以确保使用默认值初始化模板的变量和成员，即使它们是用内置类型实例化的。
- 可以为原始数组提供特定模板，这些模板也可以应用于字符串字面量。
- 当传递原始数组或字符串字面量时，当且仅当参数不是引用时，在实参推导过程中会发生实参类型退化（执行数组到指针的转换）。
- 可以定义变量模板（从 C++14 开始）。
- 还可以使用类模板作为模板参数，称之为模板的模板参数。
- 模板的模板实参通常必须与模板的参数完全匹配。
