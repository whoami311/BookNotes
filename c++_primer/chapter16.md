# Chapter16 模板与泛型编程

1. 默认情况下，对于一个实例化了的类模板，其成员只有在使用时才会被实例化。

2. 当编译器遇到一个实例化定义（与声明相对）时，它为其生成代码。

3. 在大系统中，在多个文件实例化相同模板的额外开销可能非常严重。我们可以通过显式实例化（explicit instantiation）来避免这种开销。

4. 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有const转换及数组或函数到指针的转换。

5. 如果一个函数参数是指向模板类型参数的右值引用（如T&&），它对应的实参的const属性和左值/右值属性将得到保持。

6. 当用一个指向模板参数类型的右值引用函数参数（T&&）时，forward会保持实参类型的所有细节。

7. 当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。

8. 对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。

9. 模板及其特例化版本应该声明在同一个头文件中，所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。
