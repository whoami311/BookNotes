# chapter15 面向对象程序设计

1. 面向对象程序设计（OOP）的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

2. 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。

3. 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

4. 在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。

5. 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

6. 每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。

7. 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。

8. 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。

9. 基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。

10. 虚函数的默认实参值由本次调用的静态类型决定。如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

11. 通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。

12. 不能继承友元关系；每个类负责控制各自成员的访问权限。

13. 派生类只能为那些它可以访问的名字提供 `using` 声明。

14. 派生类的成员将隐藏同名的基类成员。

15. 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。

16. 在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。

17. 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。

18. 当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容。
