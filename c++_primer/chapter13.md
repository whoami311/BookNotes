# chapter13 拷贝控制

1. 赋值运算符通常应该返回一个指向其左侧运算对象的引用。

2. 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。

3. 对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。

4. 本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。

5. 赋值运算符：

   - 如果一个对象赋予它自身，赋值运算符必须能正确工作。
   - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。

6. 使用拷贝和交换的赋值运算符自动就是异常安全的，且能自动处理自赋值。

7. 拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作。这种情况下，公共的工作应该放在 `private` 的工具函数中完成。

8. 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。

9. 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。

10. 不抛出异常的移动构造函数和移动赋值运算符必须标记为 `noexcept`。

11. 在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。

12. 只有当一个类没有定义自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。

13. 定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。

14. 在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用 `std::move`。

15. 区分移动和拷贝的重载函数通常有一个版本接受一个 `const T&`，而另一个版本接受一个 `T&&`。

16. 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。
