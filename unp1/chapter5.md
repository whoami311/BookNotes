# chapter5

1. 进程终止处理的部分工作是关闭所有打开的描述符。
2. 信号（signal）就是告知某个进程发生了某个事件的通知，有时也称为软件中断（software interrupt）。
3. 有两个信号不能被信号处理函数捕获，它们是SIGKILL和SIGSTOP。信号处理函数由信号值这个单一的整数参数来调用，且没有返回值，其函数原型因此如下：

```c
void handler(int signo);
```
对于大多数信号来说，调用sigaction函数并指定信号发生时所调用的函数就是捕获信号所需做的全部工作。不过SIGIO、SIGPOLL和SIGURG这些个别信号还要求捕获他们的进程做些额外工作。
4. 可以把某个信号的处置设定为SIG_IGN来忽略它。SIGKILL和SIGSTOP不能被忽略。
5. 可以把某个信号的处置设定为SIG_DEF来启用它的默认处置。默认处置通常是在收到信号后终止进程，其中某些信号还在当前工作目录产生一个进程的核心映像（core image，也称为内存影像）。另有个别信号的默认处置是忽略，SIGCHLD和SIGURG（带外数据到达时发送）就是默认处置为忽略的两个信号。
6. signal是早于POSIX出现的历史悠久的函数。调用它时，不用的实现提供不同的信号语义以达成后向兼容，而POSIX则明确规定了调用sigaction时的信号语义。我们的解决办法是定义自己的signal函数，它只是调用POSIX的sigaction函数。这就以所期望的POSIX语义提供了一个简单的接口。
7. 函数signal的正常函数原型因层次太多而变得很复杂：

```c
void (*signal(int signo, void (*func)(int)))(int);
```

可以使用typedef简化函数原型：

```c
typedef void Sigfunc(int);
Sigfunc *signal(int signo, Sigfunc *func);
```

1. SA_RESTART标志是可选的。如果设置，由相应信号中断的系统调用将由内核自动重启。
2. 在一个信号处理函数运行期间，正被递交的信号是阻塞的。而且，安装处理函数时在传递给sigaction函数的sa_mask信号集中指定的任何额外信号也被阻塞。
3. 如果一个信号在被阻塞期间产生了一次或多次，那么该信号被解阻塞之后通常只递交一次，也就是说Unix信号默认是不排队的。
4. 利用sigprocmask函数选择性地阻塞或解阻塞一组信号是可能的。这使得我们可以做到在一段临界区代码执行期间，防止捕获某些信号，以此保护这段代码。
5. 如果一个进程终止，而该进程有子进程处于僵死状态，那么它的所有僵死子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们。
6. 当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。
7. 如果调用wait的进程没有已终止的进程，不过有一个或多个子进程仍在执行，那么wait将阻塞到现有子进程第一个终止为止。
8. 网络编程中：(1)当fork子进程时，必须捕获SIGCHLD信号。(2)当捕获信号时，必须处理被中断的系统调用。(3)SIGCHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵死进程。
9. 当一个进程向某个已收到RST的套接字执行写操作时，内核向该进程发送一个SIGPIPE信号。该信号的默认行为是终止进程，因此进程必须捕获它以免不情愿地被终止。同时写操作将返回EPIPE错误。
10. Unix系统关机时，init进程通常先给所有进程发送SIGTERM信号（该信号可被捕获），等待一段固定的时间（往往是5~20秒），然后给所有仍在运行的进程发送SIGKILL信号（该信号不能被捕获）。这么做留给所有运行的进程一小段时间来清除和终止。如果我们忽略SIGTERM信号，我们的服务器将由SIGKILL信号终止。
11. 在客户与服务器间传递二进制结构：(1)不同的实现以不同的格式存储二进制数。最常见的格式便是大端字节序与小端字节序。(2)不同的实现在存储相同的C数据类型上可能存在差异。例如32位系统和64位系统的short、int和long等整数类型。(3)不同的实现给结构打包的方式存在差异，取决于各种数据类型所用的位数以及机器的对齐限制。