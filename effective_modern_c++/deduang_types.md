# 第一章 类型推导

## Item 1：理解模板类型推导

```c++
template<typename T>
void f(ParamType param);

f(expr);                        //从 expr 中推导 T 和 ParamType
```

### 情景一：`ParamType` 是一个指针或引用，但不是通用引用

在这种情况下，类型推导会这样进行：

1. 如果 `expr` 的类型是一个引用，忽略引用部分
2. 然后 `expr` 的类型与 `ParamType` 进行模式匹配来决定 `T`

### 情景二：`ParamType` 是一个通用引用

- 如果 `expr` 是左值，`T` 和 `ParamType` 都会被推导为左值引用。这非常不寻常，第一，这是模板类型推导中唯一一种 `T` 被推导为引用的情况。第二，虽然 `ParamType` 被声明为右值引用类型，但是最后推导的结果是左值引用。
- 如果 `expr` 是右值，就使用正常的（也就是**情景一**）推导规则

### 情景三：`ParamType` 既不是指针也不是引用

当 `ParamType` 既不是指针也不是引用时，我们通过传值（pass-by-value）的方式处理：

```c++
template<typename T>
void f(T param);                //以传值的方式处理param
```

这意味着无论传递什么 `param` 都会成为它的一份拷贝——一个完整的新对象。事实上 `param` 成为一个新对象这一行为会影响 `T` 如何从 `expr` 中推导出结果。

1. 和之前一样，如果 `expr` 的类型是一个引用，忽略这个引用部分
2. 如果忽略 `expr` 的引用性（reference-ness）之后，`expr` 是一个 `const`，那就再忽略 `const`。如果它是 `volatile`，也忽略 `volatile`（`volatile` 对象不常见，它通常用于驱动程序的开发中。关于 `volatile` 的细节请参见 Item 40）

**请记住：**

- 在模板类型推导时，有引用的实参会被视为无引用，他们的引用会被忽略
- 对于通用引用的推导，左值实参会被特殊对待
- 对于传值类型推导，`const` 和 / 或 `volatile` 实参会被认为是 non-`const` 的和 non-`volatile` 的
- 在模板类型推导时，数组名或者函数名实参会退化为指针，除非它们被用于初始化引用

## Item 2：理解 `auto` 类型推导

`auto` 类型推导除了一个例外（我们很快就会讨论），其他情况都和模板类型推导一样。

当用 `auto` 声明的变量使用花括号进行初始化，`auto` 类型推导推出的类型则为 `std::initializer_list`。如果这样的一个类型不能被成功推导（比如花括号里面包含的是不同类型的变量），编译器会拒绝这样的代码。

对于花括号的处理是 `auto` 类型推导和模板类型推导唯一不同的地方。当使用 `auto` 声明的变量使用花括号的语法进行初始化的时候，会推导出 `std::initializer_list<T>` 的实例化，但是对于模板类型推导这样就行不通。

`auto` 类型推导和模板类型推导的真正区别在于，`auto` 类型推导假定花括号表示 `std::initializer_list` 而模板类型推导不会这样（确切的说是不知道怎么办）。

C++14 允许 `auto` 用于函数返回值并会被推导（参见 Item 3），而且 C++14 的 lambda 函数也允许在形参声明中使用 `auto`。但是在这些情况下 `auto` 实际上使用模板类型推导的那一套规则在工作，而不是 `auto` 类型推导。

**请记住：**

- `auto` 类型推导通常和模板类型推导相同，但是 `auto` 类型推导假定花括号初始化代表 `std::initializer_list`，而模板类型推导不这样做
- 在 C++14 中 `auto` 允许出现在函数返回值或者 lambda 函数形参中，但是它的工作机制是模板类型推导那一套方案，而不是 `auto` 类型推导

## Item 3：理解 `decltype`

- `decltype` 总是不加修改的产生变量或者表达式的类型。
- 对于 `T` 类型的不是单纯的变量名的左值表达式，`decltype` 总是产出 `T` 的引用即 `T&`。
- C++14 支持 `decltype(auto)`，就像 `auto` 一样，推导出类型，但是它使用 `decltype` 的规则进行推导。

## Item 4：学会查看类型推导结果

- 类型推断可以从 IDE 看出，从编译器报错看出，从 Boost TypeIndex 库的使用看出
- 这些工具可能既不准确也无帮助，所以理解 C++ 类型推导规则才是最重要的
