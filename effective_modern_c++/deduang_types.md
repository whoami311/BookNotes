# 第一章 类型推导

## Item 1：理解模板类型推导

```c++
template<typename T>
void f(ParamType param);

f(expr);                        //从 expr 中推导 T 和 ParamType
```

### 情景一：`ParamType` 是一个指针或引用，但不是通用引用

在这种情况下，类型推导会这样进行：

1. 如果 `expr` 的类型是一个引用，忽略引用部分
2. 然后 `expr` 的类型与 `ParamType` 进行模式匹配来决定 `T`

### 情景二：`ParamType` 是一个通用引用

- 如果 `expr` 是左值，`T` 和 `ParamType` 都会被推导为左值引用。这非常不寻常，第一，这是模板类型推导中唯一一种 `T` 被推导为引用的情况。第二，虽然 `ParamType` 被声明为右值引用类型，但是最后推导的结果是左值引用。
- 如果 `expr` 是右值，就使用正常的（也就是**情景一**）推导规则

### 情景三：`ParamType` 既不是指针也不是引用

当 `ParamType` 既不是指针也不是引用时，我们通过传值（pass-by-value）的方式处理：

```c++
template<typename T>
void f(T param);                //以传值的方式处理param
```

这意味着无论传递什么 `param` 都会成为它的一份拷贝——一个完整的新对象。事实上 `param` 成为一个新对象这一行为会影响 `T` 如何从 `expr` 中推导出结果。

1. 和之前一样，如果 `expr` 的类型是一个引用，忽略这个引用部分
2. 如果忽略 `expr` 的引用性（reference-ness）之后，`expr` 是一个 `const`，那就再忽略 `const`。如果它是 `volatile`，也忽略 `volatile`（`volatile` 对象不常见，它通常用于驱动程序的开发中。关于 `volatile` 的细节请参见 Item 40）

**请记住：**

- 在模板类型推导时，有引用的实参会被视为无引用，他们的引用会被忽略
- 对于通用引用的推导，左值实参会被特殊对待
- 对于传值类型推导，`const` 和 / 或 `volatile` 实参会被认为是 non-`const` 的和 non-`volatile` 的
- 在模板类型推导时，数组名或者函数名实参会退化为指针，除非它们被用于初始化引用

## Item 2：理解 `auto` 类型推导

`auto` 类型推导除了一个例外（我们很快就会讨论），其他情况都和模板类型推导一样。

当用 `auto` 声明的变量使用花括号进行初始化，`auto` 类型推导推出的类型则为 `std::initializer_list`。如果这样的一个类型不能被成功推导（比如花括号里面包含的是不同类型的变量），编译器会拒绝这样的代码。

对于花括号的处理是 `auto` 类型推导和模板类型推导唯一不同的地方。当使用 `auto` 声明的变量使用花括号的语法进行初始化的时候，会推导出 `std::initializer_list<T>` 的实例化，但是对于模板类型推导这样就行不通。

`auto` 类型推导和模板类型推导的真正区别在于，`auto` 类型推导假定花括号表示 `std::initializer_list` 而模板类型推导不会这样（确切的说是不知道怎么办）。

C++14 允许 `auto` 用于函数返回值并会被推导（参见 Item 3），而且 C++14 的 lambda 函数也允许在形参声明中使用 `auto`。但是在这些情况下 `auto` 实际上使用模板类型推导的那一套规则在工作，而不是 `auto` 类型推导。

**请记住：**

- `auto` 类型推导通常和模板类型推导相同，但是 `auto` 类型推导假定花括号初始化代表 `std::initializer_list`，而模板类型推导不这样做
- 在 C++14 中 `auto` 允许出现在函数返回值或者 lambda 函数形参中，但是它的工作机制是模板类型推导那一套方案，而不是 `auto` 类型推导

## Item 3：理解 `decltype`

在 C++11 中，`decltype` 最主要的用途就是用于声明函数模板，而这个函数返回类型依赖于形参类型。

C++11 允许自动推导单一语句的 lambda 表达式的返回类型， C++14 扩展到允许自动推导所有的 lambda 表达式和函数，甚至它们内含多条语句。

C++ 期望在某些情况下当类型被暗示时需要使用 `decltype` 类型推导的规则，C++14 通过使用 `decltype(auto)` 说明符使得这成为可能。我们第一次看见 `decltype(auto)` 可能觉得非常的矛盾（到底是 `decltype` 还是 `auto`？），实际上我们可以这样解释它的意义：`auto` 说明符表示这个类型将会被推导，`decltype` 说明 `decltype` 的规则将会被用到这个推导过程中。

`decltype(auto)` 的使用不仅仅局限于函数返回类型，当你想对初始化表达式使用 `decltype` 推导的规则，你也可以使用。

```c++
template<typename Containter, typename Index>   //现在c是通用引用
decltype(auto) authAndAccess(Container&& c, Index i)
{
    authenticateUser();
    return std::forward<Container>(c)[i];
}
```

在这个模板中，我们不知道我们操纵的容器的类型是什么，那意味着我们同样不知道它使用的索引对象（index objects）的类型，对一个未知类型的对象使用传值通常会造成不必要的拷贝，对程序的性能有极大的影响，还会造成对象切片行为（参见 Item 41），以及给同事落下笑柄。但是就容器索引来说，我们遵照标准模板库对于索引的处理是有理由的（比如 `std::string`，`std::vector` 和 `std::deque` 的 `operator[]`），所以我们坚持传值调用。

将 `decltype` 应用于变量名会产生该变量名的声明类型。虽然变量名都是左值表达式，但这不会影响 `decltype` 的行为。（译者注：这里是说对于单纯的变量名，`decltype` 只会返回变量的声明类型）然而，对于比单纯的变量名更复杂的左值表达式，`decltype` 可以确保报告的类型始终是左值引用。也就是说，如果一个不是单纯变量名的左值表达式的类型是 `T`，那么 `decltype` 会把这个表达式的类型报告为 `T&`。这几乎没有什么太大影响，因为大多数左值表达式的类型天生具备一个左值引用修饰符。例如，返回左值的函数总是返回左值引用。

当使用 `decltype(auto)` 的时候一定要加倍的小心，在表达式中看起来无足轻重的细节将会影响到 `decltype(auto)` 的推导结果。为了确认类型推导是否产出了你想要的结果，请参见 Item 4 描述的那些技术。

同时你也不应该忽略 `decltype` 这块大蛋糕。没错，`decltype`（单独使用或者与 `auto` 一起用）可能会偶尔产生一些令人惊讶的结果，但那毕竟是少数情况。通常，`decltype` 都会产生你想要的结果，尤其是当你对一个变量使用 `decltype` 时，因为在这种情况下，`decltype` 只是做一件本分之事：它产出变量的声明类型。

**请记住：**

- `decltype` 总是不加修改的产生变量或者表达式的类型。
- 对于 `T` 类型的不是单纯的变量名的左值表达式，`decltype` 总是产出 `T` 的引用即 `T&`。
- C++14 支持 `decltype(auto)`，就像 `auto` 一样，推导出类型，但是它使用 `decltype` 的规则进行推导。

## Item 4：学会查看类型推导结果

- 类型推断可以从 IDE 看出，从编译器报错看出，从 Boost TypeIndex 库的使用看出
- 这些工具可能既不准确也无帮助，所以理解 C++ 类型推导规则才是最重要的
