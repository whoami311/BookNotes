# 第一章 类型推导

## Item 1：理解模板类型推导

- 在模板类型推导时，有引用的实参会被视为无引用，他们的引用会被忽略
- 对于通用引用的推导，左值实参会被特殊对待
- 对于传值类型推导，`const` 和 / 或 `volatile` 实参会被认为是 non-const 的和 non-volatile 的
- 在模板类型推导时，数组名或者函数名实参会退化为指针，除非它们被用于初始化引用

## Item 2：理解 `auto` 类型推导

- `auto` 类型推导通常和模板类型推导相同，但是 `auto` 类型推导假定花括号初始化代表 `std::initializer_list`，而模板类型推导不这样做
- 在 C++14 中 `auto` 允许出现在函数返回值或者 lambda 函数形参中，但是它的工作机制是模板类型推导那一套方案，而不是 `auto` 类型推导

## Item 3：理解 `decltype`

- `decltype` 总是不加修改的产生变量或者表达式的类型。
- 对于 `T` 类型的不是单纯的变量名的左值表达式，`decltype` 总是产出 `T` 的引用即 `T&`。
- C++14 支持 `decltype(auto)`，就像 `auto` 一样，推导出类型，但是它使用 `decltype` 的规则进行推导。

## Item 4：学会查看类型推导结果

- 类型推断可以从 IDE 看出，从编译器报错看出，从 Boost TypeIndex 库的使用看出
- 这些工具可能既不准确也无帮助，所以理解 C++ 类型推导规则才是最重要的
