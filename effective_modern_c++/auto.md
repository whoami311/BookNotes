# 第二章 `auto`

## Item 5：优先考虑 `auto` 而非显式类型声明

`auto` 变量从初始化表达式中推导出类型，所以我们必须初始化。

使用 `auto` 除了可以避免未初始化的无效变量，省略冗长的声明类型，直接保存闭包外，它还有一个好处是可以避免一个问题，我称之为与类型快捷方式（type shortcuts）有关的问题。

显式的指定类型可能会导致你不想看到的类型转换。如果你使用 `auto` 声明目标变量你就不必担心这个问题。

基于这些原因我建议你优先考虑 `auto` 而非显式类型声明。然而 `auto` 也不是完美的。每个 `auto` 变量都从初始化表达式中推导类型，有一些表达式的类型和我们期望的大相径庭。关于在哪些情况下会发生这些问题，以及你可以怎么解决这些问题我们在 Item 2 和 6 讨论。

事实是显式指定类型通常只会引入一些微妙的错误，无论是在正确性还是效率方面。而且，如果初始化表达式的类型改变，则 `auto` 推导出的类型也会改变，这意味着使用 `auto` 可以帮助我们完成一些重构工作。

**请记住：**

- `auto` 变量必须初始化，通常它可以避免一些移植性和效率性的问题，也使得重构更方便，还能让你少打几个字。
- 正如 Item2 和 6 讨论的，`auto` 类型的变量可能会踩到一些陷阱。

## Item 6：`auto` 推导若非己愿，使用显式类型初始化惯用法

作为一个通则，不可见的代理类通常不适用于 `auto`。这样类型的对象的生命期通常不会设计为能活过一条语句，所以创建那样的对象你基本上就走向了违反程序库设计基本假设的道路。`std::vector<bool>::reference` 就是这种情况，我们看到违反这个基本假设将导致未定义行为。

实际上， 很多开发者都是在跟踪一些令人困惑的复杂问题或在单元测试出错进行调试时才看到代理类的使用。不管你怎么发现它们的，一旦看到 `auto` 推导了代理类的类型而不是被代理的类型，解决方案并不需要抛弃 `auto`。`auto` 本身没什么问题，问题是 `auto` 不会推导出你想要的类型。解决方案是强制使用一个不同的类型推导形式，这种方法我通常称之为显式类型初始器惯用法（the explicitly typed initialized idiom）。

显式类型初始器惯用法使用 `auto` 声明一个变量，然后对表达式强制类型转换（cast）得出你期望的推导结果。

**请记住：**

- 不可见的代理类可能会使 `auto` 从表达式中推导出“错误的”类型
- 显式类型初始器惯用法强制 `auto` 推导出你想要的结果
