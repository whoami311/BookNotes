# 第八章 微调

对于 C++ 中的通用技术和特性，总是存在适用和不适用的场景。除了本章覆盖的两个例外，描述什么场景使用哪种通用技术通常来说很容易。这两个例外是传值（pass by value）和安置（emplacement）。决定何时使用这两种技术受到多种因素的影响，本书提供的最佳建议是在使用它们的同时仔细考虑清楚，尽管它们都是高效的现代 C++ 编程的重要角色。接下来的条款提供了使用它们来编写软件是否合适的所需信息。

## Item 41：对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递

有些函数的形参是可拷贝的。（在本条款中，“拷贝”一个形参通常意思是，将形参作为拷贝或移动操作的源对象。简介中提到，C++ 没有术语来区分拷贝操作得到的副本和移动操作得到的副本。）

```c++
class Widget {                                  //方法1：对左值和右值重载
public:
    void addName(const std::string& newName)
    { names.push_back(newName); } // rvalues
    void addName(std::string&& newName)
    { names.push_back(std::move(newName)); }
    …
private:
    std::vector<std::string> names;
};

class Widget {                                  //方法2：使用通用引用
public:
    template<typename T>
    void addName(T&& newName)
    { names.push_back(std::forward<T>(newName)); }
    …
};

class Widget {                                  //方法3：传值
public:
    void addName(std::string newName)
    { names.push_back(std::move(newName)); }
    …
};

Widget w;
…
std::string name("Bart");
w.addName(name);                                //传左值
…
w.addName(name + "Jenne");                      //传右值
```

忽略编译器对于移动和拷贝操作的优化，因为这些优化是与上下文和编译器有关的，实际上不会改变我们分析的本质。

- **重载**：无论传递左值还是传递右值，调用都会绑定到一个叫 `newName` 的引用上。从拷贝和移动操作方面看，这个过程零开销。左值重载中，`newName` 拷贝到 `Widget::names` 中，右值重载中，移动进去。开销总结：左值一次拷贝，右值一次移动。

- **使用通用引用**：同重载一样，调用也绑定到 `addName` 这个引用上，没有开销。由于使用了 `std::forward`，左值 `std::string` 实参会拷贝到 `Widget::names`，右值 `std::string` 实参移动进去。对 `std::string` 实参来说，开销同重载方式一样：左值一次拷贝，右值一次移动。

    Item25 解释了如果调用者传递的实参不是 `std::string` 类型，将会转发到 `std::string` 的构造函数，几乎也没有 `std::string` 拷贝或者移动操作。因此通用引用的方式有同样效率，所以这不影响本次分析，简单假定调用者总是传入 `std::string` 类型实参即可。

- **按值传递**：无论传递左值还是右值，都必须构造 `newName` 形参。如果传递的是左值，需要拷贝的开销，如果传递的是右值，需要移动的开销。在函数的实现中，`newName` 总是采用移动的方式到 `Widget::names`。开销总结：左值实参，一次拷贝一次移动，右值实参两次移动。对比按引用传递的方法，对于左值或者右值，均多出一次移动操作。

再次回顾本Item的内容：

    对于移动成本低且总是被拷贝的可拷贝形参，考虑按值传递。

这样措辞是有原因的。实际上四个原因：

1. 应该仅**考虑**使用传值方式。确实，只需要编写一个函数。确实，只会在目标代码中生成一个函数。确实，避免了通用引用的种种问题。但是毕竟开销会比那些替代方式更高（译者注：指接受引用的两种实现方式），而且下面还会讨论，还会存在一些目前我们并未讨论到的开销。
2. 仅考虑对于**可拷贝形参**使用按值传递。不符合此条件的的形参必须有只可移动的类型（move-only types）（的数据成员），因为函数总是会做副本（译注：指的是传值时形参总是实参的一个副本），而如果它们不可拷贝，副本就必须通过移动构造函数创建。（这样的句子就说明有一个术语来区分拷贝操作制作的副本，和移动操作制作的副本，是非常好的。）回忆一下传值方案比“重载”方案的优势在于，仅有一个函数要写。但是对于只可移动类型，没必要为左值实参提供重载，因为拷贝左值需要拷贝构造函数，只可移动类型的拷贝构造函数是禁用的。那意味着只需要支持右值实参，“重载”方案只需要一个重载函数：接受右值引用的函数。
3. 按值传递应该仅考虑那些**移动开销小**的形参。当移动的开销较低，额外的一次移动才能被开发者接受，但是当移动的开销很大，执行不必要的移动就类似执行一个不必要的拷贝，而避免不必要的拷贝的重要性就是最开始 C++98 规则中避免传值的原因！
4. 你应该只对**总是被拷贝**的形参考虑按值传递。

即使你编写的函数对可拷贝类型执行无条件的复制，且这个类型移动开销小，有时也可能不适合按值传递。这是因为函数拷贝一个形参存在两种方式：一种是通过构造函数（拷贝构造或者移动构造），还有一种是赋值（拷贝赋值或者移动赋值）。对于使用构造函数拷贝形参的函数，之前的分析已经可以给出最终结论：按值传递对于左值和右值均增加了一次移动操作的开销。

当形参通过赋值操作进行拷贝时，分析起来更加复杂。

基于赋值的形参拷贝操作开销取决于具体的实参的值，这种分析适用于在动态分配内存中存值的形参类型。不是所有类型都满足，但是很多——包括 `std::string` 和 `std::vector`——是这样。

这种潜在的开销增加仅在传递左值实参时才适用，因为执行内存分配和释放通常发生在真正的拷贝操作（即，不是移动）中。对右值实参，移动几乎就足够了。

结论是，使用通过赋值拷贝一个形参进行按值传递的函数的额外开销，取决于传递的类型，左值和右值的比例，这个类型是否需要动态分配内存，以及，如果需要分配内存的话，赋值操作符的具体实现，还有赋值目标占的内存至少要跟赋值源占的内存一样大。对于 `std::string` 来说，开销还取决于实现是否使用了小字符串优化（SSO——参考 Item 29），如果是，那么要赋值的值是否匹配 SSO 缓冲区。

所以，正如我所说，当形参通过赋值进行拷贝时，分析按值传递的开销是复杂的。通常，最有效的经验就是“在证明没问题之前假设有问题”，就是除非已证明按值传递会为你需要的形参类型产生可接受的执行效率，否则使用重载或者通用引用的实现方式。

到此为止，对于需要运行尽可能快的软件来说，按值传递可能不是一个好策略，因为避免即使开销很小的移动操作也非常重要。此外，有时并不能清楚知道会发生多少次移动操作。在调用链中，每个函数都使用传值，因为“只多了一次移动的开销”，但是整个调用链总体就会产生无法忍受的开销，通过引用传递，调用链不会增加这种开销。

跟性能无关，但总是需要考虑的是，不像按引用传递，按值传递会受到切片问题的影响。这是 C++98 的事，在此不在详述，但是如果要设计一个函数，来处理这样的形参：基类或者任何其派生类，你肯定不想声明一个那个类型的传值形参，因为你会“切掉”传入的任意派生类对象的派生类特征。

如果不熟悉对象切片问题，可以先通过搜索引擎了解一下。这样你就知道切片问题是 C++98 中默认按值传递名声不好的另一个原因（要在效率问题的原因之上）。

C++11 没有从根本上改变 C++98 对于按值传递的智慧。通常，按值传递仍然会带来你希望避免的性能下降，而且按值传递会导致切片问题。C++11 中新的功能是区分了左值和右值实参。利用对于可拷贝类型的右值的移动语义，需要重载或者通用引用，尽管两者都有其缺陷。对于特殊的场景，可拷贝且移动开销小的类型，传递给总是会拷贝他们的一个函数，并且切片也不需要考虑，这时，按值传递就提供了一种简单的实现方式，效率接近传递引用的函数，但是避免了传引用方案的缺点。

**请记住：**

- 对于可拷贝，移动开销低，而且无条件被拷贝的形参，按值传递效率基本与按引用传递效率一致，而且易于实现，还生成更少的目标代码。
- 通过构造拷贝形参可能比通过赋值拷贝形参开销大的多。
- 按值传递会引起切片问题，所说不适合基类形参类型。

## Item 42：考虑就地创建而非插入

`std::vector` 的 `push_back` 被按左值和右值分别重载：

```c++
template <class T,                  //来自C++11标准
          class Allocator = allocator<T>>
class vector {
public:
    …
    void push_back(const T& x);     //插入左值
    void push_back(T&& x);          //插入右值
    …
};
```

```c++
std::vector<std::string> vs;        //std::string的容器
vs.push_back("xyzzy");              //添加字符串字面量
```

为了在 `std::string` 容器中创建新元素，调用了 `std::string` 的构造函数，但是这份代码并不仅调用了一次构造函数，而是调用了两次，而且还调用了 `std::string` 析构函数。

`emplace_back` 就是像我们想要的那样做的：使用传递给它的任何实参直接在 `std::vector` 内部构造一个 `std::string`。没有临时变量会生成。

`emplace_back` 使用完美转发，因此只要你没有遇到完美转发的限制（参见 Item 30），就可以传递任何实参以及组合到 `emplace_back`。

`emplace_back` 可以用于每个支持 `push_back` 的标准容器。类似的，每个支持 `push_front` 的标准容器都支持 `emplace_front`。每个支持 `insert`（除了 `std::forward_list` 和 `std::array`）的标准容器支持 `emplace`。关联容器提供 `emplace_hint` 来补充接受“hint”迭代器的 `insert` 函数，`std::forward_list` 有 `emplace_after` 来匹配 `insert_after`。

使得置入（emplacement）函数功能优于插入函数的原因是它们有灵活的接口。插入函数接受**对象**去插入，而置入函数接受**对象的构造函数接受的实参**去插入。这种差异允许置入函数避免插入函数所必需的临时对象的创建和销毁。

因为可以传递容器内元素类型的实参给置入函数（因此该实参使函数执行复制或者移动构造函数），所以在插入函数不会构造临时对象的情况，也可以使用置入函数。在这种情况下，插入和置入函数做的是同一件事。

因此，置入函数可以完成插入函数的所有功能。并且有时效率更高，至少在理论上，不会更低效。那为什么不在所有场合使用它们？

因为，就像说的那样，只是“理论上”，在理论和实际上没有什么区别，但是实际上区别还是有的。在当前标准库的实现下，有些场景，就像预期的那样，置入执行性能优于插入，但是，有些场景反而插入更快。这种场景不容易描述，因为依赖于传递的实参的类型、使用的容器、置入或插入到容器中的位置、容器中类型的构造函数的异常安全性，和对于禁止重复值的容器（即 `std::set`，`std::map`，`std::unordered_set`，`std::unordered_map`）要添加的值是否已经在容器中。因此，大致的调用建议是：通过 benchmark 测试来确定置入和插入哪种更快。

当然这个结论不是很令人满意，所以你会很高兴听到还有一种启发式的方法来帮助你确定是否应该使用置入。如果下列条件都能满足，置入会优于插入：

- **值是通过构造函数添加到容器，而不是直接赋值**。如果新值放到已经存在了对象的一个地方，那情况就完全不一样了。考虑下：
    ```c++
    std::vector<std::string> vs;        //跟之前一样
    …                                   //添加元素到vs
    vs.emplace(vs.begin(), "xyzzy");    //添加“xyzzy”到vs头部
    ```
    对于这份代码，没有实现会在已经存在对象的位置 `vs[0]` 构造这个添加的 `std::string`。而是，通过移动赋值的方式添加到需要的位置。但是移动赋值需要一个源对象，所以这意味着一个临时对象要被创建，而置入优于插入的原因就是没有临时对象的创建和销毁，所以当通过赋值操作添加元素时，置入的优势消失殆尽。

    而且，向容器添加元素是通过构造还是赋值通常取决于实现者。但是，启发式仍然是有帮助的。基于节点的容器实际上总是使用构造添加新元素，大多数标准库容器都是基于节点的。例外的容器只有 `std::vector`，`std::deque`，`std::string`。（`std::array` 也不是基于节点的，但是它不支持置入和插入，所以它与这儿无关。）在不是基于节点的容器中，你可以依靠 `emplace_back` 来使用构造向容器添加元素，对于 `std::deque`，`emplace_front` 也是一样的。
- **传递的实参类型与容器的初始化类型不同**。再次强调，置入优于插入通常基于以下事实：当传递的实参不是容器保存的类型时，接口不需要创建和销毁临时对象。当将类型为T的对象添加到 `container<T>` 时，没有理由期望置入比插入运行的更快，因为不需要创建临时对象来满足插入的接口。
- **容器不拒绝重复项作为新值**。 这意味着容器要么允许添加重复值，要么你添加的元素大部分都是不重复的。这样要求的原因是为了判断一个元素是否已经存在于容器中，置入实现通常会创建一个具有新值的节点，以便可以将该节点的值与现有容器中节点的值进行比较。如果要添加的值不在容器中，则链接该节点。然后，如果值已经存在，置入操作取消，创建的节点被销毁，意味着构造和析构时的开销被浪费了。这样的节点更多的是为置入函数而创建，相比起为插入函数来说。

在决定是否使用置入函数时，需要注意另外两个问题。首先是资源管理。

根本上讲，像 `std::shared_ptr` 和 `std::unique_ptr` 这样的资源管理类的高效性是以资源（比如从 `new` 来的原始指针）被立即传递给资源管理对象的构造函数为条件的。实际上，`std::make_shared` 和 `std::make_unique` 这样的函数自动做了这些事，是使它们如此重要的原因。

在对存储资源管理类对象的容器（比如 `std::list<std::shared_ptr<Widget>>`）调用插入函数时，函数的形参类型通常确保在资源的获取（比如使用 `new`）和资源管理对象的创建之间没有其他操作。在置入函数中，完美转发推迟了资源管理对象的创建，直到可以在容器的内存中构造它们为止，这给“异常导致资源泄漏”提供了可能。所有的标准库容器都容易受到这个问题的影响。在使用资源管理对象的容器时，必须注意确保在使用置入函数而不是插入函数时，不会为提高效率带来的降低异常安全性付出代价。

坦白说，无论如何，你不应该将 `new Widget` 之类的表达式传递给 `emplace_back` 或者 `push_back` 或者大多数这种函数，因为，就像 Item 21 中解释的那样，这可能导致我们刚刚讨论的异常安全性问题。消除资源泄漏可能性的方法是，使用独立语句把从 `new Widget` 获取的指针传递给资源管理类对象，然后这个对象作为右值传递给你本来想传递 `new Widget` 的函数（Item 21 有这个观点的详细讨论）。

无论哪种方式，都会产生 `spw` 的创建和销毁成本。选择置入而非插入的动机是避免容器元素类型的临时对象的开销。但是对于 `spw` 的概念来讲，当添加资源管理类型对象到容器中，并根据正确的方式确保在获取资源和连接到资源管理对象上之间无其他操作时，置入函数不太可能胜过插入函数。

置入函数的第二个值得注意的方面是它们与 `explicit` 的构造函数的交互。

```c++
std::regex r1 = nullptr;                 //错误！不能编译
std::regex r2(nullptr);                  //可以编译
```

在标准的官方术语中，用于初始化 `r1` 的语法（使用等号）是所谓的**拷贝初始化**。相反，用于初始化 `r2` 的语法是（使用小括号，有时也用花括号）被称为**直接初始化**。

```c++
using regex   = basic_regex<char>;

explicit basic_regex(const char* ptr,flag_type flags); //定义 (1)explicit构造函数

basic_regex(const basic_regex& right); //定义 (2)拷贝构造函数
```

拷贝初始化不被允许使用 `explicit` 构造函数（译者注：即没法调用相应类的 `explicit` 拷贝构造函数）：对于 `r1`,使用赋值运算符定义变量时将调用拷贝构造函数定义 (2)，其形参类型为 `basic_regex&`。因此 `nullptr` 首先需要隐式装换为 `basic_regex`。而根据定义 (1)中的 `explicit`，这样的隐式转换不被允许，从而产生编译时期的报错。对于直接初始化，编译器会自动选择与提供的参数最匹配的构造函数，即定义 (1)。就是初始化 `r1` 不能编译，而初始化 `r2` 可以编译的原因。

然后回到 `push_back` 和 `emplace_back`，更一般来说是，插入函数和置入函数的对比。置入函数使用直接初始化，这意味着可能使用 `explicit` 的构造函数。插入函数使用拷贝初始化，所以不能用 `explicit` 的构造函数。因此：

```c++
regexes.emplace_back(nullptr);           //可编译。直接初始化允许使用接受指针的
                                         //std::regex的explicit构造函数
regexes.push_back(nullptr);              //错误！拷贝初始化不允许用那个构造函数
```

获得的经验是，当你使用置入函数时，请特别小心确保传递了正确的实参，因为即使是 `explicit` 的构造函数也会被编译器考虑，编译器会试图以有效方式解释你的代码。

**请记住：**

- 原则上，置入函数有时会比插入函数高效，并且不会更差。
- 实际上，当以下条件满足时，置入函数更快：
  1. 值被构造到容器中，而不是直接赋值；
  2. 传入的类型与容器的元素类型不一致；
  3. 容器不拒绝已经存在的重复值。
- 置入函数可能执行插入函数拒绝的类型转换。
