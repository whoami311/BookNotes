# 移步现代 C++

## Item 7：区别使用 `()` 和 `{}` 创建对象

- 花括号初始化是最广泛使用的初始化语法，它防止变窄转换，并且对于 C++ 最令人头疼的解析有天生的免疫性
- 在构造函数重载决议中，编译器会尽最大努力将括号初始化与 `std::initializer_list` 参数匹配，即便其他构造函数看起来是更好的选择
- 对于数值类型的 `std::vector` 来说使用花括号初始化和圆括号初始化会造成巨大的不同
- 在模板类选择使用圆括号初始化或使用花括号初始化创建对象是一个挑战

## Item 8：优先考虑 `nullptr` 而非 `0` 和 `NULL`

- 优先考虑 `nullptr` 而非 `0` 和 `NULL`
- 避免重载指针和整型

## Item 9：优先考虑别名声明而非 `typedef`

- `typedef` 不支持模板化，但是别名声明支持。
- 别名模板避免了使用 `::type` 后缀，而且在模板中使用 `typedef` 还需要在前面加上 `typename`
- C++14 提供了 C++11 所有 type traits 转换的别名声明版本

## Item 10：优先考虑限域 `enum` 而非未限域 `enum`

- C++98的 `enum` 即非限域 `enum`。
- 限域 `enum` 的枚举名仅在 `enum` 内可见。要转换为其它类型只能使用 `cast`
- 非限域 / 限域 `enum` 都支持底层类型说明语法，限域 `enum` 底层类型默认是 `int`。非限域 `enum` 没有默认底层类型
- 限域 `enum` 总是可以前置声明。非限域 `enum` 仅当指定它们的底层类型时才能前置

## Item 11：优先考虑使用 `deleted` 函数而非使用未定义的私有声明

- 比起声明函数为 `private` 但不定义，使用 `deleted` 函数更好
- 任何函数都能被删除（be deleted），包括非成员函数和模板实例（译注：实例化的函数）

## Item 12：使用 `override` 声明重写函数

- 为重写函数加上 `override`
- 成员函数引用限定让我们可以区别对待左值对象和右值对象（即 `*this`）

## Item 13：优先考虑 `const_iterator` 而非 `iterator`

- 优先考虑 `const_iterator` 而非 `iterator`
- 在最大程度通用的代码中，优先考虑非成员函数版本的 `begin`，`end`，`rbegin` 等，而非同名成员函数

## Item 14：如果函数不抛出异常请使用 `noexcept`

- `noexcept` 是函数接口的一部分，这意味着调用者可能会依赖它
- `noexcept` 函数较之于 non-noexcept 函数更容易优化
- `noexcept` 对于移动语义，`swap`，内存释放函数和析构函数非常有用
- 大多数函数是异常中立的（译注：可能抛也可能不抛异常）而不是 `noexcept`

## Item 15：尽可能的使用 `constexpr`

- `constexpr` 对象是 `const`，它被在编译期可知的值初始化
- 当传递编译期可知的值时，`constexpr` 函数可以产出编译期可知的结果
- `constexpr` 对象和函数可以使用的范围比 non-constexpr 对象和函数要大
- `constexpr` 是对象和函数接口的一部分

## Item 16：让 `const` 成员函数线程安全

- 确保 `const` 成员函数线程安全，除非你确定它们永远不会在并发上下文（concurrent context）中使用。
- 使用 `std::atomic` 变量可能比互斥量提供更好的性能，但是它只适合操作单个变量或内存位置。

## Item 17：理解特殊成员函数的生成

- 特殊成员函数是编译器可能自动生成的函数：默认构造函数，析构函数，拷贝操作，移动操作
- 移动操作仅当类没有显式声明移动操作、拷贝操作、析构函数时才自动生成
- 拷贝构造函数仅当类没有显式声明拷贝构造函数时才自动生成，并且如果用户声明了移动操作，拷贝构造就是 `delete`。拷贝赋值运算符仅当类没有显式声明拷贝赋值运算符时才自动生成，并且如果用户声明了移动操作，拷贝赋值运算符就是 `delete`。当用户声明了析构函数，拷贝操作的自动生成已被废弃
- 成员函数模板不抑制特殊成员函数的生成
