# 第五章 右值引用，移动语义，完美转发

- **移动语义**使编译器有可能用廉价的移动操作来代替昂贵的拷贝操作。正如拷贝构造函数和拷贝赋值操作符给了你控制拷贝语义的权力，移动构造函数和移动赋值操作符也给了你控制移动语义的权力。移动语义也允许创建只可移动（move-only）的类型，例如 `std::unique_ptr`，`std::future` 和 `std::thread`。

- **完美转发**使接收任意数量实参的函数模板成为可能，它可以将实参转发到其他的函数，使目标函数接收到的实参与被传递给转发函数的实参保持一致。

**右值引用**是连接这两个截然不同的概念的胶合剂。它是使移动语义和完美转发变得可能的基础语言机制。

牢记形参永远是左值，即使它的类型是一个右值引用。

## Item 23：理解 `std::move` 和 `std::forward`

`std::move` 不移动（move）任何东西，`std::forward` 也不转发（forward）任何东西。在运行时，它们不做任何事情。它们不产生任何可执行代码，一字节也没有。

`std::move` 和 `std::forward` 仅仅是执行转换（cast）的函数（事实上是函数模板）。`std::move` 无条件的将它的实参转换为右值，而 `std::forward` 只在特定情况满足时下进行转换。它们就是如此。

```c++
template<typename T>
decltype(auto) move(T&& param)          //C++14，在std命名空间
{
    using ReturnType = remove_referece_t<T>&&;
    return static_cast<ReturnType>(param);
}
```

1. 不要在你希望能移动对象的时候，声明它们为 `const`。对 `const` 对象的移动请求会悄无声息的被转化为拷贝操作。
2. `std::move` 不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动。关于 `std::move`，你能确保的唯一一件事就是将它应用到一个对象上，你能够得到一个右值。

与 `std::move` 总是无条件的将它的实参为右值不同，`std::forward` 只有在满足一定条件的情况下才执行转换。`std::forward` 是有条件的转换。

是否我们可以免于使用 `std::move` 而在任何地方只使用 `std::forward`？从纯技术的角度，答案是 yes：`std::forward` 是可以完全胜任，`std::move` 并非必须。

`std::move` 的吸引力在于它的便利性：减少了出错的可能性，增加了代码的清晰程度。

注意，第一，`std::move` 只需要一个函数实参，而 `std::forward` 不但需要一个函数实参，还需要一个模板类型实参。其次，我们传递给 `std::forward` 的类型应当是一个non-reference，因为惯例是传递的实参应该是一个右值（见 Item 28）。同样，这意味着 `std::move` 比起 `std::forward` 来说需要打更少的字，并且免去了传递一个表示我们正在传递一个右值的类型实参。同样，它根绝了我们传递错误类型的可能性。

更重要的是，`std::move` 的使用代表着无条件向右值的转换，而使用 `std::forward` 只对绑定了右值的引用进行到右值转换。这是两种完全不同的动作。前者是典型地为了移动操作，而后者只是传递（亦为转发）一个对象到另外一个函数，保留它原有的左值属性或右值属性。因为这些动作实在是差异太大，所以我们拥有两个不同的函数（以及函数名）来区分这些动作。

**请记住：**

- `std::move` 执行到右值的无条件的转换，但就自身而言，它不移动任何东西
- `std::forward` 只有当它的参数被绑定到一个右值时，才将参数转换为右值
- `std::move` 和 `std::forward` 在运行期什么也不做

## Item 24：区分通用引用与右值引用

事实上，`T&&` 有两种不同的意思。第一种，当然是右值引用。这种引用表现得正如你所期待的那样：它们只绑定到右值上，并且它们主要的存在原因就是为了识别可以移动操作的对象。

`T&&` 的另一种意思是，它既可以是右值引用，也可以是左值引用。这种引用在源码里看起来像右值引用（即 `T&&`），但是它们可以表现得像是左值引用（即 `T&`）。它们的二重性使它们既可以绑定到右值上（就像右值引用），也可以绑定到左值上（就像左值引用）。此外，它们还可以绑定到 `const` 或者 non-`const` 的对象上，也可以绑定到 `volatile` 或者non-`volatile` 的对象上，甚至可以绑定到既 `const` 又 `volatile` 的对象上。它们可以绑定到几乎任何东西。这种空前灵活的引用值得拥有自己的名字。我把它叫做通用引用（universal references）。（Item 25 解释了 `std::forward` 几乎总是可以应用到通用引用上，并且在这本书即将出版之际，一些 C++ 社区的成员已经开始将这种通用引用称之为转发引用（forwarding references））。


**请记住：**

- 如果一个函数模板形参的类型为 `T&&`，并且 `T` 需要被推导得知，或者如果一个对象被声明为 `auto&&`，这个形参或者对象就是一个通用引用
- 如果类型声明的形式不是标准的 `type&&`，或者如果类型推导没有发生，那么 `type&&` 代表一个右值引用
- 通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用

## Item 25：对右值引用使用 `std::move`，对通用引用使用 `std::forward`

右值引用仅绑定可以移动的对象。另一方面，通用**引用**可能绑定到有资格移动的对象上。通用引用使用右值初始化时，才将其强制转换为右值。

总而言之，当把右值引用转发给其他函数时，右值引用应该被**无条件转换**为右值（通过 `std::move`），因为它们**总是**绑定到右值；当转发通用引用时，通用引用应该**有条件地转换**为右值（通过 `std::forward`），因为它们只是有时绑定到右值。

如果你在**按值**返回的函数中，返回值绑定到右值引用或者通用引用上，需要对返回的引用使用 `std::move` 或者 `std::forward`。

```c++
Widget makeWidget()                 //makeWidget的“拷贝”版本
{
    Widget w;                       //局部对象
    …                               //配置w
    return w;                       //“拷贝”w到返回值中
}
```

```c++
Widget makeWidget()                 //makeWidget的移动版本
{
    Widget w;
    …
    return std::move(w);            //移动w到返回值中（不要这样做！）
}
```

这是错的，因为对于这种优化，标准化委员会远领先于开发者。早就为人认识到的是，`makeWidget` 的“拷贝”版本可以避免复制局部变量 `w` 的需要，通过在分配给函数返回值的内存中构造 `w` 来实现。这就是所谓的**返回值优化**（return value optimization，RVO），这在C++标准中已经实现了。

对这种好事遣词表达是个讲究活，因为你想只在那些不影响软件外在行为的地方允许这样的**拷贝消除**（copy elision）。对标准中教条的（也可以说是有毒的）絮叨做些解释，这个特定的好事就是说，编译器可能会在按值返回的函数中消除对局部对象的拷贝（或者移动），如果满足

1. 局部对象与函数返回值的类型相同
2. 局部对象就是要返回的东西（适合的局部对象包括大多数局部变量，还有作为 `return` 语句的一部分而创建的临时对象。函数形参不满足要求。一些人将 RVO 的应用区分为命名的和未命名的（即临时的）局部对象，限制了 RVO 术语应用到未命名对象上，并把对命名对象的应用称为**命名返回值优化**（named return value optimization，NRVO）。）

但是 RVO 就是个优化。编译器不被**要求**消除拷贝和移动操作，即使他们被允许这样做。或许你会疑惑，并担心编译器用拷贝操作惩罚你，因为它们确实可以这样。或者你可能有足够的了解，意识到有些情况很难让编译器实现 RVO，比如当函数不同控制路径返回不同局部变量时。（编译器必须产生一些代码在分配的函数返回值的内存中构造适当的局部变量，但是编译器如何确定哪个变量是合适的呢？）如果这样，你可能会愿意以移动的代价来保证不会产生拷贝。那就是，极可能仍然认为应用 `std::move` 到一个要返回的局部对象上是合理的，只因为可以不再担心拷贝的代价。

那种情况下，应用 `std::move` 到一个局部对象上**仍然**是一个坏主意。C++ 标准关于 RVO 的部分表明，如果满足 RVO 的条件，但是编译器选择不执行拷贝消除，则返回的对象**必须被视为右值**。实际上，标准要求当 RVO 被允许时，或者实行拷贝消除，或者将 `std::move` 隐式应用于返回的局部对象。

这意味着，如果对从按值返回的函数返回来的局部对象使用 `std::move`，你并不能帮助编译器（如果不能实行拷贝消除的话，他们必须把局部对象看做右值），而是阻碍其执行优化选项（通过阻止 RVO）。在某些情况下，将 `std::move` 应用于局部变量可能是一件合理的事（即，你把一个变量传给函数，并且知道不会再用这个变量），但是满足 RVO 的 `return` 语句或者返回一个传值形参并不在此列。

**请记住：**

- 最后一次使用时，在右值引用上使用 `std::move`，在通用引用上使用 `std::forward`
- 对按值返回的函数要返回的右值引用和通用引用，执行相同的操作
- 如果局部对象可以被返回值优化消除，就绝不使用 `std::move` 或者 `std::forward`
