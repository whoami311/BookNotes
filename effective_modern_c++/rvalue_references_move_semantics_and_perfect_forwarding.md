# 第五章 右值引用，移动语义，完美转发

- **移动语义**使编译器有可能用廉价的移动操作来代替昂贵的拷贝操作。正如拷贝构造函数和拷贝赋值操作符给了你控制拷贝语义的权力，移动构造函数和移动赋值操作符也给了你控制移动语义的权力。移动语义也允许创建只可移动（move-only）的类型，例如 `std::unique_ptr`，`std::future` 和 `std::thread`。

- **完美转发**使接收任意数量实参的函数模板成为可能，它可以将实参转发到其他的函数，使目标函数接收到的实参与被传递给转发函数的实参保持一致。

**右值引用**是连接这两个截然不同的概念的胶合剂。它是使移动语义和完美转发变得可能的基础语言机制。

牢记形参永远是左值，即使它的类型是一个右值引用。

## Item 23：理解 `std::move` 和 `std::forward`

`std::move` 不移动（move）任何东西，`std::forward` 也不转发（forward）任何东西。在运行时，它们不做任何事情。它们不产生任何可执行代码，一字节也没有。

`std::move` 和 `std::forward` 仅仅是执行转换（cast）的函数（事实上是函数模板）。`std::move` 无条件的将它的实参转换为右值，而 `std::forward` 只在特定情况满足时下进行转换。它们就是如此。

```c++
template<typename T>
decltype(auto) move(T&& param)          //C++14，在std命名空间
{
    using ReturnType = remove_referece_t<T>&&;
    return static_cast<ReturnType>(param);
}
```

1. 不要在你希望能移动对象的时候，声明它们为 `const`。对 `const` 对象的移动请求会悄无声息的被转化为拷贝操作。
2. `std::move` 不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动。关于 `std::move`，你能确保的唯一一件事就是将它应用到一个对象上，你能够得到一个右值。

与 `std::move` 总是无条件的将它的实参为右值不同，`std::forward` 只有在满足一定条件的情况下才执行转换。`std::forward` 是有条件的转换。

是否我们可以免于使用 `std::move` 而在任何地方只使用 `std::forward`？从纯技术的角度，答案是 yes：`std::forward` 是可以完全胜任，`std::move` 并非必须。

`std::move` 的吸引力在于它的便利性：减少了出错的可能性，增加了代码的清晰程度。

注意，第一，`std::move` 只需要一个函数实参，而 `std::forward` 不但需要一个函数实参，还需要一个模板类型实参。其次，我们传递给 `std::forward` 的类型应当是一个non-reference，因为惯例是传递的实参应该是一个右值（见 Item 28）。同样，这意味着 `std::move` 比起 `std::forward` 来说需要打更少的字，并且免去了传递一个表示我们正在传递一个右值的类型实参。同样，它根绝了我们传递错误类型的可能性。

更重要的是，`std::move` 的使用代表着无条件向右值的转换，而使用 `std::forward` 只对绑定了右值的引用进行到右值转换。这是两种完全不同的动作。前者是典型地为了移动操作，而后者只是传递（亦为转发）一个对象到另外一个函数，保留它原有的左值属性或右值属性。因为这些动作实在是差异太大，所以我们拥有两个不同的函数（以及函数名）来区分这些动作。

**请记住：**

- `std::move` 执行到右值的无条件的转换，但就自身而言，它不移动任何东西
- `std::forward` 只有当它的参数被绑定到一个右值时，才将参数转换为右值
- `std::move` 和 `std::forward` 在运行期什么也不做

## Item 24：区分通用引用与右值引用

事实上，`T&&` 有两种不同的意思。第一种，当然是右值引用。这种引用表现得正如你所期待的那样：它们只绑定到右值上，并且它们主要的存在原因就是为了识别可以移动操作的对象。

`T&&` 的另一种意思是，它既可以是右值引用，也可以是左值引用。这种引用在源码里看起来像右值引用（即 `T&&`），但是它们可以表现得像是左值引用（即 `T&`）。它们的二重性使它们既可以绑定到右值上（就像右值引用），也可以绑定到左值上（就像左值引用）。此外，它们还可以绑定到 `const` 或者 non-`const` 的对象上，也可以绑定到 `volatile` 或者non-`volatile` 的对象上，甚至可以绑定到既 `const` 又 `volatile` 的对象上。它们可以绑定到几乎任何东西。这种空前灵活的引用值得拥有自己的名字。我把它叫做通用引用（universal references）。（Item 25 解释了 `std::forward` 几乎总是可以应用到通用引用上，并且在这本书即将出版之际，一些 C++ 社区的成员已经开始将这种通用引用称之为转发引用（forwarding references））。


**请记住：**

- 如果一个函数模板形参的类型为 `T&&`，并且 `T` 需要被推导得知，或者如果一个对象被声明为 `auto&&`，这个形参或者对象就是一个通用引用
- 如果类型声明的形式不是标准的 `type&&`，或者如果类型推导没有发生，那么 `type&&` 代表一个右值引用
- 通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用

## Item 25：对右值引用使用 `std::move`，对通用引用使用 `std::forward`

右值引用仅绑定可以移动的对象。另一方面，通用**引用**可能绑定到有资格移动的对象上。通用引用使用右值初始化时，才将其强制转换为右值。

总而言之，当把右值引用转发给其他函数时，右值引用应该被**无条件转换**为右值（通过 `std::move`），因为它们**总是**绑定到右值；当转发通用引用时，通用引用应该**有条件地转换**为右值（通过 `std::forward`），因为它们只是有时绑定到右值。

如果你在**按值**返回的函数中，返回值绑定到右值引用或者通用引用上，需要对返回的引用使用 `std::move` 或者 `std::forward`。

```c++
Widget makeWidget()                 //makeWidget的“拷贝”版本
{
    Widget w;                       //局部对象
    …                               //配置w
    return w;                       //“拷贝”w到返回值中
}
```

```c++
Widget makeWidget()                 //makeWidget的移动版本
{
    Widget w;
    …
    return std::move(w);            //移动w到返回值中（不要这样做！）
}
```

这是错的，因为对于这种优化，标准化委员会远领先于开发者。早就为人认识到的是，`makeWidget` 的“拷贝”版本可以避免复制局部变量 `w` 的需要，通过在分配给函数返回值的内存中构造 `w` 来实现。这就是所谓的**返回值优化**（return value optimization，RVO），这在C++标准中已经实现了。

对这种好事遣词表达是个讲究活，因为你想只在那些不影响软件外在行为的地方允许这样的**拷贝消除**（copy elision）。对标准中教条的（也可以说是有毒的）絮叨做些解释，这个特定的好事就是说，编译器可能会在按值返回的函数中消除对局部对象的拷贝（或者移动），如果满足

1. 局部对象与函数返回值的类型相同
2. 局部对象就是要返回的东西（适合的局部对象包括大多数局部变量，还有作为 `return` 语句的一部分而创建的临时对象。函数形参不满足要求。一些人将 RVO 的应用区分为命名的和未命名的（即临时的）局部对象，限制了 RVO 术语应用到未命名对象上，并把对命名对象的应用称为**命名返回值优化**（named return value optimization，NRVO）。）

但是 RVO 就是个优化。编译器不被**要求**消除拷贝和移动操作，即使他们被允许这样做。或许你会疑惑，并担心编译器用拷贝操作惩罚你，因为它们确实可以这样。或者你可能有足够的了解，意识到有些情况很难让编译器实现 RVO，比如当函数不同控制路径返回不同局部变量时。（编译器必须产生一些代码在分配的函数返回值的内存中构造适当的局部变量，但是编译器如何确定哪个变量是合适的呢？）如果这样，你可能会愿意以移动的代价来保证不会产生拷贝。那就是，极可能仍然认为应用 `std::move` 到一个要返回的局部对象上是合理的，只因为可以不再担心拷贝的代价。

那种情况下，应用 `std::move` 到一个局部对象上**仍然**是一个坏主意。C++ 标准关于 RVO 的部分表明，如果满足 RVO 的条件，但是编译器选择不执行拷贝消除，则返回的对象**必须被视为右值**。实际上，标准要求当 RVO 被允许时，或者实行拷贝消除，或者将 `std::move` 隐式应用于返回的局部对象。

这意味着，如果对从按值返回的函数返回来的局部对象使用 `std::move`，你并不能帮助编译器（如果不能实行拷贝消除的话，他们必须把局部对象看做右值），而是阻碍其执行优化选项（通过阻止 RVO）。在某些情况下，将 `std::move` 应用于局部变量可能是一件合理的事（即，你把一个变量传给函数，并且知道不会再用这个变量），但是满足 RVO 的 `return` 语句或者返回一个传值形参并不在此列。

**请记住：**

- 最后一次使用时，在右值引用上使用 `std::move`，在通用引用上使用 `std::forward`
- 对按值返回的函数要返回的右值引用和通用引用，执行相同的操作
- 如果局部对象可以被返回值优化消除，就绝不使用 `std::move` 或者 `std::forward`

## Item 26：避免在通用引用上重载

使用通用引用的函数在 C++ 中是最贪婪的函数。它们几乎可以精确匹配任何类型的实参（极少不适用的实参在 Item 30 中介绍）。这也是把重载和通用引用组合在一块是糟糕主意的原因：通用引用的实现会匹配比开发者预期要多得多的实参类型。

一个更容易掉入这种陷阱的例子是写一个完美转发构造函数。

当继承纳入考虑范围时，完美转发的构造函数与编译器生成的拷贝、移动操作之间的交互会更加复杂。尤其是，派生类的拷贝和移动操作的传统实现会表现得非常奇怪。

```c++
class SpecialPerson: public Person {
public:
    SpecialPerson(const SpecialPerson& rhs) //拷贝构造函数，调用基类的
    : Person(rhs)                           //完美转发构造函数！
    { … }

    SpecialPerson(SpecialPerson&& rhs)      //移动构造函数，调用基类的
    : Person(std::move(rhs))                //完美转发构造函数！
    { … }
};
```

**请记住：**

- 对通用引用形参的函数进行重载，通用引用函数的调用机会几乎总会比你期望的多得多
- 完美转发构造函数是糟糕的实现，因为对于 non-`const` 左值，它们比拷贝构造函数而更匹配，而且会劫持派生类对于基类的拷贝和移动构造函数的调用

## Item 27：熟悉通用引用重载的替代方法

### 放弃重载

这些函数可以使用不同的名字来避免在通用引用上的重载的弊端。例如两个重载的 `logAndAdd` 函数，可以分别改名为 `logAndAddName` 和 `logAndAddNameIdx`。但是，这种方式不能用在构造函数中，因为构造函数的名字被语言固定了（即构造函数名与类名相同）。

### 传递 `const T&`

一种替代方案是退回到C++98，然后将传递通用引用替换为传递 lvalue-refrence-to-const。缺点是效率不高。现在我们知道了通用引用和重载的相互关系，所以放弃一些效率来确保行为正确简单可能也是一种不错的折中。

### 传值

通常在不增加复杂性的情况下提高性能的一种方法是，将按传引用形参替换为按值传递，这是违反直觉的。

### 使用 tag dispatch

通过查看所有重载的所有形参以及调用点的所有传入实参，然后选择最优匹配的函数——考虑所有形参/实参的组合。通用引用通常提供了最优匹配，但是如果通用引用是包含其他**非**通用引用的形参列表的一部分，则非通用引用形参的较差匹配会使有一个通用引用的重载版本不被运行。这就是 *tag dispatch* 方法的基础。

即我们使用重载。其中一个函数接受通用引用。所以我们同时使用了重载和通用引用。但是每个函数接受第二个形参，表征传入的实参是否为整型。这第二个形参可以帮助我们避免陷入到 Item 26 中提到的麻烦中，因为我们将其安排为第二个实参决定选择哪个重载函数。

```c++
template<typename T>
void logAndAdd(T&& name)
{
    logAndAddImpl(
        std::forward<T>(name),
        std::is_integral<typename std::remove_reference<T>::type>()
    );
}

template<typename T>                            //非整型实参：添加到全局数据结构中
void logAndAddImpl(T&& name, std::false_type)	//译者注：高亮std::false_type
{
    auto now = std::chrono::system_clock::now();
    log(now, "logAndAdd");
    names.emplace(std::forward<T>(name));
}

std::string nameFromIdx(int idx);           //与条款26一样，整型实参：查找名字并用它调用logAndAdd
void logAndAddImpl(int idx, std::true_type) //译者注：高亮std::true_type
{
  logAndAdd(nameFromIdx(idx)); 
}
```

在这个设计中，类型 `std::true_type` 和 `std::false_type` 是“标签”（tag），其唯一目的就是强制重载解析按照我们的想法来执行。注意到我们甚至没有对这些参数进行命名。他们在运行时毫无用处，事实上我们希望编译器可以意识到这些标签形参没被使用，然后在程序执行时优化掉它们。（至少某些时候有些编译器会这样做。）通过创建标签对象，在 `logAndAdd` 内部将重载实现函数的调用“分发”（*dispatch*）给正确的重载。因此这个设计名称为：*tag dispatch*。这是模板元编程的标准构建模块，你对现代 C++ 库中的代码了解越多，你就会越多遇到这种设计。

### 约束使用通用引用的模板

这种情况，采用通用引用的重载函数通常比期望的更加贪心，虽然不像单个分派函数一样那么贪心，而又不满足使用 tag dispatch 的条件。你需要另外的技术，可以让你确定允许使用通用引用模板的条件。朋友，你需要的就是 `std::enable_if`。

`std::enable_if` 可以给你提供一种强制编译器执行行为的方法，像是特定模板不存在一样。这种模板被称为被**禁止**（disabled）。默认情况下，所有模板是**启用**的（enabled），但是使用 `std::enable_if` 可以使得仅在 `std::enable_if` 指定的条件满足时模板才启用。

```c++
class Person {
public:
    template<
        typename T,
        typename = std::enable_if_t<
            !std::is_base_of<Person, std::decay_t<T>>::value
            &&
            !std::is_integral<std::remove_reference_t<T>>::value
        >
    >
    explicit Person(T&& n)          //对于std::strings和可转化为
    : name(std::forward<T>(n))      //std::strings的实参的构造函数
    { … }

    explicit Person(int idx)        //对于整型实参的构造函数
    : name(nameFromIdx(idx))
    { … }

    …                               //拷贝、移动构造函数等

private:
    std::string name;
};
```

看！多么优美！好吧，优美之处只是对于那些迷信模板元编程之人，但是确实提出了不仅能工作的方法，而且极具技巧。因为使用了完美转发，所以具有最大效率，因为控制了通用引用与重载的结合而不是禁止它，这种技术可以被用于不可避免要用重载的情况（比如构造函数）。

### 折中

本条款提到的前三个技术——放弃重载、传递 `const T&`、传值——在函数调用中指定每个形参的类型。后两个技术——tag dispatch 和限制模板适用范围——使用完美转发，因此不需要指定形参类型。这一基本决定（是否指定类型）有一定后果。

通常，完美转发更有效率，因为它避免了仅仅去为了符合形参声明的类型而创建临时对象。

但是完美转发也有缺点。即使某些类型的实参可以传递给接受特定类型的函数，也无法完美转发。Item 30 中探索了完美转发失败的例子。

第二个问题是当客户传递无效参数时错误消息的可理解性。

在这个例子中，通用引用仅被转发一次（从 `Person` 构造函数到 `std::string` 构造函数），但是更复杂的系统中，在最终到达判断实参类型是否可接受的地方之前，通用引用会被多层函数调用转发。通用引用被转发的次数越多，产生的错误消息偏差就越大。许多开发者发现，这种特殊问题是发生在留有通用引用形参的接口上，这些接口以性能作为首要考虑点。

在 `Person` 这个例子中，我们知道完美转发函数的通用引用形参要作为 `std::string` 的初始化器，所以我们可以用 `static_assert` 来确认它可以起这个作用。`std::is_constructible` 这个 type trait 执行编译时测试，确定一个类型的对象是否可以用另一个不同类型（或多个类型）的对象（或多个对象）来构造，所以代码可以这样：

```c++
class Person {
public:
    template<                       //同之前一样
        typename T,
        typename = std::enable_if_t<
            !std::is_base_of<Person, std::decay_t<T>>::value
            &&
            !std::is_integral<std::remove_reference_t<T>>::value
        >
    >
    explicit Person(T&& n)
    : name(std::forward<T>(n))
    {
        //断言可以用T对象创建std::string
        static_assert(
        std::is_constructible<std::string, T>::value,
        "Parameter n can't be used to construct a std::string"
        );

        …               //通常的构造函数的工作写在这

    }
    
    …                   //Person类的其他东西（同之前一样）
};
```

如果客户代码尝试使用无法构造 `std::string` 的类型创建 `Person`，会导致指定的错误消息。不幸的是，在这个例子中，`static_assert` 在构造函数体中，但是转发的代码作为成员初始化列表的部分在检查之前。所以我使用的编译器，结果是由 `static_assert` 产生的清晰的错误消息在常规错误消息（多达 160 行以上那个）后出现。

**请记住：**

- 通用引用和重载的组合替代方案包括使用不同的函数名，通过 lvalue-reference-to-const 传递形参，按值传递形参，使用 tag dispatch。
- 通过 `std::enable_if` 约束模板，允许组合通用引用和重载使用，但它也控制了编译器在哪种条件下才使用通用引用重载。
- 通用引用参数通常具有高效率的优势，但是可用性就值得斟酌。

## Item 28：理解引用折叠

Item 23 中指出，当实参传递给模板函数时，被推导的模板形参 `T` 根据实参是左值还是右值来编码。但是那条款并没有提到只有当实参被用来实例化通用引用形参时，上述推导才会发生。对通用引用和左值/右值编码的观察意味着对于这个模板

```c++
template<typename T>
void func(T&& param);
```

不管传给 `param` 的实参是左值还是右值，模板形参 `T` 都会编码。

编码机制是简单的。当左值实参被传入时，`T` 被推导为左值引用。当右值被传入时，`T` 被推导为非引用。（请注意不对称性：左值被编码为左值引用，右值被编码为**非引用**。）

在我们更加深入 `std::forward` 和通用引用之前，必须明确在 C++ 中引用的引用是非法的。

禁止**程序员**声明引用的引用，但是**编译器**会在特定的上下文中产生这些，模板实例化就是其中一种情况。当编译器生成引用的引用时，引用折叠指导下一步发生什么。

存在两种类型的引用（左值和右值），所以有四种可能的引用组合（左值的左值，左值的右值，右值的右值，右值的左值）。如果一个上下文中允许引用的引用存在（比如，模板的实例化），引用根据（reference collapsing）规则折叠为单个引用：

    如果任一引用为左值引用，则结果为左值引用。否则（即，如果引用都是右值引用），结果为右值引用。

引用折叠是 `std::forward` 工作的一种关键机制。

```c++
template<typename T>                        //C++14；仍然在std命名空间
T&& forward(remove_reference_t<T>& param)
{
  return static_cast<T&&>(param);
}
```

引用折叠发生在四种情况下。

1. 也是最常见的就是模板实例化。
2. 是 `auto` 变量的类型生成，具体细节类似于模板，因为 `auto` 变量的类型推导基本与模板类型推导雷同（参见 Item 2）。

通用引用不是一种新的引用，它实际上是满足以下两个条件下的右值引用：

- **类型推导区分左值和右值**。T类型的左值被推导为T&类型，T类型的右值被推导为T。
- **发生引用折叠**。

通用引用的概念是有用的，因为它使你不必一定意识到引用折叠的存在，从直觉上推导左值和右值的不同类型，在凭直觉把推导的类型代入到它们出现的上下文中之后应用引用折叠规则。

3. `typedef` 和别名声明的产生和使用中（参见 Item 9）。如果，在创建或者评估 `typedef` 过程中出现了引用的引用，则引用折叠就会起作用。
4. `decltype` 使用的情况。如果在分析 `decltype` 期间，出现了引用的引用，引用折叠规则就会起作用（关于 `decltype`，参见 Item 3）

**请记住：**

- 引用折叠发生在四种情况下：模板实例化，`auto` 类型推导，`typedef` 与别名声明的创建和使用，`decltype`。
- 当编译器在引用折叠环境中生成了引用的引用时，结果就是单个引用。有左值引用折叠结果就是左值引用，否则就是右值引用。
- 通用引用就是在特定上下文的右值引用，上下文是通过类型推导区分左值还是右值，并且发生引用折叠的那些地方。

## Item 29：认识移动操作的缺点

移动语义可以说是 C++11 最主要的特性。你可能会见过这些类似的描述“移动容器和拷贝指针一样开销小”， “拷贝临时对象现在如此高效，写代码避免这种情况简直就是过早优化”。这种情绪很容易理解。移动语义确实是这样重要的特性。它不仅允许编译器使用开销小的移动操作代替大开销的复制操作，而且默认这么做（当特定条件满足的时候）。以 C++98 的代码为基础，使用 C++11 重新编译你的代码，然后，哇，你的软件运行的更快了。

移动语义确实可以做这些事，这把这个特性封为一代传说。但是传说总有些夸大成分。这个条款的目的就是给你泼一瓢冷水，保持理智看待移动语义。

让我们从已知很多类型不支持移动操作开始这个过程。为了升级到 C++11，C++98 的很多标准库做了大修改，为很多类型提供了移动的能力，这些类型的移动实现比复制操作更快，并且对库的组件实现修改以利用移动操作。但是很有可能你工作中的代码没有完整地利用 C++11。对于你的应用中（或者代码库中）的类型，没有适配 C++11 的部分，编译器即使支持移动语义也是无能为力的。的确，C++11 倾向于为缺少移动操作的类生成它们，但是只有在没有声明复制操作，移动操作，或析构函数的类中才会生成移动操作（参考 Item 17）。数据成员或者某类型的基类禁止移动操作（比如通过 `delete` 移动操作，参考 Item 11），编译器不生成移动操作的支持。对于没有明确支持移动操作的类型，并且不符合编译器默认生成的条件的类，没有理由期望 C++11 会比 C++98 进行任何性能上的提升。

即使显式支持了移动操作，结果可能也没有你希望的那么好。比如，所有 C++11 的标准库容器都支持了移动操作，但是认为移动所有容器的开销都非常小是个错误。对于某些容器来说，压根就不存在开销小的方式来移动它所包含的内容。对另一些容器来说，容器的开销真正小的移动操作会有些容器元素不能满足的注意条件。

考虑一下 `std::array`，这是 C++11 中的新容器。`std::array` 本质上是具有 STL 接口的内置数组。这与其他标准容器将内容存储在堆内存不同。存储具体数据在堆内存的容器，本身只保存了指向堆内存中容器内容的指针（真正实现当然更复杂一些，但是基本逻辑就是这样）。这个指针的存在使得在常数时间移动整个容器成为可能，只需要从源容器拷贝保存指向容器内容的指针到目标容器，然后将源指针置为空指针就可以了。

`std::array` 没有这种指针实现，数据就保存在 `std::array` 对象中。

假定 `Widget` 类的移动操作比复制操作快，移动 `Widget` 的 `std::array` 就比复制要快。所以 `std::array` 确实支持移动操作。但是使用 `std::array` 的移动操作还是复制操作都将花费线性时间的开销，因为每个容器中的元素终归需要拷贝或移动一次，这与“移动一个容器就像操作几个指针一样方便”的含义相去甚远。

另一方面，`std::string` 提供了常数时间的移动操作和线性时间的复制操作。这听起来移动比复制快多了，但是可能不一定。许多字符串的实现采用了小字符串优化（small string optimization，SSO）。“小”字符串（比如长度小于 15 个字符的）存储在了 `std::string` 的缓冲区中，并没有存储在堆内存，移动这种存储的字符串并不比复制操作更快。

SSO 的动机是大量证据表明，短字符串是大量应用使用的习惯。使用内存缓冲区存储而不分配堆内存空间，是为了更好的效率。然而这种内存管理的效率导致移动的效率并不比复制操作高，即使一个半吊子程序员也能看出来对于这样的字符串，拷贝并不比移动慢。

即使对于支持快速移动操作的类型，某些看似可靠的移动操作最终也会导致复制。Item 14 解释了原因，标准库中的某些容器操作提供了强大的异常安全保证，确保依赖那些保证的 C++98 的代码在升级到 C++11 且仅当移动操作不会抛出异常，从而可能替换操作时，不会不可运行。结果就是，即使类提供了更具效率的移动操作，而且即使移动操作更合适（比如源对象是右值），编译器仍可能被迫使用复制操作，因为移动操作没有声明 `noexcept`。

因此，存在几种情况，C++11 的移动语义并无优势：

- **没有移动操作**：要移动的对象没有提供移动操作，所以移动的写法也会变成复制操作。
- **移动不会更快**：要移动的对象提供的移动操作并不比复制速度更快。
- **移动不可用**：进行移动的上下文要求移动操作不会抛出异常，但是该操作没有被声明为 `noexcept`。

值得一提的是，还有另一个场景，会使得移动并没有那么有效率：

- **源对象是左值**：除了极少数的情况外（例如Item25），只有右值可以作为移动操作的来源。

但是该条款的标题是假定移动操作不存在，成本高，未被使用。这就是通用代码中的典型情况，比如编写模板代码，因为你不清楚你处理的具体类型是什么。在这种情况下，你必须像出现移动语义之前那样，像在 C++98 里一样保守地去复制对象。“不稳定的”代码也是如此，即那些由于经常被修改导致类型特性变化的源代码。

但是，通常，你了解你代码里使用的类型，依赖他们的特性不变性（比如是否支持快速移动操作）。这种情况，你无需这个条款的假设，只需要查找所用类型的移动操作详细信息。如果类型提供了快速移动操作，并且在调用移动操作的上下文中使用对象，可以安全的使用快速移动操作替换复制操作。

**请记住：**

- 假定移动操作不存在，成本高，未被使用。
- 在已知的类型或者支持移动语义的代码中，就不需要上面的假设。

## Item 30：熟悉完美转发失败的情况

“转发”仅表示将一个函数的形参传递——就是**转发**——给另一个函数。对于第二个函数（被传递的那个）目标是收到与第一个函数（执行传递的那个）完全相同的对象。这规则排除了按值传递的形参，因为它们是原始调用者传入内容的**拷贝**。我们希望被转发的函数能够使用最开始传进来的那些对象。指针形参也被排除在外，因为我们不想强迫调用者传入指针。关于通常目的的转发，我们将处理引用形参。

**完美转发**（*perfect forwarding*）意味着我们不仅转发对象，我们还转发显著的特征：它们的类型，是左值还是右值，是 `const` 还是 `volatile`。结合到我们会处理引用形参，这意味着我们将使用通用引用（参见 Item 24），因为通用引用形参被传入实参时才确定是左值还是右值。

```c++
template<typename... Ts>
void fwd(Ts&&... params)            //接受任何实参
{
    f(std::forward<Ts>(params)...); //转发给f
}
```

这种形式你会在标准化容器置入函数（emplace functions）中（参见 Item 42）和智能指针的工厂函数 `std::make_unique` 和 `std::make_shared` 中（参见 Item 21）看到，当然还有其他一些地方。

给定我们的目标函数 `f` 和转发函数 `fwd`，如果 `f` 使用某特定实参会执行某个操作，但是 `fwd` 使用相同的实参会执行不同的操作，完美转发就会失败

```c++
f( expression );        //调用f执行某个操作
fwd( expression );		//但调用fwd执行另一个操作，则fwd不能完美转发expression给f
```

导致这种失败的实参种类有很多。知道它们是什么以及如何解决它们很重要，因此让我们来看看无法做到完美转发的实参类型。

### 花括号初始化器

```c++
void f(const std::vector<int>& v);

f({ 1, 2, 3 });         //可以，“{1, 2, 3}”隐式转换为std::vector<int>

fwd({ 1, 2, 3 });       //错误！不能编译
```

当通过调用函数模板 `fwd` 间接调用 `f` 时，编译器不再把调用地传入给 `fwd` 的实参和 `f` 的声明中形参类型进行比较。而是**推导**传入给 `fwd` 的实参类型，然后比较推导后的实参类型和 `f` 的形参声明类型。当下面情况任何一个发生时，完美转发就会失败：

- **编译器不能推导出 `fwd` 的一个或者多个形参类型。**这种情况下代码无法编译。
- **编译器推导“错”了 `fwd` 的一个或者多个形参类型。**在这里，“错误”可能意味着 `fwd` 的实例将无法使用推导出的类型进行编译，但是也可能意味着使用 `fwd` 的推导类型调用 `f`，与用传给 `fwd` 的实参直接调用 `f` 表现出不一致的行为。这种不同行为的原因可能是因为 `f` 是个重载函数的名字，并且由于是“不正确的”类型推导，在 `fwd` 内部调用的 `f` 重载和直接调用的 `f` 重载不一样。

在上面的 `fwd({ 1, 2, 3 })` 例子中，问题在于，将花括号初始化传递给未声明为 `std::initializer_list` 的函数模板形参，被判定为——就像标准说的——“非推导上下文”。简单来讲，这意味着编译器不准在对 `fwd` 的调用中推导表达式 `{ 1, 2, 3 }` 的类型，因为 `fwd` 的形参没有声明为 `std::initializer_list`。对于 `fwd` 形参的推导类型被阻止，编译器只能拒绝该调用。

有趣的是，Item 2 说明了使用花括号初始化的 `auto` 的变量的类型推导是成功的。这种变量被视为 `std::initializer_list` 对象，在转发函数应推导出类型为 `std::initializer_list` 的情况，这提供了一种简单的解决方法——使用 `auto` 声明一个局部变量，然后将局部变量传进转发函数：

```c++
auto il = { 1, 2, 3 };  //il的类型被推导为std::initializer_list<int>
fwd(il);                //可以，完美转发il给f
```

### `0` 或者 `NULL` 作为空指针

Item 8 说明当你试图传递 `0` 或者 `NULL` 作为空指针给模板时，类型推导会出错，会把传来的实参推导为一个整型类型（典型情况为 `int`）而不是指针类型。结果就是不管是 `0` 还是 `NULL` 都不能作为空指针被完美转发。解决方法非常简单，传一个 `nullptr` 而不是 `0` 或者 `NULL`。

### 仅有声明的整型 `static const` 数据成员

通常，无需在类中定义整型 `static const` 数据成员；声明就可以了。这是因为编译器会对此类成员实行**常量传播**（*const propagation*），因此消除了保留内存的需要。

```c++
class Widget {
public:
    static const std::size_t MinVals = 28;  //MinVal的声明
    ...
};
...                                         //没有MinVals定义

std::vector<int> widgetData;
widgetData.reserve(Widget::MinVals);        //使用MinVals

void f(std::size_t val);

f(Widget::MinVals);         //可以，视为“f(28)”

fwd(Widget::MinVals);       //错误！不应该链接
```

尽管代码中没有使用 `MinVals` 的地址，但是 `fwd` 的形参是通用引用，而引用，在编译器生成的代码中，通常被视作指针。在程序的二进制底层代码中（以及硬件中）指针和引用是一样的。在这个水平上，引用只是可以自动解引用的指针。在这种情况下，通过引用传递 `MinVals` 实际上与通过指针传递 `MinVals` 是一样的，因此，必须有内存使得指针可以指向。通过引用传递的整型 `static const` 数据成员，通常需要定义它们，这个要求可能会造成在不使用完美转发的代码成功的地方，使用等效的完美转发失败。（译者注：这里意思应该是没有定义，完美转发就会失败）

可能你也注意到了在上述讨论中我使用了一些模棱两可的词。代码“不应该”链接。引用“通常”被看做指针。传递整型 `static const` 数据成员“通常”要求定义。看起来就像有些事情我没有告诉你......

确实，根据标准，通过引用传递 `MinVals` 要求有定义。但不是所有的实现都强制要求这一点。所以，取决于你的编译器和链接器，你可能发现你可以在未定义的情况使用完美转发，恭喜你，但是这不是那样做的理由。为了具有可移植性，只要给整型 `static const` 提供一个定义，比如这样：

```c++
const std::size_t Widget::MinVals;  //在Widget的.cpp文件
```

注意定义中不要重复初始化（这个例子中就是赋值 `28`）。但是不要忽略这个细节。如果你忘了，并且在两个地方都提供了初始化，编译器就会报错，提醒你只能初始化一次。 

### 重载函数的名称和模板名称

```c++
void f(int (*pf)(int));             //pf = “process function”
void f(int pf(int));                //与上面定义相同的f

int processVal(int value);
int processVal(int value, int priority);

f(processVal);                      //可以

fwd(processVal);                    //错误！那个processVal？
```

工作的基本机制是 `f` 的声明让编译器识别出哪个是需要的 `processVal`。但是，`fwd` 是一个函数模板，没有它可接受的类型的信息，使得编译器不可能决定出哪个函数应被传递。

单用 `processVal` 是没有类型信息的，所以就不能类型推导，完美转发失败。

如果我们试图使用函数模板而不是（或者也加上）重载函数的名字，同样的问题也会发生。一个函数模板不代表单独一个函数，它表示一个函数族。

要让像 `fwd` 的完美转发函数接受一个重载函数名或者模板名，方法是指定要转发的那个重载或者实例。比如，你可以创造与 `f` 相同形参类型的函数指针，通过 `processVal` 或者 `workOnVal` 实例化这个函数指针（这可以引导选择正确版本的 `processVal` 或者产生正确的 `workOnVal` 实例），然后传递指针给 `fwd`：

```c++
using ProcessFuncType =                         //写个类型定义；见条款9
    int (*)(int);

ProcessFuncType processValPtr = processVal;     //指定所需的processVal签名

fwd(processValPtr);                             //可以
fwd(static_cast<ProcessFuncType>(workOnVal));   //也可以
```

当然，这要求你知道 `fwd` 转发的函数指针的类型。没有理由去假定完美转发函数会记录着这些东西。毕竟，完美转发被设计为接受任何内容，所以如果没有文档告诉你要传递什么，你又从何而知这些东西呢？

### 位域

完美转发最后一种失败的情况是函数实参使用位域这种类型。

```c++
struct IPv4Header {
    std::uint32_t version:4,
                  IHL:4,
                  DSCP:6,
                  ECN:2,
                  totalLength:16;
    ...
};

void f(std::size_t sz);         //要调用的函数

IPv4Header h;
...
f(h.totalLength);               //可以

fwd(h.totalLength);             //错误！
```

问题在于 `fwd` 的形参是引用，而 `h.totalLength` 是non-`const` 位域。听起来并不是那么糟糕，但是 C++ 标准非常清楚地谴责了这种组合：non-`const` 引用不应该绑定到位域。禁止的理由很充分。位域可能包含了机器字的任意部分（比如 32 位 `int` 的 3-5 位），但是这些东西无法直接寻址。我之前提到了在硬件层面引用和指针是一样的，所以没有办法创建一个指向任意 bit 的指针（C++ 规定你可以指向的最小单位是 `char`），同样没有办法绑定引用到任意 bit 上。

一旦意识到接收位域实参的函数都将接收位域的**副本**，就可以轻松解决位域不能完美转发的问题。毕竟，没有函数可以绑定引用到位域，也没有函数可以接受指向位域的指针，因为不存在这种指针。位域可以传给的形参种类只有按值传递的形参，有趣的是，还有 reference-to-`const`。在传值形参的情况中，被调用的函数接受了一个位域的副本；在传 reference-to-`const` 形参的情况中，标准要求这个引用实际上绑定到存放位域值的副本对象，这个对象是某种整型（比如 `int`）。reference-to-`const` 不直接绑定到位域，而是绑定位域值拷贝到的一个普通对象。

传递位域给完美转发的关键就是利用传给的函数接受的是一个副本的事实。你可以自己创建副本然后利用副本调用完美转发。在 `IPv4Header` 的例子中，可以如下写法：

```c++
//拷贝位域值；参看条款6了解关于初始化形式的信息
auto length = static_cast<std::uint16_t>(h.totalLength);

fwd(length);                    //转发这个副本
```

### 总结

在大多数情况下，完美转发工作的很好。你基本不用考虑其他问题。但是当其不工作时——当看起来合理的代码无法编译，或者更糟的是，虽能编译但无法按照预期运行时——了解完美转发的缺陷就很重要了。同样重要的是如何解决它们。在大多数情况下，都很简单。

**请记住：**

- 当模板类型推导失败或者推导出错误类型，完美转发会失败。
- 导致完美转发失败的实参种类有花括号初始化，作为空指针的 `0` 或者 `NULL`，仅有声明的整型 `static const` 数据成员，模板和重载函数的名字，位域。
