# 第五章 右值引用，移动语义，完美转发

- **移动语义**使编译器有可能用廉价的移动操作来代替昂贵的拷贝操作。正如拷贝构造函数和拷贝赋值操作符给了你控制拷贝语义的权力，移动构造函数和移动赋值操作符也给了你控制移动语义的权力。移动语义也允许创建只可移动（move-only）的类型，例如 `std::unique_ptr`，`std::future` 和 `std::thread`。

- **完美转发**使接收任意数量实参的函数模板成为可能，它可以将实参转发到其他的函数，使目标函数接收到的实参与被传递给转发函数的实参保持一致。

**右值引用**是连接这两个截然不同的概念的胶合剂。它是使移动语义和完美转发变得可能的基础语言机制。

牢记形参永远是左值，即使它的类型是一个右值引用。

## Item 23：理解 `std::move` 和 `std::forward`

`std::move` 不移动（move）任何东西，`std::forward` 也不转发（forward）任何东西。在运行时，它们不做任何事情。它们不产生任何可执行代码，一字节也没有。

`std::move` 和 `std::forward` 仅仅是执行转换（cast）的函数（事实上是函数模板）。`std::move` 无条件的将它的实参转换为右值，而 `std::forward` 只在特定情况满足时下进行转换。它们就是如此。

```c++
template<typename T>
decltype(auto) move(T&& param)          //C++14，在std命名空间
{
    using ReturnType = remove_referece_t<T>&&;
    return static_cast<ReturnType>(param);
}
```

1. 不要在你希望能移动对象的时候，声明它们为 `const`。对 `const` 对象的移动请求会悄无声息的被转化为拷贝操作。
2. `std::move` 不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动。关于 `std::move`，你能确保的唯一一件事就是将它应用到一个对象上，你能够得到一个右值。

与 `std::move` 总是无条件的将它的实参为右值不同，`std::forward` 只有在满足一定条件的情况下才执行转换。`std::forward` 是有条件的转换。

是否我们可以免于使用 `std::move` 而在任何地方只使用 `std::forward`？从纯技术的角度，答案是 yes：`std::forward` 是可以完全胜任，`std::move` 并非必须。

`std::move` 的吸引力在于它的便利性：减少了出错的可能性，增加了代码的清晰程度。

注意，第一，`std::move` 只需要一个函数实参，而 `std::forward` 不但需要一个函数实参，还需要一个模板类型实参。其次，我们传递给 `std::forward` 的类型应当是一个non-reference，因为惯例是传递的实参应该是一个右值（见 Item 28）。同样，这意味着 `std::move` 比起 `std::forward` 来说需要打更少的字，并且免去了传递一个表示我们正在传递一个右值的类型实参。同样，它根绝了我们传递错误类型的可能性。

更重要的是，`std::move` 的使用代表着无条件向右值的转换，而使用 `std::forward` 只对绑定了右值的引用进行到右值转换。这是两种完全不同的动作。前者是典型地为了移动操作，而后者只是传递（亦为转发）一个对象到另外一个函数，保留它原有的左值属性或右值属性。因为这些动作实在是差异太大，所以我们拥有两个不同的函数（以及函数名）来区分这些动作。

**请记住：**

- `std::move` 执行到右值的无条件的转换，但就自身而言，它不移动任何东西
- `std::forward` 只有当它的参数被绑定到一个右值时，才将参数转换为右值
- `std::move` 和 `std::forward` 在运行期什么也不做

## Item 24：区分通用引用与右值引用

事实上，`T&&` 有两种不同的意思。第一种，当然是右值引用。这种引用表现得正如你所期待的那样：它们只绑定到右值上，并且它们主要的存在原因就是为了识别可以移动操作的对象。

`T&&` 的另一种意思是，它既可以是右值引用，也可以是左值引用。这种引用在源码里看起来像右值引用（即 `T&&`），但是它们可以表现得像是左值引用（即 `T&`）。它们的二重性使它们既可以绑定到右值上（就像右值引用），也可以绑定到左值上（就像左值引用）。此外，它们还可以绑定到 `const` 或者 non-`const` 的对象上，也可以绑定到 `volatile` 或者non-`volatile` 的对象上，甚至可以绑定到既 `const` 又 `volatile` 的对象上。它们可以绑定到几乎任何东西。这种空前灵活的引用值得拥有自己的名字。我把它叫做通用引用（universal references）。（Item 25 解释了 `std::forward` 几乎总是可以应用到通用引用上，并且在这本书即将出版之际，一些 C++ 社区的成员已经开始将这种通用引用称之为转发引用（forwarding references））。


**请记住：**

- 如果一个函数模板形参的类型为 `T&&`，并且 `T` 需要被推导得知，或者如果一个对象被声明为 `auto&&`，这个形参或者对象就是一个通用引用
- 如果类型声明的形式不是标准的 `type&&`，或者如果类型推导没有发生，那么 `type&&` 代表一个右值引用
- 通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用

## Item 25：对右值引用使用 `std::move`，对通用引用使用 `std::forward`

右值引用仅绑定可以移动的对象。另一方面，通用**引用**可能绑定到有资格移动的对象上。通用引用使用右值初始化时，才将其强制转换为右值。

总而言之，当把右值引用转发给其他函数时，右值引用应该被**无条件转换**为右值（通过 `std::move`），因为它们**总是**绑定到右值；当转发通用引用时，通用引用应该**有条件地转换**为右值（通过 `std::forward`），因为它们只是有时绑定到右值。

如果你在**按值**返回的函数中，返回值绑定到右值引用或者通用引用上，需要对返回的引用使用 `std::move` 或者 `std::forward`。

```c++
Widget makeWidget()                 //makeWidget的“拷贝”版本
{
    Widget w;                       //局部对象
    …                               //配置w
    return w;                       //“拷贝”w到返回值中
}
```

```c++
Widget makeWidget()                 //makeWidget的移动版本
{
    Widget w;
    …
    return std::move(w);            //移动w到返回值中（不要这样做！）
}
```

这是错的，因为对于这种优化，标准化委员会远领先于开发者。早就为人认识到的是，`makeWidget` 的“拷贝”版本可以避免复制局部变量 `w` 的需要，通过在分配给函数返回值的内存中构造 `w` 来实现。这就是所谓的**返回值优化**（return value optimization，RVO），这在C++标准中已经实现了。

对这种好事遣词表达是个讲究活，因为你想只在那些不影响软件外在行为的地方允许这样的**拷贝消除**（copy elision）。对标准中教条的（也可以说是有毒的）絮叨做些解释，这个特定的好事就是说，编译器可能会在按值返回的函数中消除对局部对象的拷贝（或者移动），如果满足

1. 局部对象与函数返回值的类型相同
2. 局部对象就是要返回的东西（适合的局部对象包括大多数局部变量，还有作为 `return` 语句的一部分而创建的临时对象。函数形参不满足要求。一些人将 RVO 的应用区分为命名的和未命名的（即临时的）局部对象，限制了 RVO 术语应用到未命名对象上，并把对命名对象的应用称为**命名返回值优化**（named return value optimization，NRVO）。）

但是 RVO 就是个优化。编译器不被**要求**消除拷贝和移动操作，即使他们被允许这样做。或许你会疑惑，并担心编译器用拷贝操作惩罚你，因为它们确实可以这样。或者你可能有足够的了解，意识到有些情况很难让编译器实现 RVO，比如当函数不同控制路径返回不同局部变量时。（编译器必须产生一些代码在分配的函数返回值的内存中构造适当的局部变量，但是编译器如何确定哪个变量是合适的呢？）如果这样，你可能会愿意以移动的代价来保证不会产生拷贝。那就是，极可能仍然认为应用 `std::move` 到一个要返回的局部对象上是合理的，只因为可以不再担心拷贝的代价。

那种情况下，应用 `std::move` 到一个局部对象上**仍然**是一个坏主意。C++ 标准关于 RVO 的部分表明，如果满足 RVO 的条件，但是编译器选择不执行拷贝消除，则返回的对象**必须被视为右值**。实际上，标准要求当 RVO 被允许时，或者实行拷贝消除，或者将 `std::move` 隐式应用于返回的局部对象。

这意味着，如果对从按值返回的函数返回来的局部对象使用 `std::move`，你并不能帮助编译器（如果不能实行拷贝消除的话，他们必须把局部对象看做右值），而是阻碍其执行优化选项（通过阻止 RVO）。在某些情况下，将 `std::move` 应用于局部变量可能是一件合理的事（即，你把一个变量传给函数，并且知道不会再用这个变量），但是满足 RVO 的 `return` 语句或者返回一个传值形参并不在此列。

**请记住：**

- 最后一次使用时，在右值引用上使用 `std::move`，在通用引用上使用 `std::forward`
- 对按值返回的函数要返回的右值引用和通用引用，执行相同的操作
- 如果局部对象可以被返回值优化消除，就绝不使用 `std::move` 或者 `std::forward`

## Item 26：避免在通用引用上重载

使用通用引用的函数在 C++ 中是最贪婪的函数。它们几乎可以精确匹配任何类型的实参（极少不适用的实参在 Item 30 中介绍）。这也是把重载和通用引用组合在一块是糟糕主意的原因：通用引用的实现会匹配比开发者预期要多得多的实参类型。

一个更容易掉入这种陷阱的例子是写一个完美转发构造函数。

当继承纳入考虑范围时，完美转发的构造函数与编译器生成的拷贝、移动操作之间的交互会更加复杂。尤其是，派生类的拷贝和移动操作的传统实现会表现得非常奇怪。

```c++
class SpecialPerson: public Person {
public:
    SpecialPerson(const SpecialPerson& rhs) //拷贝构造函数，调用基类的
    : Person(rhs)                           //完美转发构造函数！
    { … }

    SpecialPerson(SpecialPerson&& rhs)      //移动构造函数，调用基类的
    : Person(std::move(rhs))                //完美转发构造函数！
    { … }
};
```

**请记住：**

- 对通用引用形参的函数进行重载，通用引用函数的调用机会几乎总会比你期望的多得多
- 完美转发构造函数是糟糕的实现，因为对于 non-`const` 左值，它们比拷贝构造函数而更匹配，而且会劫持派生类对于基类的拷贝和移动构造函数的调用

## Item 27：熟悉通用引用重载的替代方法

### 放弃重载

这些函数可以使用不同的名字来避免在通用引用上的重载的弊端。例如两个重载的 `logAndAdd` 函数，可以分别改名为 `logAndAddName` 和 `logAndAddNameIdx`。但是，这种方式不能用在构造函数中，因为构造函数的名字被语言固定了（即构造函数名与类名相同）。

### 传递 `const T&`

一种替代方案是退回到C++98，然后将传递通用引用替换为传递 lvalue-refrence-to-const。缺点是效率不高。现在我们知道了通用引用和重载的相互关系，所以放弃一些效率来确保行为正确简单可能也是一种不错的折中。

### 传值

通常在不增加复杂性的情况下提高性能的一种方法是，将按传引用形参替换为按值传递，这是违反直觉的。

### 使用 tag dispatch

通过查看所有重载的所有形参以及调用点的所有传入实参，然后选择最优匹配的函数——考虑所有形参/实参的组合。通用引用通常提供了最优匹配，但是如果通用引用是包含其他**非**通用引用的形参列表的一部分，则非通用引用形参的较差匹配会使有一个通用引用的重载版本不被运行。这就是 *tag dispatch* 方法的基础。

即我们使用重载。其中一个函数接受通用引用。所以我们同时使用了重载和通用引用。但是每个函数接受第二个形参，表征传入的实参是否为整型。这第二个形参可以帮助我们避免陷入到 Item 26 中提到的麻烦中，因为我们将其安排为第二个实参决定选择哪个重载函数。

```c++
template<typename T>
void logAndAdd(T&& name)
{
    logAndAddImpl(
        std::forward<T>(name),
        std::is_integral<typename std::remove_reference<T>::type>()
    );
}

template<typename T>                            //非整型实参：添加到全局数据结构中
void logAndAddImpl(T&& name, std::false_type)	//译者注：高亮std::false_type
{
    auto now = std::chrono::system_clock::now();
    log(now, "logAndAdd");
    names.emplace(std::forward<T>(name));
}

std::string nameFromIdx(int idx);           //与条款26一样，整型实参：查找名字并用它调用logAndAdd
void logAndAddImpl(int idx, std::true_type) //译者注：高亮std::true_type
{
  logAndAdd(nameFromIdx(idx)); 
}
```

在这个设计中，类型 `std::true_type` 和 `std::false_type` 是“标签”（tag），其唯一目的就是强制重载解析按照我们的想法来执行。注意到我们甚至没有对这些参数进行命名。他们在运行时毫无用处，事实上我们希望编译器可以意识到这些标签形参没被使用，然后在程序执行时优化掉它们。（至少某些时候有些编译器会这样做。）通过创建标签对象，在 `logAndAdd` 内部将重载实现函数的调用“分发”（*dispatch*）给正确的重载。因此这个设计名称为：*tag dispatch*。这是模板元编程的标准构建模块，你对现代 C++ 库中的代码了解越多，你就会越多遇到这种设计。

### 约束使用通用引用的模板

这种情况，采用通用引用的重载函数通常比期望的更加贪心，虽然不像单个分派函数一样那么贪心，而又不满足使用 tag dispatch 的条件。你需要另外的技术，可以让你确定允许使用通用引用模板的条件。朋友，你需要的就是 `std::enable_if`。

`std::enable_if` 可以给你提供一种强制编译器执行行为的方法，像是特定模板不存在一样。这种模板被称为被**禁止**（disabled）。默认情况下，所有模板是**启用**的（enabled），但是使用 `std::enable_if` 可以使得仅在 `std::enable_if` 指定的条件满足时模板才启用。

```c++
class Person {
public:
    template<
        typename T,
        typename = std::enable_if_t<
            !std::is_base_of<Person, std::decay_t<T>>::value
            &&
            !std::is_integral<std::remove_reference_t<T>>::value
        >
    >
    explicit Person(T&& n)          //对于std::strings和可转化为
    : name(std::forward<T>(n))      //std::strings的实参的构造函数
    { … }

    explicit Person(int idx)        //对于整型实参的构造函数
    : name(nameFromIdx(idx))
    { … }

    …                               //拷贝、移动构造函数等

private:
    std::string name;
};
```

看！多么优美！好吧，优美之处只是对于那些迷信模板元编程之人，但是确实提出了不仅能工作的方法，而且极具技巧。因为使用了完美转发，所以具有最大效率，因为控制了通用引用与重载的结合而不是禁止它，这种技术可以被用于不可避免要用重载的情况（比如构造函数）。

### 折中

本条款提到的前三个技术——放弃重载、传递 `const T&`、传值——在函数调用中指定每个形参的类型。后两个技术——tag dispatch 和限制模板适用范围——使用完美转发，因此不需要指定形参类型。这一基本决定（是否指定类型）有一定后果。

通常，完美转发更有效率，因为它避免了仅仅去为了符合形参声明的类型而创建临时对象。

但是完美转发也有缺点。即使某些类型的实参可以传递给接受特定类型的函数，也无法完美转发。Item 30 中探索了完美转发失败的例子。

第二个问题是当客户传递无效参数时错误消息的可理解性。

在这个例子中，通用引用仅被转发一次（从 `Person` 构造函数到 `std::string` 构造函数），但是更复杂的系统中，在最终到达判断实参类型是否可接受的地方之前，通用引用会被多层函数调用转发。通用引用被转发的次数越多，产生的错误消息偏差就越大。许多开发者发现，这种特殊问题是发生在留有通用引用形参的接口上，这些接口以性能作为首要考虑点。

在 `Person` 这个例子中，我们知道完美转发函数的通用引用形参要作为 `std::string` 的初始化器，所以我们可以用 `static_assert` 来确认它可以起这个作用。`std::is_constructible` 这个 type trait 执行编译时测试，确定一个类型的对象是否可以用另一个不同类型（或多个类型）的对象（或多个对象）来构造，所以代码可以这样：

```c++
class Person {
public:
    template<                       //同之前一样
        typename T,
        typename = std::enable_if_t<
            !std::is_base_of<Person, std::decay_t<T>>::value
            &&
            !std::is_integral<std::remove_reference_t<T>>::value
        >
    >
    explicit Person(T&& n)
    : name(std::forward<T>(n))
    {
        //断言可以用T对象创建std::string
        static_assert(
        std::is_constructible<std::string, T>::value,
        "Parameter n can't be used to construct a std::string"
        );

        …               //通常的构造函数的工作写在这

    }
    
    …                   //Person类的其他东西（同之前一样）
};
```

如果客户代码尝试使用无法构造 `std::string` 的类型创建 `Person`，会导致指定的错误消息。不幸的是，在这个例子中，`static_assert` 在构造函数体中，但是转发的代码作为成员初始化列表的部分在检查之前。所以我使用的编译器，结果是由 `static_assert` 产生的清晰的错误消息在常规错误消息（多达 160 行以上那个）后出现。

**请记住：**

- 通用引用和重载的组合替代方案包括使用不同的函数名，通过 lvalue-reference-to-const 传递形参，按值传递形参，使用 tag dispatch。
- 通过 `std::enable_if` 约束模板，允许组合通用引用和重载使用，但它也控制了编译器在哪种条件下才使用通用引用重载。
- 通用引用参数通常具有高效率的优势，但是可用性就值得斟酌。

## Item 28：理解引用折叠

Item 23 中指出，当实参传递给模板函数时，被推导的模板形参 `T` 根据实参是左值还是右值来编码。但是那条款并没有提到只有当实参被用来实例化通用引用形参时，上述推导才会发生。对通用引用和左值/右值编码的观察意味着对于这个模板

```c++
template<typename T>
void func(T&& param);
```

不管传给 `param` 的实参是左值还是右值，模板形参 `T` 都会编码。

编码机制是简单的。当左值实参被传入时，`T` 被推导为左值引用。当右值被传入时，`T` 被推导为非引用。（请注意不对称性：左值被编码为左值引用，右值被编码为**非引用**。）

在我们更加深入 `std::forward` 和通用引用之前，必须明确在 C++ 中引用的引用是非法的。

禁止**程序员**声明引用的引用，但是**编译器**会在特定的上下文中产生这些，模板实例化就是其中一种情况。当编译器生成引用的引用时，引用折叠指导下一步发生什么。

存在两种类型的引用（左值和右值），所以有四种可能的引用组合（左值的左值，左值的右值，右值的右值，右值的左值）。如果一个上下文中允许引用的引用存在（比如，模板的实例化），引用根据（reference collapsing）规则折叠为单个引用：

    如果任一引用为左值引用，则结果为左值引用。否则（即，如果引用都是右值引用），结果为右值引用。

引用折叠是 `std::forward` 工作的一种关键机制。

```c++
template<typename T>                        //C++14；仍然在std命名空间
T&& forward(remove_reference_t<T>& param)
{
  return static_cast<T&&>(param);
}
```

引用折叠发生在四种情况下。

1. 也是最常见的就是模板实例化。
2. 是 `auto` 变量的类型生成，具体细节类似于模板，因为 `auto` 变量的类型推导基本与模板类型推导雷同（参见 Item 2）。

通用引用不是一种新的引用，它实际上是满足以下两个条件下的右值引用：

- **类型推导区分左值和右值**。T类型的左值被推导为T&类型，T类型的右值被推导为T。
- **发生引用折叠**。

通用引用的概念是有用的，因为它使你不必一定意识到引用折叠的存在，从直觉上推导左值和右值的不同类型，在凭直觉把推导的类型代入到它们出现的上下文中之后应用引用折叠规则。

3. `typedef` 和别名声明的产生和使用中（参见 Item 9）。如果，在创建或者评估 `typedef` 过程中出现了引用的引用，则引用折叠就会起作用。
4. `decltype` 使用的情况。如果在分析 `decltype` 期间，出现了引用的引用，引用折叠规则就会起作用（关于 `decltype`，参见 Item 3）

**请记住：**

- 引用折叠发生在四种情况下：模板实例化，`auto` 类型推导，`typedef` 与别名声明的创建和使用，`decltype`。
- 当编译器在引用折叠环境中生成了引用的引用时，结果就是单个引用。有左值引用折叠结果就是左值引用，否则就是右值引用。
- 通用引用就是在特定上下文的右值引用，上下文是通过类型推导区分左值还是右值，并且发生引用折叠的那些地方。

## Item 29：认识移动操作的缺点

移动语义可以说是 C++11 最主要的特性。你可能会见过这些类似的描述“移动容器和拷贝指针一样开销小”， “拷贝临时对象现在如此高效，写代码避免这种情况简直就是过早优化”。这种情绪很容易理解。移动语义确实是这样重要的特性。它不仅允许编译器使用开销小的移动操作代替大开销的复制操作，而且默认这么做（当特定条件满足的时候）。以 C++98 的代码为基础，使用 C++11 重新编译你的代码，然后，哇，你的软件运行的更快了。

移动语义确实可以做这些事，这把这个特性封为一代传说。但是传说总有些夸大成分。这个条款的目的就是给你泼一瓢冷水，保持理智看待移动语义。

让我们从已知很多类型不支持移动操作开始这个过程。为了升级到 C++11，C++98 的很多标准库做了大修改，为很多类型提供了移动的能力，这些类型的移动实现比复制操作更快，并且对库的组件实现修改以利用移动操作。但是很有可能你工作中的代码没有完整地利用 C++11。对于你的应用中（或者代码库中）的类型，没有适配 C++11 的部分，编译器即使支持移动语义也是无能为力的。的确，C++11 倾向于为缺少移动操作的类生成它们，但是只有在没有声明复制操作，移动操作，或析构函数的类中才会生成移动操作（参考 Item 17）。数据成员或者某类型的基类禁止移动操作（比如通过 `delete` 移动操作，参考 Item 11），编译器不生成移动操作的支持。对于没有明确支持移动操作的类型，并且不符合编译器默认生成的条件的类，没有理由期望 C++11 会比 C++98 进行任何性能上的提升。

即使显式支持了移动操作，结果可能也没有你希望的那么好。比如，所有 C++11 的标准库容器都支持了移动操作，但是认为移动所有容器的开销都非常小是个错误。对于某些容器来说，压根就不存在开销小的方式来移动它所包含的内容。对另一些容器来说，容器的开销真正小的移动操作会有些容器元素不能满足的注意条件。

考虑一下 `std::array`，这是 C++11 中的新容器。`std::array` 本质上是具有 STL 接口的内置数组。这与其他标准容器将内容存储在堆内存不同。存储具体数据在堆内存的容器，本身只保存了指向堆内存中容器内容的指针（真正实现当然更复杂一些，但是基本逻辑就是这样）。这个指针的存在使得在常数时间移动整个容器成为可能，只需要从源容器拷贝保存指向容器内容的指针到目标容器，然后将源指针置为空指针就可以了。

`std::array` 没有这种指针实现，数据就保存在 `std::array` 对象中。

假定 `Widget` 类的移动操作比复制操作快，移动 `Widget` 的 `std::array` 就比复制要快。所以 `std::array` 确实支持移动操作。但是使用 `std::array` 的移动操作还是复制操作都将花费线性时间的开销，因为每个容器中的元素终归需要拷贝或移动一次，这与“移动一个容器就像操作几个指针一样方便”的含义相去甚远。

另一方面，`std::string` 提供了常数时间的移动操作和线性时间的复制操作。这听起来移动比复制快多了，但是可能不一定。许多字符串的实现采用了小字符串优化（small string optimization，SSO）。“小”字符串（比如长度小于 15 个字符的）存储在了 `std::string` 的缓冲区中，并没有存储在堆内存，移动这种存储的字符串并不比复制操作更快。

SSO 的动机是大量证据表明，短字符串是大量应用使用的习惯。使用内存缓冲区存储而不分配堆内存空间，是为了更好的效率。然而这种内存管理的效率导致移动的效率并不比复制操作高，即使一个半吊子程序员也能看出来对于这样的字符串，拷贝并不比移动慢。

即使对于支持快速移动操作的类型，某些看似可靠的移动操作最终也会导致复制。Item 14 解释了原因，标准库中的某些容器操作提供了强大的异常安全保证，确保依赖那些保证的 C++98 的代码在升级到 C++11 且仅当移动操作不会抛出异常，从而可能替换操作时，不会不可运行。结果就是，即使类提供了更具效率的移动操作，而且即使移动操作更合适（比如源对象是右值），编译器仍可能被迫使用复制操作，因为移动操作没有声明 `noexcept`。

因此，存在几种情况，C++11 的移动语义并无优势：

- **没有移动操作**：要移动的对象没有提供移动操作，所以移动的写法也会变成复制操作。
- **移动不会更快**：要移动的对象提供的移动操作并不比复制速度更快。
- **移动不可用**：进行移动的上下文要求移动操作不会抛出异常，但是该操作没有被声明为 `noexcept`。

值得一提的是，还有另一个场景，会使得移动并没有那么有效率：

- **源对象是左值**：除了极少数的情况外（例如Item25），只有右值可以作为移动操作的来源。

但是该条款的标题是假定移动操作不存在，成本高，未被使用。这就是通用代码中的典型情况，比如编写模板代码，因为你不清楚你处理的具体类型是什么。在这种情况下，你必须像出现移动语义之前那样，像在 C++98 里一样保守地去复制对象。“不稳定的”代码也是如此，即那些由于经常被修改导致类型特性变化的源代码。

但是，通常，你了解你代码里使用的类型，依赖他们的特性不变性（比如是否支持快速移动操作）。这种情况，你无需这个条款的假设，只需要查找所用类型的移动操作详细信息。如果类型提供了快速移动操作，并且在调用移动操作的上下文中使用对象，可以安全的使用快速移动操作替换复制操作。

**请记住：**

- 假定移动操作不存在，成本高，未被使用。
- 在已知的类型或者支持移动语义的代码中，就不需要上面的假设。

## Item 30：熟悉完美转发失败的情况



**请记住：**

