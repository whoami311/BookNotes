# 第五章 右值引用，移动语义，完美转发

- **移动语义**使编译器有可能用廉价的移动操作来代替昂贵的拷贝操作。正如拷贝构造函数和拷贝赋值操作符给了你控制拷贝语义的权力，移动构造函数和移动赋值操作符也给了你控制移动语义的权力。移动语义也允许创建只可移动（move-only）的类型，例如 `std::unique_ptr`，`std::future` 和 `std::thread`。

- **完美转发**使接收任意数量实参的函数模板成为可能，它可以将实参转发到其他的函数，使目标函数接收到的实参与被传递给转发函数的实参保持一致。

**右值引用**是连接这两个截然不同的概念的胶合剂。它是使移动语义和完美转发变得可能的基础语言机制。

牢记形参永远是左值，即使它的类型是一个右值引用。

## Item 23：理解 `std::move` 和 `std::forward`

`std::move` 不移动（move）任何东西，`std::forward` 也不转发（forward）任何东西。在运行时，它们不做任何事情。它们不产生任何可执行代码，一字节也没有。

`std::move` 和 `std::forward` 仅仅是执行转换（cast）的函数（事实上是函数模板）。`std::move` 无条件的将它的实参转换为右值，而 `std::forward` 只在特定情况满足时下进行转换。它们就是如此。

```c++
template<typename T>
decltype(auto) move(T&& param)          //C++14，在std命名空间
{
    using ReturnType = remove_referece_t<T>&&;
    return static_cast<ReturnType>(param);
}
```

1. 不要在你希望能移动对象的时候，声明它们为 `const`。对 `const` 对象的移动请求会悄无声息的被转化为拷贝操作。
2. `std::move` 不仅不移动任何东西，而且它也不保证它执行转换的对象可以被移动。关于 `std::move`，你能确保的唯一一件事就是将它应用到一个对象上，你能够得到一个右值。

与 `std::move` 总是无条件的将它的实参为右值不同，`std::forward` 只有在满足一定条件的情况下才执行转换。`std::forward` 是有条件的转换。

是否我们可以免于使用 `std::move` 而在任何地方只使用 `std::forward`？从纯技术的角度，答案是 yes：`std::forward` 是可以完全胜任，`std::move` 并非必须。

`std::move` 的吸引力在于它的便利性：减少了出错的可能性，增加了代码的清晰程度。

注意，第一，`std::move` 只需要一个函数实参，而 `std::forward` 不但需要一个函数实参，还需要一个模板类型实参。其次，我们传递给 `std::forward` 的类型应当是一个non-reference，因为惯例是传递的实参应该是一个右值（见 Item 28）。同样，这意味着 `std::move` 比起 `std::forward` 来说需要打更少的字，并且免去了传递一个表示我们正在传递一个右值的类型实参。同样，它根绝了我们传递错误类型的可能性。

更重要的是，`std::move` 的使用代表着无条件向右值的转换，而使用 `std::forward` 只对绑定了右值的引用进行到右值转换。这是两种完全不同的动作。前者是典型地为了移动操作，而后者只是传递（亦为转发）一个对象到另外一个函数，保留它原有的左值属性或右值属性。因为这些动作实在是差异太大，所以我们拥有两个不同的函数（以及函数名）来区分这些动作。

**请记住：**

- `std::move` 执行到右值的无条件的转换，但就自身而言，它不移动任何东西
- `std::forward` 只有当它的参数被绑定到一个右值时，才将参数转换为右值
- `std::move` 和 `std::forward` 在运行期什么也不做

## Item 24：区分通用引用与右值引用

事实上，`T&&` 有两种不同的意思。第一种，当然是右值引用。这种引用表现得正如你所期待的那样：它们只绑定到右值上，并且它们主要的存在原因就是为了识别可以移动操作的对象。

`T&&` 的另一种意思是，它既可以是右值引用，也可以是左值引用。这种引用在源码里看起来像右值引用（即 `T&&`），但是它们可以表现得像是左值引用（即 `T&`）。它们的二重性使它们既可以绑定到右值上（就像右值引用），也可以绑定到左值上（就像左值引用）。此外，它们还可以绑定到 `const` 或者 non-`const` 的对象上，也可以绑定到 `volatile` 或者non-`volatile` 的对象上，甚至可以绑定到既 `const` 又 `volatile` 的对象上。它们可以绑定到几乎任何东西。这种空前灵活的引用值得拥有自己的名字。我把它叫做通用引用（universal references）。（Item 25 解释了 `std::forward` 几乎总是可以应用到通用引用上，并且在这本书即将出版之际，一些 C++ 社区的成员已经开始将这种通用引用称之为转发引用（forwarding references））。


**请记住：**

- 如果一个函数模板形参的类型为 `T&&`，并且 `T` 需要被推导得知，或者如果一个对象被声明为 `auto&&`，这个形参或者对象就是一个通用引用
- 如果类型声明的形式不是标准的 `type&&`，或者如果类型推导没有发生，那么 `type&&` 代表一个右值引用
- 通用引用，如果它被右值初始化，就会对应地成为右值引用；如果它被左值初始化，就会成为左值引用