# lambda 表达式

*lambda* 表达式是 C++ 编程中的游戏规则改变者。这有点令人惊讶，因为它没有给语言带来新的表达能力。lambda 可以做的所有事情都可以通过其他方式完成。但是 lambda 是创建函数对象相当便捷的一种方法，对于日常的 C++ 开发影响是巨大的。没有 lambda 时，STL中的“`_if`”算法（比如，`std::find_if`，`std::remove_if`，`std::count_if` 等）通常需要繁琐的谓词，但是当有 lambda 可用时，这些算法使用起来就变得相当方便。用比较函数（比如，`std::sort`，`std::nth_element`，`std::lower_bound` 等）来自定义算法也是同样方便的。在 STL 外，lambda 可以快速创建 `std::unique_ptr` 和 `std::shared_ptr` 的自定义删除器（见 Item 18 和 19），并且使线程 API 中条件变量的谓词指定变得同样简单（参见 Item 39）。除了标准库，lambda 有利于即时的回调函数，接口适配函数和特定上下文中的一次性函数。lambda 确实使 C++ 成为更令人愉快的编程语言。

与 lambda 相关的词汇可能会令人疑惑，这里做一下简单的回顾：

- **lambda 表达式**（lambda expression）就是一个表达式。下面是部分源代码。在

```c++
std::find_if(container.begin(), container.end(),
             [](int val){ return 0 < val && val < 10; });   //本行高亮
```

中，代码的高亮部分就是 lambda。

- **闭包**（*enclosure*）是 lambda 创建的运行时对象。依赖捕获模式，闭包持有被捕获数据的副本或者引用。在上面的 `std::find_if` 调用中，闭包是作为第三个实参在运行时传递给 `std::find_if` 的对象。

- **闭包类**（*closure class*）是从中实例化闭包的类。每个 lambda 都会使编译器生成唯一的闭包类。lambda 中的语句成为其闭包类的成员函数中的可执行指令。

lambda 通常被用来创建闭包，该闭包仅用作函数的实参。上面对 `std::find_if` 的调用就是这种情况。然而，闭包通常可以拷贝，所以可能有多个闭包对应于一个 lambda。

非正式的讲，模糊 lambda，闭包和闭包类之间的界限是可以接受的。但是，在随后的 Item 中，区分什么存在于编译期（lambdas 和闭包类），什么存在于运行时（闭包）以及它们之间的相互关系是重要的。

## Item 31：避免使用默认捕获模式

C++11 中有两种默认的捕获模式：按引用捕获和按值捕获。但默认按引用捕获模式可能会带来悬空引用的问题，而默认按值捕获模式可能会诱骗你让你以为能解决悬空引用的问题（实际上并没有），还会让你以为你的闭包是独立的（事实上也不是独立的）。

按引用捕获会导致闭包中包含了对某个局部变量或者形参的引用，变量或形参只在定义 lambda 的作用域中可用。如果该 lambda 创建的闭包生命周期超过了局部变量或者形参的生命周期，那么闭包中的引用将会变成悬空引用。

比起“`[&]`”传达的意思，显式捕获能让人更容易想起“确保没有悬空变量”。

如果你知道一个闭包将会被马上使用（例如被传入到一个 STL 算法中）并且不会被拷贝，那么在它的 lambda 被创建的环境中，将不会有闭包的引用比父函数的局部变量和形参活得长的风险。在这种情况下，你可能会争论说，没有悬空引用的危险，就不需要避免使用默认的引用捕获模式。

的确如此，这是安全的做法，但这种安全是不确定的。如果发现 lambda 在其它上下文中很有用，然后拷贝粘贴到一个捕获的变量已经死亡，但闭包生命周期还没结束的上下文中，你又回到了悬空的使用上了。同时，在该捕获语句中，也没有特别提醒了你注意分析捕获的变量的生命周期。

从长期来看，显式列出 lambda 依赖的局部变量和形参，是更加符合软件工程规范的做法。

在通常情况下，按值捕获并不能完全解决悬空引用的问题。这里的问题是如果你按值捕获的是一个指针，你将该指针拷贝到 lambda 对应的闭包里，但这样并不能避免 lambda 外 `delete` 这个指针的行为，从而导致你的副本指针变成悬空指针。

也许你要抗议说：“这不可能发生。看过了第 4 章，我对智能指针的使用非常热衷。只有那些失败的 C++98 的程序员才会用裸指针和 `delete`语句。”这也许是正确的，但却是不相关的，因为事实上你的确会使用裸指针，也的确存在被你 `delete` 的可能性。只不过在现代的 C++ 编程风格中，不容易在源代码中显露出来而已。

捕获只能应用于 lambda 被创建时所在作用域里的 non-`static` 局部变量（包括形参）。

在 C++14 中，一个更好的捕获成员变量的方式时使用通用的 lambda 捕获：

```c++
void Widget::addFilter() const
{
    filters.emplace_back(                   //C++14：
        [divisor = divisor](int value)      //拷贝divisor到闭包
        { return value % divisor == 0; }	//使用这个副本
    );
}
```

这种通用的 lambda 捕获并没有默认的捕获模式，因此在 C++14 中，本条款的建议——避免使用默认捕获模式——仍然是成立的。

使用默认的按值捕获还有另外的一个缺点，它们预示了相关的闭包是独立的并且不受外部数据变化的影响。一般来说，这是不对的。lambda 可能会依赖局部变量和形参（它们可能被捕获），还有**静态存储生命周期**（static storage duration）的对象。这些对象定义在全局空间或者命名空间，或者在类、函数、文件中声明为 `static`。这些对象也能在 lambda 里使用，但它们不能被捕获。但默认按值捕获可能会因此误导你，让你以为捕获了这些变量。

**请记住：**

- 默认的按引用捕获可能会导致悬空引用。
- 默认的按值捕获对于悬空指针很敏感（尤其是 `this` 指针），并且它会误导人产生 lambda 是独立的想法。

## Item 32：使用初始化捕获来移动对象到闭包中

在某些场景下，按值捕获和按引用捕获都不是你所想要的。如果你有一个只能被移动的对象（例如 `std::unique_ptr` 或 `std::future`）要进入到闭包里，使用 C++11 是无法实现的。如果你要复制的对象复制开销非常高，但移动的成本却不高（例如标准库中的大多数容器），并且你希望的是宁愿移动该对象到闭包而不是复制它。然而 C++11 却无法实现这一目标。

但那是 C++11 的时候。到了 C++14 就另一回事了，它能支持将对象移动到闭包中。

缺少移动捕获被认为是 C++11 的一个缺点，直接的补救措施是将该特性添加到 C++14 中，但标准化委员会选择了另一种方法。他们引入了一种新的捕获机制，该机制非常灵活，移动捕获是它可以执行的技术之一。新功能被称作**初始化捕获**（*init capture*），C++11 捕获形式能做的所有事它几乎可以做，甚至能完成更多功能。你不能用初始化捕获表达的东西是默认捕获模式，但 Item 31 说明提醒了你无论如何都应该远离默认捕获模式。（在 C++11 捕获模式所能覆盖的场景里，初始化捕获的语法有点不大方便。因此在 C++11 的捕获模式能完成所需功能的情况下，使用它是完全合理的）。

使用初始化捕获可以让你指定：

1. 从 lambda 生成的闭包类中的**数据成员名称**；
2. 初始化该成员的**表达式**；

这是使用初始化捕获将 `std::unique_ptr` 移动到闭包中的方法：

```c++
class Widget {                          //一些有用的类型
public:
    …
    bool isValidated() const;
    bool isProcessed() const;
    bool isArchived() const;
private:
    …
};

auto pw = std::make_unique<Widget>();   //创建Widget；使用std::make_unique
                                        //的有关信息参见条款21

...                                     //设置*pw

auto func = [pw = std::move(pw)]        //使用std::move(pw)初始化闭包数据成员
            { return pw->isValidated()
                     && pw->isArchived(); };
```

高亮的文本包含了初始化捕获的使用（译者注：高亮了 `pw = std::move(pw)`），`=` 的左侧是指定的闭包类中数据成员的名称，右侧则是初始化表达式。有趣的是，`=` 左侧的作用域不同于右侧的作用域。左侧的作用域是闭包类，右侧的作用域和 lambda 定义所在的作用域相同。在上面的示例中，`=` 左侧的名称 `pw` 表示闭包类中的数据成员，而右侧的名称 `pw` 表示在 lambda 上方声明的对象，即由调用 `std::make_unique` 去初始化的变量。因此，`pw = std::move(pw)` 的意思是“在闭包中创建一个数据成员 `pw`，并使用将 `std::move` 应用于局部变量 `pw` 的结果来初始化该数据成员”。

一般来说，lambda 主体中的代码在闭包类的作用域内，因此 `pw` 的使用指的是闭包类的数据成员。

在此示例中，注释“设置*pw”表示在由 `std::make_unique` 创建 `Widget` 之后，lambda 捕获到指向 `Widget` 的 `std::unique_ptr` 之前，该 `Widget` 以某种方式进行了修改。如果不需要这样的设置，即如果 `std::make_unique` 创建的 `Widget` 处于适合被 lambda 捕获的状态，则不需要局部变量 `pw`，因为闭包类的数据成员可以通过 `std::make_unique` 直接初始化：

```c++
auto func = [pw = std::make_unique<Widget>()]   //使用调用make_unique得到的结果
            { return pw->isValidated()          //初始化闭包数据成员
                     && pw->isArchived(); };
```

这清楚地表明了，这个 C++14 的捕获概念是从 C++11 发展出来的的，在 C++11 中，无法捕获表达式的结果。 因此，初始化捕获的另一个名称是通用 lambda 捕获（generalized lambda capture）。

但是，如果你使用的一个或多个编译器不支持C++14的初始捕获怎么办？ 如何使用不支持移动捕获的语言完成移动捕获？

如果你坚持要使用 lambda（并且考虑到它们的便利性，你可能会这样做），移动捕获可以在 C++11 中这样模拟：

1. **将要捕获的对象移动到由 `std::bind` 产生的函数对象中；**
2. **将“被捕获的”对象的引用赋予给 lambda。**

```c++
std::vector<double> data;               //同上

...                                     //同上

auto func =
    std::bind(                              //C++11模拟初始化捕获
        [](const std::vector<double>& data) //译者注：本行高亮
        { /*使用data*/ },
        std::move(data)                     //译者注：本行高亮
    );
```

默认情况下，从 lambda 生成的闭包类中的 `operator()` 成员函数为 `const` 的。这具有在 lambda 主体内把闭包中的所有数据成员渲染为 `const` 的效果。但是，`bind` 对象内部的移动构造的 `data` 副本不是 `const` 的，因此，为了防止在 lambda 内修改该 `data` 副本，lambda 的形参应声明为 reference-to-`const`。 如果将 lambda 声明为 `mutable`，则闭包类中的 `operator()` 将不会声明为 `const`，并且在 lambda 的形参声明中省略 `const`也是合适的：

```c++
auto func =
    std::bind(                                  //C++11对mutable lambda
        [](std::vector<double>& data) mutable	//初始化捕获的模拟
        { /*使用data*/ },
        std::move(data)
    );
```

因为 `bind` 对象存储着传递给 `std::bind` 的所有实参的副本，所以在我们的示例中，`bind` 对象包含由 lambda 生成的闭包副本，这是它的第一个实参。 因此闭包的生命周期与 `bind` 对象的生命周期相同。 这很重要，因为这意味着只要存在闭包，包含伪移动捕获对象的 `bind` 对象也将存在。

`std::bind` 的基本要点：

- 无法移动构造一个对象到 C++11 闭包，但是可以将对象移动构造进 C++11 的 `bind` 对象。
- 在 C++11 中模拟移动捕获包括将对象移动构造进 `bind` 对象，然后通过传引用将移动构造的对象传递给 lambda。
- 由于 `bind` 对象的生命周期与闭包对象的生命周期相同，因此可以将 `bind` 对象中的对象视为闭包中的对象。

作为使用 `std::bind` 模仿移动捕获的第二个示例，这是我们之前看到的在闭包中创建 `std::unique_ptr` 的 C++14 代码：

```c++
auto func = [pw = std::make_unique<Widget>()]   //同之前一样
            { return pw->isValidated()          //在闭包中创建pw
                     && pw->isArchived(); };
```

这是 C++11 的模拟实现：

```c++
auto func = std::bind(
                [](const std::unique_ptr<Widget>& pw)
                { return pw->isValidated()
                         && pw->isArchived(); },
                std::make_unique<Widget>()
            );
```

具备讽刺意味的是，这里我展示了如何使用 `std::bind` 解决 C++11 lambda 中的限制，因为在 Item 34 中，我主张使用 lambda 而不是 `std::bind`。但是，该条款解释的是在 C++11 中有些情况下 `std::bind` 可能有用，这就是其中一种。 （在 C++14 中，初始化捕获和 `auto` 形参等特性使得这些情况不再存在。）

**请记住：**

- 使用 C++14 的初始化捕获将对象移动到闭包中。
- 在 C++11 中，通过手写类或 `std::bind` 的方式来模拟初始化捕获。

## Item 33：对 `auto&&` 形参使用 `decltype` 以 `std::forward` 它们

**泛型 lambda**（*generic lambdas*）是 C++14 中最值得期待的特性之一——因为在 lambda 的形参中可以使用 `auto` 关键字。这个特性的实现是非常直截了当的：即在闭包类中的 `operator()` 函数是一个函数模板。

当传递给 lambda 形参 `x` 的是一个右值实参时，`decltype(x)` 可以产生一个右值引用。把一个左值传给 lambda 时，`decltype(x)` 会产生一个可以传给 `std::forward` 的常规类型。对于右值，把 `decltype(x)` 产生的类型传递给 `std::forward` 是非传统的，不过它产生的实例化结果与传统类型相同。所以无论是左值还是右值，把 `decltype(x)` 传递给 `std::forward` 都能得到我们想要的结果，因此 lambda 的完美转发可以写成：

```c++
auto f =
    [](auto&& param)
    {
        return
            func(normalize(std::forward<decltype(param)>(param)));
    };
```

再加上 6 个点，就可以让我们的lambda完美转发接受多个形参了，因为 C++14 中的 lambda 也可以是可变形参的：

```c++
auto f =
    [](auto&&... params)
    {
        return
            func(normalize(std::forward<decltype(params)>(params)...));
    };
```

**请记住：**

- 对 `auto&&` 形参使用 `decltype` 以 `std::forward` 它们。

## Item 34：考虑lambda而非std::bind

在 C++11 中，lambda 几乎总是比 `std::bind` 更好的选择。 从 C++14 开始，lambda 的作用不仅强大，而且是完全值得使用的。

`std::bind` 的工作方式：传递给 `bind` 对象的所有实参都是通过引用传递的，因为此类对象的函数调用运算符使用完美转发。

与 lambda 相比，使用 `std::bind` 进行编码的代码可读性较低，表达能力较低，并且效率可能较低。 在 C++14 中，没有 `std::bind` 的合理用例。 但是，在 C++11 中，可以在两个受约束的情况下证明使用 `std::bind` 是合理的：

- **移动捕获**。C++11 的 lambda 不提供移动捕获，但是可以通过结合 lambda 和 `std::bind` 来模拟。 有关详细信息，请参阅 Item 32，该条款还解释了在C++14中，lambda 对初始化捕获的支持消除了这个模拟的需求。
- **多态函数对象**。因为 `bind` 对象上的函数调用运算符使用完美转发，所以它可以接受任何类型的实参（以 Item 30 中描述的完美转发的限制为界限）。当你要绑定带有模板化函数调用运算符的对象时，此功能很有用。

**请记住：**

- 与使用 `std::bind` 相比，lambda 更易读，更具表达力并且可能更高效。
- 只有在 C++11 中，`std::bind` 可能对实现移动捕获或绑定带有模板化函数调用运算符的对象时会很有用。
